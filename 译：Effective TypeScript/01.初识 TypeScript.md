# 第一章 初识 TypeScript

在深入细节之前，本章将帮助你全面了解 TypeScript。它究竟是什么？你该如何理解它？它与 JavaScript 有何关联？它的类型系统是否可为空？any 类型是什么概念？鸭子类型又作何解？

TypeScript 是一门独特的语言，它既不在解释器中运行（如 Python 和 Ruby 那样），也不编译为底层语言（如 Java 和 C 那样）。相反，它被编译为另一种高级语言——JavaScript。实际运行的是这段 JavaScript 代码，而非你的 TypeScript 代码。因此，理解 TypeScript 与 JavaScript 的关系至关重要，这将帮助你成为更高效的 TypeScript 开发者。

TypeScript 的类型系统还具有一些需要特别注意的特殊性。后续章节将更详尽地探讨类型系统，但本章会重点介绍几个最关键的亮点。

即使你已经写过大量 TypeScript 代码，本章内容依然值得一读。它将帮助你建立对 TypeScript 及其类型系统运作方式的正确认知模型，并可能澄清一些你未曾察觉的误解。

## 第 1 条：理解 TypeScript 与 JavaScript 的关系

长期使用 TypeScript 的人必然会听到"TypeScript 是 JavaScript 的超集"或"TypeScript 是带类型注解的 JavaScript 超集"这类说法。但这究竟意味着什么？TypeScript 与 JavaScript 之间到底是怎样的关系？由于这两种语言紧密关联，深刻理解它们之间的关系是用好 TypeScript 的基础。

如果 B 中的所有内容都包含在 A 中，那么 A 就是 B 的"超集"。从语法层面而言，TypeScript 是 JavaScript 的超集：只要你的 JavaScript 程序没有语法错误，那么它同时也是 TypeScript 程序。TypeScript 的类型检查器很可能会对你的代码标记出一些问题，但这属于独立问题。TypeScript 仍会解析你的代码并生成 JavaScript。（这是两者关系的另一个关键点，我们将在第 3 条中深入探讨。）

TypeScript 文件使用.ts 扩展名，而非 JavaScript 文件的.js 扩展名。但这并不意味着 TypeScript 是完全不同的语言！由于 TypeScript 是 JavaScript 的超集，你.js 文件中的代码本质上已经是 TypeScript 了。将 main.js 重命名为 main.ts 并不会改变这一事实。

若要将现有 JavaScript 代码库迁移至 TypeScript，这一特性极具价值。这意味着您无需用其他语言重写任何代码，就能直接享受 TypeScript 带来的优势。若选择用 Java 等语言重写 JavaScript 代码则无法实现这一点。这种平滑的迁移路径正是 TypeScript 最出色的特性之一，第 10 章将对此展开更详细的探讨。

所有 JavaScript 程序都是合法的 TypeScript 程序，但反之则不成立：存在无法作为 JavaScript 运行的 TypeScript 程序。这是因为 TypeScript 添加了用于类型声明的额外语法（出于历史原因还包含少量其他语法元素，详见第 72 条）。

例如下面这段合法的 TypeScript 程序：

```ts
function greet(who: string) {
  console.log("Hello", who);
}
```

但通过 node 等期待纯 JavaScript 的运行环境执行时，就会报错：

```ts
function greet(who: string) { ^
// SyntaxError: Unexpected token :
```

\`: string\` 是一种特定于 TypeScript 的类型注解。一旦使用它，就意味着你已超越了原生 JavaScript 的范畴（参见图 1-1）。

![](https://cdn-mineru.openxlab.org.cn/extract/e2e3ff02-d22d-4f92-b62d-0f5b9dd49929/2f259f5013ccec837777d6245a81578e69693dddb29466c56ce89b1a76630657.jpg)
图 1-1. 所有 JavaScript 都是 TypeScript，但并非所有 TypeScript 都是 JavaScript。

这并不是说 TypeScript 对原生 JavaScript 程序没有价值。恰恰相反！例如下面这个 JavaScript 程序：

```ts
let city = "new york city";
console.log(city.toUppercase());
```

运行时会抛出错误：

> 类型错误：city.toUppercase 不是函数

尽管这段程序没有类型注解，但 TypeScript 的类型检查器依然能够发现问题所在：

```ts
let city = "new york city";
console.log(city.toUppercase());
// Property 'toUppercase' does not exist on type
// 'string'. Did you mean 'toUpperCase'?
```

你无需显式告知 TypeScript city 变量的类型是字符串：它通过初始值自动推导出了类型。类型推断是 TypeScript 的核心特性，第 3 章将深入探讨如何有效运用这一机制。

TypeScript 类型系统的核心目标之一，就是在不运行代码的情况下检测出可能导致运行时异常的代码。当人们将 TypeScript 描述为"静态"类型系统时，正是指这种能力。虽然类型检查器无法百分百捕获所有异常代码，但它始终在努力实现这一目标。

即使你的代码没有抛出异常，它仍可能不符合预期。TypeScript 也试图捕捉这类问题。例如，这个 JavaScript 程序：

```ts
const states = [
  { name: "Alabama", capital: "Montgomery" },
  { name: "Alaska", capital: "Juneau" },
  { name: "Arizona", capital: "Phoenix" },
  // ...
];
for (const state of states) {
  console.log(state.capitol);
}
```

将输出日志：

> undefined undefined undefined

糟糕！哪里出错了？这段程序是合法的 JavaScript（因此也是合法的 TypeScript）。运行时没有抛出任何错误，但显然没有达到预期效果。即便不添加类型注解，TypeScript 的类型检查器也能发现错误并提供有用提示：

```ts
for (const state of states) {
  console.log(state.capitol);
  // Property 'capitol' does not exist on type
  // '{ name: string; capital: string; }'.
  // Did you mean 'capital'?
}
```

事实上，我们确实指的是带字母"a"的 capital（首都）。州和国家拥有的是带"a"的 capital（首都）城市，而立法机构则在带"o"的 capitol（国会大厦）建筑中开会。

虽然 TypeScript 即使在没有类型注解的情况下也能捕获错误，但若提供类型注解，它能完成更彻底的工作。这是因为类型注解向 TypeScript 表明了你的意图，使其能够发现代码行为与意图不符之处。例如，假设你在前例中颠倒了 capital/capitol 的拼写错误会怎样？

```ts
const states = [
  { name: "Alabama", capitol: "Montgomery" },
  { name: "Alaska", capitol: "Juneau" },
  { name: "Arizona", capitol: "Phoenix" }, //
];
for (const state of states) {
  console.log(state.capital);
  // Property 'capital' does not exist on type
  // '{ name: string; capitol: string; }'.
  // Did you mean 'capitol'?
}
```

之前非常有用的错误提示现在完全弄反了！问题在于你用两种不同方式拼写了同一属性，而 TypeScript 不知道哪一种是正确的。它可以猜测，但未必总是准确。解决方案是通过显式声明 states 的类型来明确你的意图：

```ts
interface State {
  name: string;
  capital: string;
}
const states: State[] = [
  { name: "Alabama", capitol: "Montgomery" },
  { name: "Alaska", capitol: "Juneau" },
  { name: "Arizona", capitol: "Phoenix" },
  // Object literal may only specify known properties,
  // but 'capitol' does not exist in type 'State'.
  // Did you mean to write 'capital'? //
];
for (const state of states) {
  console.log(state.capital);
}
```

现在错误提示与问题相符，建议的修正也是正确的。通过阐明意图，你还帮助 TypeScript 发现了其他潜在问题。例如，如果你仅在数组中拼错一次 capitol，之前是不会报错的。但有了类型注解后，就会提示错误：

```ts
const states: State[] = [
  { name: "Alabama", capital: "Montgomery" },
  { name: "Alaska", capitol: "Juneau" },
  // \~ Did you mean to write 'capital'?
  { name: "Arizona", capital: "Phoenix" },
  // ...
];
```

随着你与类型检查器的深入配合，这种互动模式会变得愈发熟悉：你提供的信息越丰富，它发现问题的能力就越强。

用维恩图来表述，我们可以新增一个程序类别：通过类型检查的 TypeScript 程序（见图 1-2）。

![](https://cdn-mineru.openxlab.org.cn/extract/e2e3ff02-d22d-4f92-b62d-0f5b9dd49929/b7814490347291cb7e11999be164047fd93d23a22da1ffe73809d012d54d1126.jpg)图 1-2. 所有 JavaScript 程序都是 TypeScript 程序。但只有部分 JavaScript（和 TypeScript）程序能通过类型检查。

如果"TypeScript 是 JavaScript 的超集"这个说法让你觉得不妥，可能是因为你考虑的是图中第三类程序集。在实际使用 TypeScript 的日常体验中，这类程序才是最关键的。通常在使用 TypeScript 时，你会努力确保代码始终通过所有类型检查。

TypeScript 的类型系统模拟了 JavaScript 的运行时行为。如果你来自具有更严格运行时检查的语言，可能会感到意外。例如：

```ts
const x = 2 + "3"; // OK
// ^? const x: string
const y = "2" + 3; // OK
// ^? const y: string
```

尽管这些语句在其他许多语言中会引发运行时错误且存在争议，但它们都能通过 TypeScript 的类型检查。这确实准确模拟了 JavaScript 的运行时行为——两个表达式最终都会生成字符串"23"。

不过 TypeScript 在某些地方会划清界限。即使以下语句在运行时不会抛出异常，类型检查器仍会标记出问题：

```ts
const a = null + 7; // Evaluates to 7 in JS
// The value 'null' cannot be used here.
const b = [] + 12; // Evaluates to '12' in JS
// Operator '+' cannot be applied to types ...
alert("Hello", "TypeScript"); // alerts "Hello"
// Expected 0-1 arguments, but got 2
```

TypeScript 类型系统的指导原则是模拟 JavaScript 的运行时行为。但在所有这些案例中，TypeScript 认为异常用法更可能是开发者失误所致而非有意为之，因此其检查范围超越了简单的运行时行为模拟。我们在 capital/capitol 的例子中也看到了这种情况——程序并未抛出异常（输出 undefined），但类型检查器仍然标记了错误。

TypeScript 如何决定何时模拟 JavaScript 的运行时行为，何时超越这种行为？归根结底这是个品味问题。采用 TypeScript 意味着你信任其开发团队的判断力。如果你喜欢给代码添加 null 和 7 或\[\]和 12 这样的组合，或者调用函数时传递多余参数，那么 TypeScript 可能不适合你！

即便程序通过了类型检查，运行时是否仍可能抛出错误？答案是"会的"。请看这个例子：

```ts
const names = ["Alice", "Bob"];
console.log(names[2].toUpperCase());
```

运行时会抛出以下错误：

> TypeError: 无法读取未定义的属性（读取 'toUpperCase'）

TypeScript 假设数组访问会在边界范围内，但实际并未如此，结果导致了异常。

当你使用 any 类型时，未捕获的错误也经常出现，我们将在第 5 条以及第 5 章中更详细地讨论这一点。

这些异常的根本原因在于 TypeScript 对值类型的理解（其静态类型）与其在运行时的实际类型发生了偏离。能够保证其静态类型准确性的类型系统被称为健全的。TypeScript 的类型系统远非健全，也从未打算如此。第 48 条探讨了更多可能导致类型系统不健全的情况。

如果类型健全性对你很重要，你可能需要考虑其他语言，如 Reason、PureScript 或 Dart。虽然这些语言确实提供了更强的运行时安全保障，但这需要付出代价：需要更多的工作来说服它们的类型检查器你的代码是正确的，而且这些语言都不是 JavaScript 的超集，因此迁移会更加复杂。

### 要点备忘

- TypeScript 是 JavaScript 的超集：所有 JavaScript 程序在语法上都是有效的 TypeScript 程序，但并非所有 TypeScript 程序都是有效的 JavaScript 程序。
- TypeScript 添加了一个静态类型系统，用于模拟 JavaScript 的运行时行为，并试图找出会在运行时抛出异常的代码。
- 有些代码可能通过类型检查，但在运行时仍会抛出异常。
- TypeScript 禁止了一些合法但存在问题的 JavaScript 结构，例如使用错误数量的参数调用函数。
- 类型注解能向 TypeScript 表明你的意图，并帮助它区分正确和错误的代码。

## 第 2 条：了解你正在使用的 TypeScript 选项

这段代码能通过类型检查器吗？

```ts
function add(a, b) {
  return a + b;
}
add(10, null);
```

在不了解您具体使用哪些选项的情况下，这个问题无法确定答案！TypeScript 编译器拥有极其丰富的配置选项，截至本文撰写时已超过一百项。

这些选项可以通过命令行设置：

```bash
$ tsc --noImplicitAny program.ts
```

或通过配置文件 tsconfig.json 设置：

```json
{
  "compilerOptions": {
    "noImplicitAny": true
  }
}
```

我们强烈推荐使用配置文件。这能确保您的同事和相关工具都明确知晓您计划如何使用 TypeScript。您可以通过运行 tsc --init 命令来创建这个配置文件。

TypeScript 的许多配置项控制着它查找源文件的位置以及生成何种输出。但有少数几项配置直接影响语言本身的核心特性。这些高层次的设计选择是大多数编程语言不会交给用户决定的。根据配置不同，TypeScript 可能给人截然不同的语言体验。要有效使用它，你需要理解其中最重要的两项配置：noImplicitAny 和 strictNullChecks。

### noImplicitAny

noImplicitAny 控制着当 TypeScript 无法确定变量类型时的处理方式。当该选项关闭时，以下代码是合法的：

```ts
function add(a, b) {
  return a + b;
}
```

如果你在编辑器中悬停查看 add 符号，它会显示 TypeScript 对该函数类型的推断结果：

```ts
function add(a: any, b: any): any;
```

any 类型实际上会禁用涉及这些参数的代码的类型检查。any 是一个有用的工具，但应谨慎使用。关于 any 的更多内容，请参阅第 5 条和第 5 章。

这些被称为隐式 any，因为你从未写过"any"这个词，但仍然会得到危险的 any 类型。如果设置了 noImplicitAny 选项，这就会变成一个错误：

```ts
function add(a, b) {
  // Parameter 'a' implicitly has an 'any' type
  // \~ Parameter 'b' implicitly has an 'any' type
  return a + b;
}
```

这些错误可以通过显式编写类型声明来修复，可以是: any 或更具体的类型：

```ts
function add(a: number, b: number) {
  return a + b;
}
```

当 TypeScript 拥有类型信息时最为有用，因此你应该尽可能设置 noImplicitAny。一旦你习惯了所有变量都有类型，没有 noImplicitAny 的 TypeScript 感觉几乎像另一种语言。

对于新项目，你应当从一开始就启用 noImplicitAny 选项，这样就能在编写代码的同时编写类型声明。这将帮助 TypeScript 发现问题、提升代码可读性，并优化开发体验（参见第 6 条）。

仅在将 JavaScript 项目迁移至 TypeScript 时（参见第 10 章），才适合暂时关闭 noImplicitAny 选项。即便如此，这也应是临时状态，你应当尽快重新启用该选项。关闭 noImplicitAny 的 TypeScript 类型检查会变得异常宽松，第 83 条将探讨由此可能引发的隐患。

### strictNullChecks

strictNullChecks 用于控制是否允许 null 和 undefined 作为所有类型的合法值。

当 strictNullChecks 关闭时，此代码有效：

```tsX
const x: number = null; // OK, null is a valid number
```

但开启 strictNullChecks 时会触发错误：

```ts
const x: number = null; // \~ Type 'null' is not assignable to type 'number'
```

若使用 undefined 替代 null 也会出现类似错误。

如需允许 null 值，可通过明确声明意图来修复错误：

```ts
const x: number | null = null;
```

若不允许空值存在，您需要追踪其来源并添加检查或断言：

```ts
const statusEl = document.getElementById("status");
statusEl.textContent = "Ready";
// 'statusEl' is possibly 'null'.
if (statusEl) {
  statusEl.textContent = "Ready"; // OK, null as be n excluded
}

statusEl!.textContent = "Ready"; // OK, we've asserted that el is non-null
```

这种使用 if 语句的方式被称为"类型收窄"或"类型细化"，第 22 条将深入探讨此模式。最后一行的"!"被称为"非空断言"。类型断言在 TypeScript 中有其适用场景，但也可能导致运行时异常。第 9 条将详细说明何时应该或不应该使用类型断言。

strictNullChecks 对于捕获涉及 null 和 undefined 值的错误极为有用，但确实增加了语言使用的难度。如果您正在启动新项目且之前使用过 TypeScript，请设置 strictNullChecks。但若是 TypeScript 新手或正在迁移 JavaScript 代码库，可以选择暂时关闭该选项。在启用 strictNullChecks 之前，您应当先设置 noImplicitAny。

若选择在不开启严格空值检查（strictNullChecks）的情况下工作，需警惕运行时出现"undefined 不是对象"这类致命错误。每次遇到此类错误都提醒着您：应该考虑启用更严格的类型检查。随着项目规模扩大，修改此项配置的难度会递增，因此建议尽早开启该选项。大多数 TypeScript 代码都采用严格空值检查模式，这终将成为您的必然选择。

### 其他配置项

虽然还存在许多影响语言语义的配置选项（例如 noImplicitThis 和 strictFunctionTypes），但与 noImplicitAny 和 strictNullChecks 相比都属次要。若要启用全部严格检查，只需开启 strict 总开关。TypeScript 在严格模式下能捕获绝大多数错误，这理应成为您的终极目标。

使用 tsc --init 创建项目时，默认即处于严格模式。

TypeScript 还提供了一些"比严格模式更严格"的可选配置。启用这些选项能让 TypeScript 在代码错误检测方面更加激进。其中 noUncheckedIndexedAccess 选项能帮助捕获对象和数组访问相关的错误。例如下面这段代码在--strict 模式下不会报类型错误，但运行时却会抛出异常：

```ts
const tenses = ["past", "present", "future"];
tenses[3].toUpperCase();
```

当设置 noUncheckedIndexedAccess 时，这会引发错误：

```ts
const tenses = ["past", "present", "future"];
tenses[3].toUpperCase();
// Object is possibly 'undefined'.
```

不过天下没有免费的午餐。许多合法的访问操作也会被标记为可能返回 undefined：

```ts
tenses[0].toUpperCase();
// \~\~ Object is possibly 'undefined'.
```

有些 TypeScript 项目会启用这个设置，有些则不会。你至少应该知道这个选项的存在。关于这个配置的更多讨论将在第 48 条中展开。

清楚你正在使用哪些选项！如果同事分享了一个 TypeScript 示例而你无法复现他们的错误，请确保你的编译器选项与他们一致。

### 要点备忘

- TypeScript 编译器包含多个会影响语言核心特性的设置项。
- 使用 tsconfig.json 而非命令行选项来配置 TypeScript。
- 除非你正在将 JavaScript 项目迁移至 TypeScript，否则请开启 noImplicitAny 选项。
- 使用 strictNullChecks 来防止"undefined 不是对象"这类运行时错误。
- 建议启用 strict 模式以获得 TypeScript 最全面的类型检查。

## 第 3 条：理解代码生成与类型系统相互独立

从高层次来看，tsc（TypeScript 编译器）主要完成两项工作：

- 它将新一代 TypeScript/JavaScript 代码转换为能在浏览器或其他运行时环境中运行的旧版 JavaScript（即"转译"过程）。
- 它对代码进行类型错误检查。

令人惊讶的是，这两个行为彼此完全独立。换句话说，代码中的类型不会影响 TypeScript 最终输出的 JavaScript。由于实际执行的是这份 JavaScript 代码，这意味着类型不会改变程序的运行时行为。

这带来了一些令人惊讶的影响，也应当让你对 TypeScript 能做什么和不能做什么形成合理的预期。

### 无法在运行时检查 TypeScript 类型

你可能会忍不住写出这样的代码：

```ts
interface Square {
  width: number;
}
interface Rectangle extends Square {
  height: number;
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    // 'Rectangle' only refers to a type,
    // but is being used as a value here
    return shape.height * shape.width;
    // \~ Property 'height' does not exist on type 'Shape'
  } else {
    return shape.width * shape.width;
  }
}
```

instanceof 检查发生在运行时，但 Rectangle 是一个类型，因此它无法影响代码的运行时行为。TypeScript 类型是"可擦除的"：编译到 JavaScript 的过程会简单地从你的代码中移除所有接口、类型和类型注解。观察这个示例编译后的 JavaScript 代码最容易理解这一点：

```ts
function calculateArea(shape) {
  if (shape instanceof Rectangle) {
    return shape.height * shape.width;
  } else {
    return shape.width * shape.width;
  }
}
```

在 instanceof 检查之前并未提及 Rectangle，因此存在问题。2 要确定你正在处理的形状类型，需要某种方式在运行时重建其类型，即在生成的 JavaScript 中有意义的方式，而不仅仅是在原始 TypeScript 中。

有几种方法可以实现这一点。一种是检查是否存在 height 属性：

```ts
function calculateArea(shape: Shape) {
  if ("height" in shape) {
    return shape.width * shape.height;
    // ^? (parameter) shape: Rectangle
  } else {
    return shape.width * shape.width;
  }
}
```

这种方法之所以有效，是因为属性检查仅涉及运行时可用的值，但仍允许类型检查器将 shape 的类型细化为 Rectangle。

另一种方法是引入一个"标签"，以在运行时可用方式显式存储类型：

```ts
interface Square {
  kind: "square";
  width: number;
}

interface Rectangle {
  kind: "rectangle";
  height: number;
  width: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape.kind === "rectangle") {
    return shape.width * shape.height;
    // ^? (parameter) shape: Rectangle
  } else {
    return shape.width * shape.width;
    // ^? (parameter) shape: Square
  }
}
```

这里的 kind 属性充当"标签"，我们称 Shape 类型为"标签联合类型"。有时也被称为"可辨识联合类型"，此时 kind 就是"辨识属性"。这两个术语可以互换使用。由于它们能在运行时轻松恢复类型信息，标签/可辨识联合类型在 TypeScript 中无处不在。

某些结构会同时引入类型（运行时不可用）和值（运行时可用）。class 关键字就是其中之一。将 Square 和 Rectangle 定义为类是解决这个错误的另一种方式：

```ts
class Square {
  width: number;
  constructor(width: number) {
    this.width = width;
  }
}
class Rectangle extends Square {
  height: number;
  constructor(width: number, height: number) {
    super(width);
    this.height = height;
  }
}
type Shape = Square | Rectangle;
function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.height; // ^? (parameter) shape: Rectangle
  } else {
    return shape.width * shape.width; // ^? (parameter) shape: Square
  }
}
```

这种方式有效是因为 class Rectangle 同时引入了类型和值，而 interface 仅引入了类型。

在 type Shape = Square | Rectangle 中的 Rectangle 指代的是类型，而 shape instanceof Rectangle 中的 Rectangle 指代的是值（这里指构造函数）。理解这种区别很重要，但可能相当微妙。第 8 条将展示如何区分这两者。

### 存在类型错误的代码仍可产生输出

由于代码输出与类型检查相互独立，因此即使代码存在类型错误，依然可能产生输出结果！

```bash
$ cat test.ts
let x = 'hello';
x = 1234;
$ tsc test.ts
test.ts:2:1 - error TS2322: Type '1234' is not assignable to type 'string'

2 x = 1234;

$ cat test.js
var x = 'hello';
x = 1234;
```

对于习惯 C 或 Java 这类将类型检查与输出紧密绑定的开发者而言，这种现象可能相当令人惊讶。你可以将所有 TypeScript 错误类比为这些语言中的警告提示：它们很可能预示着潜在问题，值得深入排查，但不会阻断构建流程。

**编译与类型检查**

> 这很可能就是围绕 TypeScript 常出现一些不严谨说法的根源。人们经常会说他们的 TypeScript"无法编译"来表示代码存在错误。但从技术上讲这种说法并不准确！只有代码生成阶段才属于"编译"。只要你的 TypeScript 是有效的 JavaScript（甚至经常在无效时也是如此），TypeScript 编译器仍会生成输出。虽然可能显得迂腐，但更准确的说法应该是你的代码存在错误，或者说它"未能通过类型检查"。

在实际开发中，存在错误时仍生成代码的功能非常有用。如果你正在构建 Web 应用程序，可能知道其中某个特定部分存在问题。但由于 TypeScript 在存在错误时仍会生成代码，你可以在修复问题前先测试应用程序的其他部分。

提交代码时应当以零错误为目标，以免陷入需要区分预期错误与非预期错误的困境。如果想在出现错误时禁用输出，可以在 tsconfig.json 中使用 noEmitOnError 选项，或在构建工具中使用等效配置。

### 类型操作不会影响运行时值

假设你有一个可能是字符串或数字的值，你想将其标准化为始终是数字。以下是一个类型检查器会接受但实际错误的尝试：

```ts
function asNumber(val: number | string): number {
  return val as number;
}
```

查看生成的 JavaScript 代码就能明白这个函数的真实作用：

```ts
function asNumber(val) {
  return val;
}
```

这里根本没有进行任何类型转换。\`as number\`只是一个类型操作，因此它不会影响代码的运行时行为。要实现值的标准化，你需要检查其运行时类型并使用 JavaScript 结构进行转换：

```ts
function asNumber(val: number | string): number {
  return Number(val);
}
```

"as number"是一种类型断言（type assertion），有时被不准确地称为"类型转换"。关于何时适合使用类型断言，详见第 9 条。

### 运行时类型可能与声明类型不一致

这个函数是否有可能执行到最后的 console.log？

```ts
function setLightSwitch(value: boolean) {
  switch (value) {
    case true:
      turnLightOn();
      break;
    case false:
      turnLightOff();
      break;
    default:
      console.log(`I'm afraid I can't do that.`);
  }
}
```

TypeScript 通常会标记无效代码，但即使开启严格模式，这里也不会报错。如何才能触发这个分支？

关键在于记住 boolean 只是声明类型。由于它是 TypeScript 类型，运行时就会消失。在 JavaScript 代码中，用户可能会无意间用"ON"这样的值调用 setLightSwitch 函数。

在纯 TypeScript 中也有方法触发这段代码路径。也许函数被调用时传入的值来自网络请求：

```ts
interface LightApiResponse {
  lightSwitchValue: boolean;
}

async function setLight() {
  const response = await fetch("/light");
  const result: LightApiResponse = await response.json();
  setLightSwitch(result.lightSwitchValue);
}
```

你已声明/light 请求的返回类型是 LightApiResponse，但没有任何机制强制保证这一点。如果你误解了 API 而 lightSwitchValue 实际是字符串类型，那么在运行时就会将字符串传递给 setLightSwitch。又或者 API 在你部署后发生了变更。

当运行时类型与声明类型不匹配时，TypeScript 会变得相当令人困惑，你应该尽可能避免这些所谓的"不健全"类型。但要注意，值的运行时类型确实有可能与你声明的类型不同。关于类型健全性的更多讨论，请参阅第 48 条。

### 无法基于 TypeScript 类型实现函数重载

像 C++这样的语言允许你定义多个版本的函数，这些函数仅在参数类型上有所不同。这被称为"函数重载"。由于代码的运行时行为与其 TypeScript 类型无关，因此在 TypeScript 中无法实现这种结构：

```ts
function add(a: number, b: number) {
  return a + b;
} // \~\~ Duplicate function implementation
function add(a: string, b: string) {
  return a + b;
} // \~ Duplicate function implementation
```

TypeScript 确实提供了函数重载的功能，但它完全在类型层面运作。你可以为一个函数提供多个类型签名，但只能有一个实现：

```ts
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: any, b: any) {
  return a + b;
}
const three = add(1, 2);
// ^? const three: number
const twelve = add("1", "2");
// ^? const twelve: string
```

add 函数的前两个签名仅提供类型信息。当 TypeScript 生成 JavaScript 输出时，它们会被移除，只保留实现部分。实现中的 any 参数并不理想。我们将在第 52 条中探讨如何处理这些问题，该条目还涵盖了使用 TypeScript 函数重载时需要注意的一些微妙之处。

### TypeScript 类型对运行时性能没有影响

由于类型和类型操作在生成 JavaScript 时会被擦除，它们不会对运行时性能产生任何影响。TypeScript 的静态类型真正实现了零成本。下次如果有人以运行时开销为由拒绝使用 TypeScript，你就知道他们根本没有认真验证过这个说法！

但需要注意两点：

- 虽然不存在运行时开销，但 TypeScript 编译器会引入构建时开销。TypeScript 团队非常重视编译器性能，编译过程通常非常迅速，特别是增量构建时。如果构建开销过大，你的构建工具可能提供"仅转译"选项来跳过类型检查。关于编译器性能的更多讨论，我们将在第 78 条详细展开。
- TypeScript 为支持旧版运行时环境所生成的代码，相比原生实现可能会带来性能开销。例如，若您使用生成器函数并以 ES5 为目标环境（该标准早于生成器功能），tsc 编译器将生成辅助代码来实现功能。相比原生生成器实现，这会产生一定性能损耗。这种情况适用于所有 JavaScript"转译器"，而不仅限于 TypeScript。无论如何，这与代码生成目标和语言级别相关，但仍与类型系统无关。

### 要点备忘

- 代码生成与类型系统相互独立。这意味着 TypeScript 类型不会影响代码的运行时行为。
- 存在类型错误的程序仍可能生成可执行代码（即"编译通过"）。
- TypeScript 的类型在运行时不可用。要在运行时查询类型，需要通过某种方式重构它。标记联合和属性检查是常见的实现方式。
- 某些结构（例如类）会同时引入一个 TypeScript 类型和一个在运行时可用的值。
- 由于类型会在编译阶段被擦除，TypeScript 类型不会影响代码的运行时性能。

## 第 4 条：熟悉结构类型系统

JavaScript 推崇"鸭子类型"：只要传递给函数的对象具备所需的全部属性，它就不会在意这个对象是如何创建的，而是直接使用它。（这一术语源自谚语"如果它走起路来像鸭子，叫起来也像鸭子，那么它很可能就是鸭子"）

TypeScript 通过所谓的"结构类型系统"来模拟这种行为。这有时会导致出人意料的结果，因为类型检查器对类型的理解可能比你预期的更为宽泛。深入理解结构类型系统将帮助你正确解读报错与非报错情况，从而编写出更健壮的代码。

假设你正在开发一个物理库，其中包含二维向量类型：

```ts
interface Vector2D {
  x: number;
  y: number;
}
```

你编写了一个计算向量长度的函数：

```ts
function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x ** 2 + v.y ** 2);
}
```

现在引入命名向量的概念：

```ts
interface NamedVector {
  name: string;
  x: number;
  y: number;
}
```

calculateLength 函数能处理 NamedVector 类型，因为它们都具有数值类型的 x 和 y 属性。TypeScript 足够智能，可以推断出这一点：

```ts
const v: NamedVector = { x: 3, y: 4, name: "Pythagoras" };
calculateLength(v); // OK, result is 5
```

有趣的是，你从未声明过 Vector2D 和 NamedVector 之间的关系。也无需为 NamedVector 重写 calculateLength 的实现。TypeScript 的类型系统模拟了 JavaScript 的运行时行为（条款 1）。它允许 calculateLength 接收 NamedVector 参数，正是因为其结构与 Vector2D 兼容。这就是"结构类型"术语的由来。

但这同样可能引发问题。假设现在要添加三维向量类型：

```ts
interface Vector3D {
  x: number;
  y: number;
  z: number;
}
```

编写一个函数对向量进行归一化处理（使其长度为 1）：

```ts
function normalize(v: Vector3D) {
  const length = calculateLength(v);
  return { x: v.x / length, y: v.y / length, z: v.z / length };
}
```

如果调用这个函数，很可能会得到一个长度大于 1 的向量：

> normalize({x: 3, y: 4, z: 5}) { x: 0.6, y: 0.8, z: 1 }

这个向量的长度约为 1.4 而非 1。那么问题出在哪里？为什么 TypeScript 没有捕获这个错误？

这个 bug 在于 calculateLength 函数操作的是二维向量，而 normalize 函数操作的是三维向量。因此在归一化过程中 z 分量被忽略了。

更令人惊讶的是类型检查器竟然没有捕捉到这个问题。为什么 calculateLength 明明声明只接收二维向量，却允许传入三维向量调用？

之前对命名向量行之有效的特性在这里反而造成了问题。使用{x, y, z}对象调用 calculateLength 不会报错，因此类型检查器也不会提出异议，最终导致了 bug 的产生。

（若希望这种情况报错，你有几种选择。第 63 条介绍了一种专门禁止 z 属性的技巧，第 64 条则展示了如何使用"品牌"模式来完全避免这类结构类型问题。）

编写函数时，很容易想象它们会被调用时传入的参数仅包含你声明的属性。这种类型被称为"封闭"、"密封"或"精确"类型，但 TypeScript 的类型系统无法表达这种概念。无论你是否喜欢，你的类型都是"开放"的。

这有时会导致意外情况：

```ts
function calculateLengthL1(v: Vector3D) {
  let length = 0;
  for (const axis of Object.keys(v)) {
    const coord = v[axis];
    // Element implicitly has an 'any' type because
    // 'string' can't be used to index type 'Vector3D'
    length += Math.abs(coord);
  }
  return length;
}
```

为什么这会报错？既然 axis 是 v 的键之一，而 v 是 Vector3D 类型，那么 axis 应该是"x"、"y"或"z"之一。根据 Vector3D 的声明，这些属性都是数字类型，那么 coord 的类型不应该是 number 吗？

这个错误是误报吗？不！TypeScript 的报错是正确的。前一段的逻辑假设 Vector3D 是密封的且没有其他属性。但它可能有：

```ts
const vec3D = { x: 3, y: 4, z: 1, address: "123 Broadway" };
calculateLengthL1(vec3D); // OK, returns NaN
```

由于变量 v 可能具有任意属性，因此 axis 的类型被定义为字符串。TypeScript 没有理由认为 v\[axis\]一定是数字类型，正如刚才所见，它完全可能不是（此处的 vec3D 变量绕过了多余属性检查，这将在条款 11 中详细讨论）。

遍历对象时正确标注类型可能颇具挑战性。我们将在条款 60 重新探讨这个话题，不过就本例而言，采用非循环的实现方式更为妥当：

```ts
function calculateLengthL1(v: Vector3D) {
  return Math.abs(v.x) + Math.abs(v.y) + Math.abs(v.z);
}
```

结构类型系统在类比较时同样可能带来意外情况——类的可赋值性是通过结构比较来判断的：

```ts
class SmallNumContainer {
  num: number;
  constructor(num: number) {
    if (num < 0 || num >= 10) {
      throw new Error(`You gave me ${num} but I want something 0-9.`);
    }
    this.num = num;
  }
}

const a = new SmallNumContainer(5);
const b: SmallNumContainer = { num: 2024 }; // OK!
```

为什么 b 能被赋值给 SmallNumContainer 类型？因为它具有一个数值类型的 num 属性，结构完全匹配。但如果你编写的函数依赖于 SmallNumContainer 中的验证逻辑，这种特性可能会导致问题。

构造函数已经运行。对于具有更多属性和方法的类来说，这种情况偶然发生的可能性较低，但这与 C++或 Java 等语言有很大不同——在这些语言中，声明 SmallNumContainer 类型的参数能确保它要么是 SmallNumContainer 要么是其子类，因此构造函数中的验证逻辑必然已执行。

结构类型在编写测试时非常有用。假设你有一个对数据库执行查询并处理结果的函数：

```ts
interface Author {
  first: string;
  last: string;
}
function getAuthors(database: PostgresDB): Author[] {
  const authorRows = database.runQuery(`SELECT first, last FROM authors`);
  return authorRows.map((row) => ({ first: row[0], last: row[1] }));
}
```

为了测试这个函数，你可以创建一个模拟的 PostgresDB。但更简单的方法是使用结构类型并定义一个更窄的接口：

```ts
interface DB {
  runQuery: (sql: string) => any[];
}
function getAuthors(database: DB): Author[] {
  const authorRows = database.runQuery(`SELECT first, last FROM authors`);
  return authorRows.map((row) => ({ first: row[0], last: row[1] }));
}
```

在生产环境中，你仍然可以向 getAuthors 传递真实的 PostgresDB，因为它具有 runQuery 方法。由于结构类型的特性，PostgresDB 无需声明它实现了 DB 接口。TypeScript 会自动识别出它满足该接口。

在编写测试时，你可以传入一个更简单的对象：

```ts
test("getAuthors", () => {
  const authors = getAuthors({
    runQuery(sql: string) {
      return [
        ["Toni", "Morrison"],
        ["Maya", "Angelou"],
      ];
    },
  });

  expect(authors).toEqual([
    { first: "Toni", last: "Morrison" },
    { first: "Maya", last: "Angelou" },
  ]);
});
```

TypeScript 会验证我们的测试数据库是否符合接口规范。而你的测试代码无需了解生产数据库的任何细节：完全不需要模拟库！通过引入抽象层（DB 接口），我们将业务逻辑（及测试）与具体实现（PostgresDB）的细节解耦。

结构类型化的另一个优势是能彻底切断库之间的依赖关系。更多相关内容参见第 70 条。

### 要点备忘

- 理解 JavaScript 采用鸭子类型，而 TypeScript 通过结构类型系统来模拟这一点：可赋值给接口的值可能包含类型声明中未明确列出的额外属性。类型并非"密封"的。
- 注意类同样遵循结构类型规则。你获得的实例可能并非预期的类！
- 利用结构类型系统来简化单元测试。

## 第 5 条：限制 any 类型的使用

TypeScript 的类型系统是渐进式且可选的：渐进式体现在你可以逐步为代码添加类型（通过 noImplicitAny），而可选性则意味着你可以随时禁用类型检查器。这些特性的核心在于 any 类型：

```ts
let ageInYears: number;
ageInYears = "12";
// Type 'string' is not assignable to type 'number'.
ageInYears = "12" as any; // OK
```

类型检查器在此处的报错是正确的，但你可以通过类型断言 as any 来消除报错。刚开始使用 TypeScript 时，当遇到不理解错误、认为类型检查器有误或只是不想花时间编写类型声明时，很容易忍不住使用 any 类型和类型断言（as any）。

某些情况下这种做法或许可行，但要注意使用 any 会丧失 TypeScript 的诸多优势。至少在使用前，你应当了解其潜在风险。

### any 类型会彻底丧失类型安全性

在前面的例子中，类型声明指出 ageInYears 是一个数字。但 any 类型允许你为其分配字符串。类型检查器会认为它是一个数字（毕竟你是这么声明的），而这种混乱不会被发现：

ageInYears += 1; // 通过；运行时 ageInYears 现在变成了"121"

### any 类型让你可以破坏契约

当你编写函数时，就是在指定一个契约：如果调用者给你某种类型的输入，你将产生某种类型的输出。但使用 any 类型时，你可以破坏这些契约：

```ts
function calculateAge(birthDate: Date): number {
  // ...
}

let birthDate: any = "1990-01-19";
calculateAge(birthDate); // OK
```

出生日期参数应为 Date 类型，而非字符串。any 类型让你违背了 calculateAge 的契约。这在 JavaScript 中尤为棘手，因为该语言经常隐式执行

类型转换。字符串有时能在需要数字的场合通过，却会在其他情况下引发错误。

### any 类型不享受语言服务支持

当变量具有非 any 类型时，TypeScript 语言服务才能提供智能自动补全和上下文文档（如图 1-3 所示）。

let person = { first: 'George'，last: 'Washington' }; person:

![](https://cdn-mineru.openxlab.org.cn/extract/e2e3ff02-d22d-4f92-b62d-0f5b9dd49929/40438adcaabbd01c020863341643bdc9daa084b2da4b04ce60005335ece1caad.jpg)图 1-3. TypeScript 语言服务能为带有类型的符号提供上下文自动补全功能。图 1-4. 对于 any 类型的符号属性则不会显示自动补全。

但对于 any 类型的符号，你就只能靠自己了（图 1-4）。

```ts
let person: any = { first: 'George'，last: 'Washington' };
person.
```

重命名是另一项类似功能。假设你有一个 Person 类型和一些用于格式化人名的函数：

```ts
interface Person {
  first: string;
  last: string;
}
const formatName = (p: Person) => `${p.first} \{p.last}`;
const formatNameAny = (p: any) => `${p.first} ${p.last}`;
```

那么你可以在编辑器中先选中，选择“重命名符号”，并将其改为 firstName（见图 1-5 和图 1-6）。

![](https://cdn-mineru.openxlab.org.cn/extract/e2e3ff02-d22d-4f92-b62d-0f5b9dd49929/19fb04364d2a48afd0ef9f22c7e8bf6f7042005eee6fc0b9dee440aed8f78220.jpg)图 1-5. 在 VS Code 中重命名符号。

![](https://cdn-mineru.openxlab.org.cn/extract/e2e3ff02-d22d-4f92-b62d-0f5b9dd49929/595178954ed33394ae21b086cd6f1b754b47af5e5398e4ca856bf2a03ad810f9.jpg)图 1-6. 选择新名称。

这改变了 formatName 函数，但未改变 any 版本：

```ts
interface Person {
  firstName: string;
  last: string;
}
const formatName = (p: Person) => `${p.firstName} ${p.last}`;
const formatNameAny = (p: any) => `${p.first} ${p.last}`;
```

TypeScript 的宣传语之一是"可扩展的 JavaScript"。其中"可扩展"的关键在于语言服务功能，这是 TypeScript 体验的核心组成部分（参见第 6 条）。失去这些功能将导致生产力下降，不仅影响你个人，也会影响所有与你代码协作的开发者。

### 任意类型会在重构代码时掩盖错误

假设你正在构建一个允许用户选择某种项目的网页应用。某个组件可能包含 onSelectItem 回调函数。为项目编写类型声明看似繁琐，于是你直接用 any 类型作为占位符：

```ts
interface ComponentProps {
  onSelectItem: (item: any) => void;
}
```

以下是管理该组件的代码：

```ts
function renderSelector(props: ComponentProps) {
  /* */
}

let selectedId: number = 0;
function handleSelectItem(item: any) {
  selectedId = item.id;
}
renderSelector({ onSelectItem: handleSelectItem });
```

后来你重构了选择器，使得将整个项目对象传递给 onSelectItem 变得困难。但这没什么大不了的，因为你只需要 ID。你在 ComponentProps 中修改了函数签名：

```ts
interface ComponentProps {
  onSelectItem: (id: number) => void;
}
```

你更新了组件后，所有代码都通过了类型检查。胜利！

...真的如此吗？handleSelectItem 接受 any 类型的参数，所以它既能处理项目对象也能处理 ID。尽管通过了类型检查，它仍会产生运行时异常。如果你使用了更具体的类型，这个问题本应被类型检查器捕获。

### any 类型会掩盖你的类型设计

对于复杂对象（如应用程序状态）的类型定义可能会变得相当冗长。与其为应用程序状态中的数十个属性逐一编写类型，您可能会忍不住直接使用 any 类型草草了事。

这种做法会带来本条列出的所有问题。但更严重的是，它会掩盖状态的设计意图。正如第 4 章所述，良好的类型设计对于编写清晰、正确且易于理解的代码至关重要。使用 any 类型会使您的类型设计变得隐晦不明，导致难以判断设计是否合理，甚至完全无法了解设计内容。如果请同事审查代码变更，他们将不得不自行推断您是否以及如何修改了应用程序状态。更好的做法是明确写出类型定义，让所有参与者都能清晰理解。

### any 类型会破坏对类型系统的信任

每次当你犯错而类型检查器捕获到它时，你对类型系统的信心就会增强。但当你在运行时看到 TypeScript 未能捕获的类型错误时，这种信心就会受到打击。如果你在大型团队中引入 TypeScript，这可能会让同事质疑 TypeScript 是否值得投入。any 类型往往是这些未捕获错误的根源。

TypeScript 旨在让你的工作更轻松，但充斥着 any 类型的 TypeScript 可能比无类型的 JavaScript 更难处理，因为你既要修复类型错误，又要在脑海中追踪实际类型。当你的类型与现实匹配时，就能从记忆类型信息的负担中解脱出来——TypeScript 会替你记住这些。

在必须使用 any 的情况下，存在优劣之分的使用方式。关于如何限制 any 负面影响的更多内容，请参阅第 5 章。

### 要点备忘

- TypeScript 的 any 类型允许你禁用对符号的大多数类型检查形式。
- any 类型会破坏类型安全性，让你违反契约，损害开发体验，使重构容易出错，掩盖你的类型设计，并削弱对类型系统的信心。
- 尽量避免使用 any 类型！
