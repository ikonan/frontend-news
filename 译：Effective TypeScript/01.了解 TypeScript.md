# 第 1 章：了解 TypeScript

在我们深入细节之前，本章将帮助你了解 TypeScript 的全貌。它是什么，你应该如何看待它？它与 JavaScript 有什么关系？它的类型是否可为空？什么是 `any` 类型？还有鸭子类型又是怎么回事？

TypeScript 是一种特殊的语言，它既不像 Python 和 Ruby 那样在解释器中运行，也不像 Java 和 C 那样编译成低级语言。相反，它编译成另一种高级语言——JavaScript。运行的是编译后的 JavaScript，而不是你的 TypeScript 代码。因此，理解 TypeScript 与 JavaScript 的关系至关重要，这将有助于你成为一名更高效的 TypeScript 开发者。

TypeScript 的类型系统也有一些不同寻常的方面，你应该有所了解。后续章节将更详细地介绍类型系统，但本章将介绍几个最重要的要点。

即使你已经编写过大量的 TypeScript 代码，也应该阅读本章。它将帮助你建立关于 TypeScript 是什么以及其类型系统如何工作的正确心智模型，还可能消除一些你自己都没意识到的误解。

## 条目 1：理解 TypeScript 与 JavaScript 的关系

由于它们联系如此紧密，深刻理解它们之间的关系是熟练使用 TypeScript 的基础。

如果 B 中的所有内容也都在 A 中，那么 A 就是 B 的“超集”。从语法层面上讲，TypeScript 是 JavaScript 的超集：只要你的 JavaScript 程序没有任何语法错误，那么它也是一个 TypeScript 程序。很有可能 TypeScript 的类型检查器会标记出你代码中的一些问题，但这是一个独立的问题。TypeScript 仍然会解析你的代码并生成 JavaScript。（这是两者关系的另一个关键部分。我们将在条目 3 中进一步探讨。）

TypeScript 文件使用 `.ts` 扩展名，而不是 JavaScript 文件的 `.js` 扩展名。这并不意味着 TypeScript 是一种完全不同的语言！由于 TypeScript 是 JavaScript 的超集，你 `.js` 文件中的代码已经是 TypeScript 代码了。将 `main.js` 重命名为 `main.ts` 并不会改变这一点。

如果你要将现有的 JavaScript 代码库迁移到 TypeScript，这将非常有帮助。这意味着你无需用其他语言重写代码就可以开始使用 TypeScript 并获得它提供的好处。如果你选择用 Java 这样的语言重写 JavaScript，情况就不是这样了。这种渐进式的迁移路径是 TypeScript 最好的特性之一。我们将在第 10 章中对这个主题进行更多讨论。

所有的 JavaScript 程序都是 TypeScript 程序，但反之则不然：存在一些不是 JavaScript 程序的 TypeScript 程序。这是因为 TypeScript 增加了用于指定类型的额外语法。（它还增加了一些其他的语法，主要是出于历史原因。请参阅条目 72。）

例如，这是一个有效的 TypeScript 程序：

```js
function greet(who: string) {
  console.log("Hello", who);
}
```

但是，当你通过像 Node 这样期望接收 JavaScript 代码的程序来运行这段代码时，你会收到一个错误：

```ts
function greet(who: string) {
//                    ^
// SyntaxError: Unexpected token :
```

`: string` 是 TypeScript 特有的类型注解。一旦你使用了它，就超出了纯 JavaScript 的范畴（请参见图 1 - 1）。

[![19b9e4ca80e945d0a3489691fea5c8f2-pdf-26-2400-jpg-tplv-a9rns2rl98-resize-crop-254-584-1600-1474-1346.jpg](https://i.postimg.cc/jdRDvmb1/19b9e4ca80e945d0a3489691fea5c8f2-pdf-26-2400-jpg-tplv-a9rns2rl98-resize-crop-254-584-1600-1474-1346.jpg)](https://postimg.cc/23XjSH3d)

图 1 - 1. 所有的 JavaScript 代码都是 TypeScript 代码，但并非所有的 TypeScript 代码都是 JavaScript 代码。

这并不是说 TypeScript 对纯 JavaScript 程序没有价值。它是有价值的！例如，这个 JavaScript 程序：

```js
let city = "new york city";
console.log(city.toUppercase());
```

当你运行它时会抛出一个错误：

> TypeError: city.toUppercase 不是一个函数

此程序中没有类型注解，但 TypeScript 的类型检查器仍然能够发现问题：

````ts
let city = "new york city";
console.log(city.toUppercase());
// ```Property 'toUppercase' does not exist on type
// 'string'. Did you mean 'toUpperCase'?
````

你不必告诉 TypeScript `city` 的类型是字符串：它会从初始值推断出类型。类型推断是 TypeScript 的关键部分，第三章将探讨如何很好地使用它。

TypeScript 类型系统的目标之一是在无需运行代码的情况下检测出在运行时会抛出异常的代码。当你听到 TypeScript 被描述为“静态”类型系统时，指的就是这种能力。类型检查器并不总能发现会抛出异常的代码，但它会尽力而为。

即使你的代码不会抛出异常，它也可能无法按你的预期运行。TypeScript 也会尝试捕获其中一些问题。例如，下面这个 JavaScript 程序：

```js
const states = [
  { name: "Alabama", capital: "Montgomery" },
  { name: "Alaska", capital: "Juneau" },
  { name: "Arizona", capital: "Phoenix" },
  // ...
];
for (const state of states) {
  console.log(state.capitol);
}
```

将输出：

> undefined
> undefined
> undefined

哎呀！哪里出问题了呢？这个程序是有效的 JavaScript 代码（因此也是 TypeScript 代码）。它运行时没有抛出任何错误。但显然它并没有按你的预期执行。即使不添加类型注解，TypeScript 的类型检查器也能发现错误并给出有用的建议：

````ts
for (const state of states) {
  console.log(state.capitol);
  // ```Property 'capitol' does not exist on type
  // '{ name: string; capital: string; }'.
  // Did you mean 'capital'?
}
````

实际上，我们指的是拼写为 “a” 的 “capital”。州和国家有首府（capital，含 “a”）城市，而立法机构则在议会大厦（capitol，含 “o”）开会。

虽然即使你不提供类型注解，TypeScript 也能捕获错误，但如果你提供了，它就能更全面地完成这项工作。这是因为类型注解能告诉 TypeScript 你的意图，从而让它发现代码行为与你意图不符的地方。例如，如果你在前一个例子中把 “capital” 和 “capitol” 的拼写错误弄反了会怎样呢？

```ts
const states = [
  { name: "Alabama", capitol: "Montgomery" },
  { name: "Alaska", capitol: "Juneau" },
  { name: "Arizona", capitol: "Phoenix" },
  // ...
];
for (const state of states) {
  console.log(state.capital);
  // ~~~~~~~ 属性 'capital' 不存在于类型
  // '{ name: string; capitol: string; }' 中。
  // 你是不是想写 'capitol'？
}
```

之前非常有用的错误提示现在却完全错了！问题在于你用两种不同的方式拼写了同一个属性，而 TypeScript 不知道哪个是正确的。它可以进行猜测，但并不总是准确的。解决办法是通过显式声明 `states` 的类型来明确你的意图：

```ts
interface State {
  name: string;
  capital: string;
}
const states: State[] = [
  { name: "Alabama", capitol: "Montgomery" },
  //                 ~~~~~~~

  { name: "Alaska", capitol: "Juneau" },
  //                ~~~~~~~

  { name: "Arizona", capitol: "Phoenix" },
  //                 ~~~~~~~ 对象字面量只能指定已知属性，
  //                但 'capitol' 并不存在于类型 'State' 中。
  //                你是不是想写 'capital'？
  // ...
];
for (const state of states) {
  console.log(state.capital);
}
```

现在，错误信息与问题相匹配，并且建议的修复方法也是正确的。通过明确表达你的意图，你还帮助 TypeScript 发现了其他潜在的问题。例如，如果你只在数组中误拼了一次 “capitol”，之前是不会报错的。但有了类型注解之后，就会报错了：

```ts
const states: State[] = [
  { name: "Alabama", capital: "Montgomery" },
  { name: "Alaska", capitol: "Juneau" },
  //               ~~~~~~~Did you mean to write 'capital'?
  { name: "Arizona", capital: "Phoenix" },
  // ...
];
```

当你使用类型检查器时，这将成为一种熟悉的模式：你提供给它的信息越多，它就能发现越多的问题。
从维恩图的角度来看，我们可以添加一组新的程序：通过类型检查器的 TypeScript 程序（见图 1 - 2）。

[![19b9e4ca80e945d0a3489691fea5c8f2-pdf-30-2400-jpg-tplv-a9rns2rl98-resize-crop-254-208-1598-802-1344-5.jpg](https://i.postimg.cc/Kv16Xvx3/19b9e4ca80e945d0a3489691fea5c8f2-pdf-30-2400-jpg-tplv-a9rns2rl98-resize-crop-254-208-1598-802-1344-5.jpg)](https://postimg.cc/w7dfLzt9)

图 1 - 2. 所有的 JavaScript 程序都是 TypeScript 程序。但只有部分 JavaScript（和 TypeScript）程序能通过类型检查器。

如果 “TypeScript 是 JavaScript 的超集” 这一说法让你觉得不对劲，可能是因为你在考虑图中的第三组程序。实际上，这组程序与日常使用 TypeScript 的体验最为相关。通常，当你使用 TypeScript 时，你会努力让代码通过所有的类型检查。

TypeScript 的类型系统模拟了 JavaScript 的运行时行为。如果你之前使用的是具有更严格运行时检查的语言，这可能会让你感到有些意外。例如：

```ts
const x = 2 + "3";
// OK
// ^? const x: string
const y = "2" + 3;
// OK
// ^? const y: string
```

尽管这些语句存在疑问，并且在许多其他语言中会产生运行时错误，但它们都能通过 TypeScript 的类型检查器。不过，这确实准确地模拟了 JavaScript 的运行时行为，在 JavaScript 中，这两个表达式的结果都是字符串 "23"。

不过，TypeScript 也有其界限。即使这些语句在运行时不会抛出异常，类型检查器也会标记出其中的问题：

```ts
const a = null + 7;
// Evaluates to 7 in JS
// ~~~~ The value 'null' cannot be used here.
const b = [] + 12;
// Evaluates to '12' in JS
// ~~~~~~~ Operator '+' cannot be applied to types ...
alert("Hello", "TypeScript");
// alerts "Hello"
// ~~~~~~~~~~~~ Expected 0-1 arguments, but got 2
```

TypeScript 类型系统的指导原则是它应该模拟 JavaScript 的运行时行为。但在所有这些情况下，TypeScript 认为这种奇怪的用法更可能是错误导致的，而不是开发者的意图，因此它不仅仅是模拟运行时行为。我们在 “capital/capitol” 的例子中看到了另一个这样的例子，在那个例子中，程序没有抛出错误（它打印出了 undefined），但类型检查器仍然标记了一个错误。

TypeScript 如何决定何时模拟 JavaScript 的运行时行为，何时超越它呢？最终这是一个个人偏好的问题。采用 TypeScript 意味着你信任开发它的团队的判断。如果你喜欢将 null 和 7 相加，或者将 [] 和 12 相加，又或者使用多余的参数调用函数，那么 TypeScript 可能不适合你！

如果你的程序通过了类型检查，它在运行时仍然可能抛出错误吗？答案是 “可能”。这里有一个例子：

```ts
const names = ["Alice", "Bob"];
console.log(names[2].toUpperCase());
```

当你运行这段代码时，会抛出以下错误：

> 类型错误：无法读取未定义属性（读取 'toUpperCase'）

TypeScript 假定数组访问在合法范围内，但实际并非如此。结果就抛出了异常。

当你使用 `any` 类型时，未捕获的错误也经常出现，我们将在第 5 条目中讨论这个问题，并在第 5 章中详细探讨。

这些异常的根本原因是 TypeScript 对值的类型理解（即静态类型）与其在运行时的实际类型不一致。一个能够保证其静态类型准确性的类型系统被称为健全的类型系统。TypeScript 的类型系统远非健全，而且它从一开始就没打算做到这一点。第 48 条目将探讨更多可能导致类型系统不健全的情况。

如果类型系统的健全性对你很重要，你可以考虑其他语言，如 Reason、PureScript 或 Dart。虽然这些语言能为运行时安全性提供更多保证，但这是有代价的：要让它们的类型检查器相信你的代码是正确的，需要付出更多努力，而且这些语言都不是 JavaScript 的超集，因此迁移过程会更加复杂。

**需要记住的要点**

- TypeScript 是 JavaScript 的超集：所有的 JavaScript 程序在语法上都是有效的 TypeScript 程序，但并非所有的 TypeScript 程序都是有效的 JavaScript 程序。
- TypeScript 增加了一个静态类型系统，该系统模拟 JavaScript 的运行时行为，并试图找出在运行时会抛出异常的代码。
- 代码有可能通过类型检查器，但在运行时仍然会抛出异常。
- TypeScript 禁止一些合法但存在疑问的 JavaScript 结构，例如使用错误数量的参数调用函数。
- 类型注解可以告诉 TypeScript 你的意图，并帮助它区分正确和错误的代码。

## 条目 2：了解你正在使用的 TypeScript 选项
