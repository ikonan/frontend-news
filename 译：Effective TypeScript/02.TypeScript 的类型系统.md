# 第 2 章 TypeScript 的类型系统

TypeScript 可以生成 JavaScript（第 3 条），但类型系统才是重点。这也是你使用这种语言的原因！

本章将带你了解 TypeScript 类型系统的方方面面：如何思考它、如何使用它、你需要做出的选择以及你应该避免的功能。TypeScript 的类型系统出人意料地强大，能够表达一些你可能不认为类型系统能够表达的东西。本章中的条目将为你提供坚实的基础，以便你在编写 TypeScript 代码和阅读本书其余部分时有所依循。

## 第 6 项：利用编辑器查询和探索类型系统

当你安装 TypeScript 时，会得到两个可执行文件：

tsc，TypeScript 编译器 tsserver，独立的 TypeScript 服务器

你更可能直接运行 TypeScript 编译器，但服务器同样非常重要，因为它提供了语言服务。这些服务包括自动补全、检查、导航和重构。你通常通过编辑器使用这些服务。如果你的编辑器没有配置提供这些服务，那你可就错过了！自动补全这类服务是让 TypeScript 使用起来如此愉快的原因之一。但除此之外，编辑器还是你构建和测试类型系统知识的最佳场所。这将帮助你培养对 TypeScript 能够推断类型的理解，这对于编写紧凑且符合规范的代码至关重要（参见第 18 项）。

编辑器之间会有所不同，但通常你可以将鼠标悬停在符号上以查看 TypeScript 认为它的类型是什么（如图 2-1 所示）。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/d5c381bde5759fa1d4ddc797d997bbc40f0ce7cd0b2e9b7ddf09df82d3188516.jpg)
图 2-1. 编辑器（VS Code）显示 numsymbol 的推断类型为 number。

你并没有在这里写 number，但 TypeScript 能根据值 10 推断出来。

你也可以检查函数，如图 2-2 所示。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/66c73529df2f36f6370dc4f98a75e81d61dfdbdcd91a710aca873d5c53dacdb5.jpg)
图 2-2. 使用编辑器显示函数推断出的返回类型

值得注意的是返回类型的推断值为 number。如果这不符合你的预期，你应该添加类型声明并找出差异（参见第 9 条）。

在任何给定点查看 TypeScript 认为变量类型的值对于理解类型扩展（参见第 20 条）和类型收缩（参见第 22 条）至关重要。在条件语句的分支中观察变量类型的改变，是增强对类型系统信心的极好方法（参见图 2-3）。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/639d4076727892a9fbacc182b198cac1d8e42eb36fd92a818be3ad6fb9c9d17a.jpg)
图 2-3. 在分支外，message 的类型为 string | null；在分支内，类型为 string。

你可以检查大型对象中的个别属性，以查看 TypeScript 对它们的推断（参见图 2-4）。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/e5d4bc60d6a70aca1d214bb755a657ddcbf3a104d1cc00e9780b450fefff9679.jpg)
图 2-4. 检查 TypeScript 对象中类型推断的情况。

如果你希望 x 是一个元组类型 (\[number, number\])，则需要添加类型注解。

要在一系列操作中间查看推断的泛型类型，请检查方法名（如图 2-5 所示）。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/908cacaa06fb510195af75459b784e1854a1022e289ba5863295bc653ced242b.jpg)
图 2-5. 在方法调用链中揭示推断出的泛型类型

Array 表明 TypeScript 理解 split 生成了一个字符串数组。虽然在这种情况下几乎没有歧义，但这种信息在编写和调试长方法调用链时会变得非常重要。TypeScript 还为 slice 方法带来了有用的文档。第 68 条将解释这是如何工作的。

在编辑器中查看类型错误也是一种学习类型系统细微之处的好方法。例如，这个函数尝试通过 ID 获取一个 HTMLElement，或者返回一个默认值。TypeScript 标记了两个错误：

```ts
function getElement(elOrId: string | HTMLElement | null): HTMLElement {
  if (typeof elOrId === 'object') {
    return elOrId;
    // \~\~\~ Type 'HTMLElement | null' is not assignable to type 'HTMLElement'
  } else if (elOrId === null) {
    return document.body;
  }
  elOrId; // ^? (parameter) elOrId: string
  return document.getElementById(elOrId);
  // \~\~\~ Type 'HTMLElement | null' is not assignable to type 'HTMLElement'
}
```

if 语句的第一分支的意图是只过滤出对象，即 HTMLElement。但奇怪的是，在 JavaScript 中 typeof null 的结果是 "object"，因此在该分支中 elOrId 仍然可能是 null。可以通过将 null 检查放在前面来修复这个问题。第二个错误是因为 document.getElementById 可能返回 null，因此你也需要处理这种情况，也许可以通过抛出异常来处理：

```ts
function getElement(elOrId: string | HTMLElement | null): HTMLElement {
  if (elOrId === null) {
    return document.body;
  } else if (typeof elOrId == 'object') {
    return elOrId;
    // ^? (parameter) elOrId: HTMLElement
  }
  const el = document.getElementById(elOrId);
  // ^? (parameter) elOrId: string
  if (!el) {
    throw new Error(`No such element ${elOrId}`);
  }
  return el;
  // ^? const el: HTMLElement
}
```

TypeScript 语言服务还提供了重构工具。这些工具中最简单但最有用的一个是重命名符号。这比简单的查找替换要复杂，因为同一个名称在不同的地方可能引用不同的变量。例如，在这段代码中，有三个名为 i 的不同变量：

```ts
let i = 0;
for (let i = 0; i < 10; i++) {
  console.log(i);
  {
    let i = 12;
    console.log(i);
  }
}
console.log(i);
```

在 VS Code 中，如果你在 for 循环中点击一个 i，然后按 F2，会出现一个文本框让你输入新的名称（如图 2-6 所示）。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/c2bf92cdc898e067b0dc9604e757b1c0ac9aa7ed82942aa4a039efc35218e36c.jpg)
图 2-6. 在编辑器中重命名符号。

当你应用重构时，只有你重命名的 i 的引用会改变：

```ts
let i = 0;
for (let x = 0; x < 10; x++) {
  console.log(x);
  {
    let i = 12;
    console.log(i);
  }
}
console.log(i);
```

如果你重命名另一个模块导入的符号，那么这些导入也会相应更新。还有很多其他有用的重构操作，例如重命名或移动文件（这会更新所有导入）以及将符号移动到新文件。你应该熟悉这些操作，因为在处理大型 TypeScript 项目时，它们可以显著提高你的工作效率。

语言服务还可以帮助你导航自己的代码以及外部库和类型声明。假设你在代码中看到对全局 fetch 函数的调用，并想了解更多关于它的信息。你的编辑器应该提供一个“转到定义”选项。在我的编辑器中，它看起来像图 2-7 所示。

[![20250526175649.jpg](https://i.postimg.cc/k5yR2NsG/20250526175649.jpg)](https://postimg.cc/wt7jPmSY)

选择此选项会带你进入 lib.dom.d.ts，TypeScript 为 DOM 包含的类型声明：

```ts
declare function fetch(
  input: RequestInfo | URL,
  init?: RequestInit
): Promise<Response>;
```

你可以看到 fetch 返回一个 Promise，并接受两个参数。点击 RequestInfo 会带你到这里：

```ts
type RequestInfo = Request | string;
```

从这里你可以进入 Request:

```ts
interface Request extends Body {
  // ...
}
declare var Request: {
  prototype: Request;
  new (input: RequestInfo | URL, init?: RequestInit | undefined): Request;
};
```

在这里你可以看到请求类型和值是分开建模的（参见第 8 项）。你已经见过 RequestInfo 了。点击 RequestInit 可以看到在构建请求时你可以使用的所有选项：

```ts
interface RequestInit {
  body?: BodyInit | null;
  cache?: RequestCache;
  credentials?: RequestCredentials;
  headers?: HeadersInit;
  // ...
}
```

这里还有很多其他类型你可以继续探索，但你已经明白了大体思路。类型声明一开始可能难以阅读，但它们是了解 TypeScript 能做什么、你所使用的库是如何建模的以及如何调试错误的极佳方式。有关类型声明的更多信息，请参阅第 8 章。

### 注意事项

- 利用支持 TypeScript 语言服务的编辑器来使用这些功能。
- 使用编辑器来培养对类型系统工作原理以及 TypeScript 如何推断类型的理解。
- 熟悉 TypeScript 的重构工具，例如重命名符号和文件。
- 知道如何跳转到类型声明文件以查看它们如何建模行为。

## 项 7：将类型视为值集合

在运行时，每个变量都从 JavaScript 的值宇宙中选择一个单一值。可能的值包括：

- 42
- null
- undefined
- '加拿大'
- {animal: '鲸鱼', weight_lbs: 40000}
- /regex/
- new HTMLButtonElement
- (x, y) => x + y

但在你的代码运行之前，当 TypeScript 在检查代码时查找错误时，变量只是一个类型。这最好被理解为一组可能的值。这一组值被称为类型的域。例如，你可以将数字类型视为所有数字值的集合。42 和 -37.25 都在其中，但 'Canada' 不在其中。根据 strictNullChecks 的设置，null 和 undefined 可能或不可能是这一组值的一部分。

**注意**

> 你通常不会在 TypeScript 的文档或文献中，甚至在这本书的其他地方看到“域”这个词。类型通常与其值集合互换使用。但在本项中，使用一个专门的术语来指代类型的值集合，而不是类型本身，会很有帮助。

最小的集合是空集，它不包含任何值。这对应于 TypeScript 中的 never 类型。由于其域为空，因此无法将任何值分配给 never 类型变量：

```ts
const x: never = 12;
// \~ Type 'number' is not assignable to type 'never'.
```

由于 never 位于类型层次结构的底部，有时被称为“底类型”。

接下来是最小的集合，它们包含单一值。这些对应于 TypeScript 中的字面量类型。（在其他语言中，这些有时被称为“单位类型”）

```ts
type A = 'A';
type B = 'B';
type Twelve = 12;
```

要形成包含两个或三个值的类型，可以将字面量类型进行联合：

```ts
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

联合类型的域是其组成类型的域的并集，如图 2-8 所示。这就是“联合类型”中的“联合”所指的内容。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/5cd4685452d831ae511a43fafe8312d31dd3643aff98f8b21552d775fbb1406f.jpg)
图 2-8. 值和类型作为值的集合。方框表示值（"A", "B", 12），圆角形状表示类型（A, B, AB, AB12, Twelve），这些类型包括一个值的集合。一种类型可以被另一种类型赋值，如果它完全包含在另一种类型中。

“可赋值”这个词在 TypeScript 的许多错误中出现。在值的集合上下文中，它意味着“属于”（对于值和类型之间的关系）或“子集”（对于两种类型之间的关系）：

```ts
const a: AB = 'A'; // OK, value 'A' is a member of the set {'A', 'B'}
const c: AB = 'C';
// \~ Type '"C"' is not assignable to type 'AB'
```

类型 "C" 是一个字面量类型。它的域由单一值 "C" 组成。这并不是 AB 类型（由 "A" 和 "B" 组成的值的集合）的子集，因此这是一个错误。总的来说，类型检查器所做的大部分工作是测试一个集合是否是另一个集合的子集：

```ts
// OK, {"A", "B"} is a subset of {"A", "B"}:
const ab: AB = Math.random() < 0.5 ? 'A' : 'B';
const ab12: AB12 = ab; // OK, {"A", "B"} is a subset of {"A", "B", 12}

declare let twelve: AB12;
const back: AB = twelve;
// \~\~ Type 'AB12' is not assignable to type 'AB'
// Type '12' is not assignable to type 'AB'
```

这些类型的集合易于推理，因为它们是有限的。你可以逐个比较元素。但在实践中，你通常会处理具有无限域的类型。对这些类型的推理可能更困难。你可以将它们视为通过列出其元素构建的：

```ts
type Int = 1 | 2 | 3 | 4 | 5; // | ...
```

或者通过描述其成员构建的：

```ts
interface Identified {
  id: string;
}
```

将此接口视为对其类型域中值的描述。这个值是一个对象吗？它的 id 属性的值是否可以赋值给 string 类型？那么它就是一个 Identified。

这就是全部内容。如第 4 条所述，TypeScript 的结构化类型规则意味着该值还可以具有其他属性。它甚至可以是

可调用！有时过多的属性检查可能会掩盖这一事实（参见第 11 项）。

将类型视为值的集合有助于你对其上的操作进行推理。例如：

```ts
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

& 运算符计算两个类型的交集。哪些值属于 PersonSpan 类型？乍一看，Person 和 Lifespan 接口没有任何共同的属性，因此你可能会认为这是空集（即，never 类型）。但类型操作适用于值的集合（类型的作用域），而不是接口中的属性。并且请记住，具有额外属性的值仍然属于该类型。因此，一个同时具有 Person 和 Lifespan 属性的值将属于交集类型：

```ts
const ps: PersonSpan = {
  name: 'Alan Turing',
  birth: new Date('1912/06/23'),
  death: new Date('1954/06/07'),
}; // OK
```

当然，一个值可能具有这三种属性之外的更多属性，仍然属于该类型！一般规则是，交集类型的值包含其各个组成部分属性的并集。

关于相交属性的直觉是正确的，但对两个接口的并集而不是交集：

```ts
type K = keyof (Person | Lifespan); // ^? type K = never
```

对于并集类型中的值，TypeScript 无法确定一定会包含哪些键，因此并集类型的 keyof 必须是空集（never）。或者，更正式地说：

```ts
// Disclaimer: these are relationships, not TypeScript code!
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

如果你能理解为什么这些等式成立，你将大大接近理解 TypeScript 的类型系统！

更符合 TypeScript 语法习惯的方式是使用 extends 来定义 PersonSpan 类型：

```ts
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

将类型视为值的集合，那么 extends 意味着什么呢？你可以将其读作“子集”。在 PersonSpan 中，每个值都必须具有一个名为 name 的字符串属性，并且每个值还必须具有一个 birth 属性，因此它是一个真子集。

虽然 extends 通常用于向接口添加字段，但只要匹配基类型值的子集即可。这允许你更精细地建模类型关系：

```ts
interface NullyStudent {
  name: string;
  ageYears: number | null;
}
interface Student extends NullyStudent {
  ageYears: number;
}
```

并不是每种语言都允许你这样改变 ageYears 的类型，但只要它能被基类型（NullyStudent）中的类型赋值，TypeScript 就允许这样做。当你考虑这两个接口的领域时，这就有意义了。如果你尝试扩展 ageYears 的类型，将会得到一个错误：

```ts
interface StringyStudent extends NullyStudent {
  // // Interface 'StringyStudent' incorrectly extends interface 'NullyStudent'.
  ageYears: number | string;
}
```

你可能会听到“子类型”这个词。这实际上就是说一个类型的领域是另一个类型的子集。用一维、二维和三维向量来思考： %%

```ts
interface Vector1D {
  x: number;
}
interface Vector2D extends Vector1D {
  y: number;
}
interface Vector3D extends Vector2D {
  z: number;
}
```

你会说 Vector3D 是 Vector2D 的子类型，而 Vector2D 是 Vector1D 的子类型（在类的上下文中，你会说“子类”）。这种关系通常用层次结构来表示，但从值集合的角度考虑，用韦恩图更为合适（见图 2-9）。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/2a9424ec32ad27def0bc1f351dc911707cd596547580433cf0872d8ab2d0277c.jpg)
图 2-9. 类型关系的两种思考方式：层次结构或重叠集合。

用韦恩图来看，即使不使用 extends 重写接口，子集/子类型/可赋值关系也不会改变：

```ts
interface Vector1D {
  x: number;
}
interface Vector2D {
  x: number;
  y: number;
}
interface Vector3D {
  x: number;
  y: number;
  z: number;
}
```

集合没有改变，所以韦恩图也没有改变。

而在处理对象类型时，这两种解释都是可行的，但当开始考虑字面量类型和联合类型时，集合解释变得更为直观。

关键字 extends 也可以出现在泛型类型中作为约束，并且在此上下文中它也意味着“子集”（第 15 项）：

```ts
function getKey<K extends string>(val: any, key: K) {
  // ...
}
```

那么，什么是对 string 的扩展？如果你习惯于从对象继承的角度思考，这很难解释。你可以定义一个对象包装类型 String 的子类（第 10 项），但这似乎不太明智。

相反，从集合的角度思考，任何其领域是 string 子集的类型都可以。这包括字面量类型 string、字面量类型联合、模板字面量类型（第 54 项）以及 string 本身：

```ts
getKey({}, 'x'); // OK, 'x' extends string
getKey({}, Math.random() < 0.5 ? 'a' : 'b'); // OK, 'a'|'b' extends string
getKey({}, document.title); // OK, string extends string
getKey({}, 12);
// \~\~ Type 'number' is not assignable to parameter of type 'string'
```

“extends” 已经在上一个错误中变成了“assignable”，但这不应该困扰我们，因为我们知道要将两者都读作“子集”。

当类型之间的关系不是严格层次结构时，集合解释也更有意义。例如，string|number 和 string|Date 之间的关系是什么？它们的交集是非空的（是 string），但 neither 是另一个的子类型。尽管这些类型不符合严格的层次结构（参见图 2-10），它们域之间的关系是清晰的。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/e1abbe4e548ce1aa5496c5d81a2db239e40cad4ced8c22ec5f21a2614db579e2.jpg)
图 2-10. 并集类型可能不符合层次结构，但可以被视为值的集合。

将类型视为集合也可以澄清数组和元组之间的关系。例如：

```ts
const list = [1, 2]; // ^? const list: number[]
const tuple: [number, number] = list;

// Type 'number[]' is not assignable to type '[number, number]'
// Target requires 2 element(s) but source may have fewer
```

是否存在不是数对的数字列表？当然有！空列表和列表 \[1\] 就是例子。因此，number\[\] 不能被赋值为 \[number, number\]，因为它不是其子集。（相反的赋值是可以的。）

三元组可以被赋值为数对吗？从结构化类型的角度考虑，你可能会认为可以。数对有 0 和 1 两个键，它难道不能有其他的键，比如 2 吗？

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
// '[number, number, number]' is not assignable to '[number, number]'
// Source has 3 element(s) but target allows only 2.
```

答案是否定的，而且原因很有趣。TypeScript 并不是将数对模型为 {0: number, 1: number}，而是模型为 {0: number, 1: number, length: 2}。这样做是有道理的——你可以检查元组的长度——并且这阻止了这种赋值。而且这可能更好！

TypeScript 不断地测试可赋值性，正如你多次看到的，这是一种子集/子类型关系。有趣的是，TypeScript 很少检查类型是否相等。这使得编写类型测试变得具有挑战性，这是第 55 项的主题。

如果类型被视为值的集合，那么具有相同集合值的两种类型就是相同的。确实如此（下面会解释一个例外）。除非两种类型在语义上不同，只是碰巧具有相同的值域，否则没有理由定义相同的类型两次。

在从空类型（空类型）到完全未知的极端另一端，未知类型的值域是 JavaScript 中的所有值。每种类型都可以赋值给 unknown。由于它位于类型层次结构的顶端，因此被称为“顶层类型”。第 46 条详细介绍了如何在自己的代码中使用 unknown 类型。

最后值得一提的是，并非所有的值集合都能对应到 TypeScript 类型。没有针对所有整数或所有具有 x 和 y 属性但没有其他属性的对象的 TypeScript 类型。有时可以使用 Exclude 来减去类型，但仅当这会导致一个有效的 TypeScript 类型时才行：

```ts
type T = Exclude<string | Date, string | number>; // ^? type T = Date
type NonZeroNums = Exclude<number, 0>; // ^? type NonZeroNums = number
```

表 2-1 总结了 TypeScript 术语与集合论术语之间的对应关系。

表 2-1. TypeScript 术语和集合术语

[![20250526181131.jpg](https://i.postimg.cc/MKh95xSR/20250526181131.jpg)](https://postimg.cc/bs90Y7dN)

这种解释有一个重要的注意事项：它在你认为值是不可变的情况下效果最佳。例如，这两种类型的区别是什么？

```ts
interface Lockbox {
  code: number;
}
interface ReadonlyLockbox {
  readonly code: number;
}
```

这两种类型的领域完全相同，但它们是可观察到的不同：

```ts
const box: Lockbox = { code: 4216 };
const robox: ReadonlyLockbox = { code: 3625 };
box.code = 1234; // ok
robox.code = 1234;
// \~\~\~\~ Cannot assign to 'code' because it is a read-only property.
```

因此，有时你会听到对这个项目标题的变体：“类型是值的集合以及你可以对它们进行的操作。”第 14 项将更多地讨论 readonly，但一般来说，当你使用不可变值时，类型检查器会更有效。

### 注意事项

- 将类型视为值的集合（即类型的领域）。这些集合可以是有限的（例如，布尔型或字面量类型）或无限的（例如，数字型或字符串型）。
- TypeScript 中的类型形成交集集合（类似于文氏图），而不是严格的层次结构。两个类型可以相互重叠，而无需一方是另一方的子类型。
- 记住即使对象具有类型声明中未提及的额外属性，该对象仍然可以属于该类型。
- 操作类型应用于集合的领域。A | B 的领域是 A 和 B 的领域的并集。
- 将“extends”、“assignable to”和“subtype of”视为“subset of”的同义词。

## 第 8 条：了解如何判断一个符号是在类型空间还是值空间

TypeScript 中的符号存在于两个空间之一：

- 类型空间
- 值空间

这可能会让人困惑，因为同一个名称在不同的空间中可以指代不同的事物：

```ts
interface Cylinder {
  radius: number;
  height: number;
}
const Cylinder = (radius: number, height: number) => ({ radius, height });
```

接口 Cylinder 在类型空间中引入了一个符号。const Cylinder 在值空间中引入了一个同名的符号。它们彼此无关。根据上下文，当你写 Cylinder 时，你可能是在指代类型或值。有时这可能会导致错误：

```ts
function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius; // Property 'radius' does not exist on type '{}
  }
}
```

这里发生了什么？你大概本意是用 instanceof 来检查形状是否为 Cylinder 类型。但 instanceof 是 JavaScript 的运行时操作符，它作用于值。因此，instanceof Cylinder 指的是函数，而不是类型。

一开始并不总是能明显区分一个符号是在类型空间还是值空间。你必须根据符号出现的上下文来判断。这尤其令人困惑，因为许多类型空间的构造看起来与值空间的构造完全相同。

字面量类型，例如：

```ts
type T1 = 'string literal';
const v1 = 'string literal';
type T2 = 123;
const v2 = 123;
```

符号在类型定义或接口之后的是类型空间中的符号，而在 const 或 let 声明中引入的符号是值。

通过 TypeScript playground 来培养对这两种空间的直觉是很好的方法，它会显示你编写的 TypeScript 源代码生成的 JavaScript 代码。类型在编译过程中会被擦除（第 3 项），因此如果一个符号消失，那么它就在类型空间中（参见图 2-11）。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/aa75a23eb023b72d7cf4d387a083b756246d4c2371f8958b16429d8502ea35e9.jpg)
图 2-11. TypeScript playground 展示生成的 JavaScript 代码。前两行的符号消失了，所以它们在类型空间中。

TypeScript 中的语句可以在类型空间和值空间之间交替。类型声明（:）或断言（as）后的符号在类型空间中，而赋值操作符（=）之后的所有内容都在值空间中。例如：

```ts
interface Person {
  first: string;
  last: string;
}

const jane: Person = { first: 'Jane', last: 'Jacobs' };
//    ____           _________________________________ Values
//          ______ Type
```

特别是函数声明，可以在这两种空间之间反复交替：

```ts
function email(to: Person, subject: string, body: string): Response {
  //     _____ __          _______          ____        Values
  //               ______           ______        ______   ________ Types
}
```

类和枚举结构既引入了类型，也引入了值。以第一个例子为例，Cylinder 可以是一个类：

```ts
class Cylinder {
  radius: number;
  height: number;
  constructor(radius: number, height: number) {
    this.radius = radius;
    this.height = height;
  }
}
function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape; // ^? (parameter) shape: Cylinder shape.radius // ^? (property) Cylinder.radius: number
  }
}
```

类引入的 TypeScript 类型基于其形状（其属性和方法），而值是构造函数。

在类型或值的上下文中，有许多操作符和关键字具有不同的含义。例如，typeof：

```ts
type T1 = typeof jane;
// ^? type T1 = Person
type T2 = typeof email;
// ^? type T2 = (to: Person, subject: string, body: string) => Response

const v1 = typeof jane; // alue is "object"
const v2 = typeof email; // Value is "function"
```

在类型上下文中，typeof 接收一个值并返回其对应的 TypeScript 类型。你可以将这些操作符作为更大类型表达式的一部分使用，或者使用类型声明来为它们命名。

在值上下文中，typeof 是 JavaScript 的运行时 typeof 操作符。它返回一个包含符号运行时类型的字符串。这与 TypeScript 类型不同！JavaScript 的运行时类型系统比 TypeScript 的静态类型系统简单得多。与 TypeScript 类型的无限多样性相比，JavaScript 的 typeof 操作符只有八种可能的返回值："string"、"number"、"boolean"、"undefined"、"object"、"function"、"symbol" 和 "bigint"。

\[\] 属性访问器在类型空间中也有一个看起来相同的对应物。但请注意，虽然在值空间中 obj\['field'\] 和 obj.field 是等价的，但在类型空间中它们并不等价。您必须使用前者来获取另一种类型的属性类型：

```ts
const first: Person['first'] = jane['first']; // Or jane.first
//    _____                    _____________ Values
//           _______________ Types
```

Person\['first'\] 在这里是一个类型，因为它出现在类型上下文中（在 : 之后）。您可以在索引槽中放入任何类型，包括联合类型或原始类型：

```ts
type PersonEl = Person['first' | 'last']; // ^? type PersonEl = string
type Tuple = [string, number, Date];
type TupleEl = Tuple[number]; // ^? type TupleEl = string | number | Date
```

有关类型操作以及如何在类型之间进行映射的更多信息，请参见第 15 条。

在两个空间中有许多其他构造具有不同的含义：

- 在值空间中，this 是 JavaScript 的 this 关键字（第 69 条）。作为一种类型，this 是 TypeScript 中 this 的类型，即“多态 this”。它有助于实现子类的方法链。T T g
- 在值空间中，& 和 | 是按位与和或运算符。而在类型空间中，它们是交集和并集运算符。
- 在值空间中，const 引入了一个新的变量，但在类型空间中，as const 改变了字面量或字面量表达式的推断类型（第 20 条）。
- 在值空间中，extends 定义了一个子类（class A extends B），但在类型空间中，它定义了一个子类型（interface A extends B）或对泛型类型的约束（Generic）。
- 在值空间中，“in”用于 for 循环（for (key in object)），而在类型空间中，它用于映射类型（Item 15）。
- 在值空间中，!是 JavaScript 的逻辑非运算符（!x），但在类型空间中，它是非空类型断言（x!；参见 Item 9）。

如果 TypeScript 似乎完全不理解你的代码，那可能是因为对类型空间和值空间的混淆。例如，假设你将之前的 email 函数改为接受一个单一的对象参数来传递其参数（Item 38 解释了为什么这是一个好主意）：

```ts
function email(options: { to: Person; subject: string; body: string }) {
  //
}
```

在 JavaScript 中，你可以使用解构赋值为对象的每个属性创建局部变量：

```ts
function email({ to, subject, body }) {
  // ...
}
```

如果你在 TypeScript 中尝试这样做，会得到一些令人困惑的错误：

```ts
function email({
  to: Person, // Binding element 'Person' implicitly has an 'any' type
  subject: string, // Binding element 'string' implicitly has an 'any' type
  body: string, // Binding element 'string' implicitly has an 'any' type
}) {
  /* ... */
}
```

问题在于 Person 和 string 被解释为值上下文。你试图创建一个名为 Person 的变量和两个名为 string 的变量。相反，你应该将类型和值分开：

```ts
function email({
  to,
  subject,
  body,
}: {
  to: Person;
  subject: string;
  body: string;
}) {
  // ..
}
```

这会显著增加代码的冗长，但在实践中，你可能已经有命名的参数类型，或者可以从上下文中推断出这些类型（第 24 条）。

虽然类型空间和值空间中的类似构造初看可能会令人困惑，但一旦掌握了它们，这些构造就会成为一种记忆辅助工具。

### 注意事项

- 在阅读 TypeScript 表达式时，要知道自己是在类型空间还是值空间。可以通过使用 TypeScript 在线 playground 来培养这种直觉。
- 每个值都有一个静态类型，但这个类型仅在类型空间中可见。类型空间中的构造如 type 和 interface 在值空间中会被擦除且不可访问。
- 某些结构，如类或枚举，同时引入了类型和值。
- typeof、this 以及许多其他运算符和关键字在类型空间和值空间中的含义不同。

## 第 9 条：优先使用类型注解而非类型断言

TypeScript 似乎有两种方式为变量赋值并指定类型：

```ts
interface Person {
  name: string;
}
const alice: Person = { name: 'Alice' }; // ^? const alice: Person
const bob = { name: 'Bob' } as Person; // ^? const bob: Person
```

虽然这些都能达到类似的效果，但实际上它们是相当不同的！第一个（alice: Person）为变量添加了类型注解，并确保值符合该类型。而后者（as Person）则进行类型断言。这告诉 TypeScript，尽管它推断出的类型是这样，但你知道得更多，希望类型是 Person。

一般来说，你应该优先使用类型注解而不是类型断言。原因如下：

```ts
const alice: Person = {};
// \~ Property 'name' is missing in type '{}' but required in type 'Person'
const bob = {} as Person; // No error
```

类型注解验证值是否符合接口。由于不符合，TypeScript 会标记错误。而类型断言通过告诉类型检查器，出于某种原因，你知道得比它更多，从而消除了这个错误。

如果你指定了额外的属性，同样的情况也会发生：

```ts
const alice: Person = { name: 'Alice' occupation: 'TypeScript developer'
// Object literal may only specify known properties,
// and 'occupation' does not exist in type 'Person'
};
const bob = { name: 'Bob' occupation: 'JavaScript developer'
} as Person; // No error
```

虽然未声明的属性从结构化类型的角度来看是有效的（第 4 项），但它们通常是错误。TypeScript 有一个额外的工具，称为多余属性检查，可以标记具有声明类型的对象中的多余属性，但如果你使用断言，则不会应用此工具。第 11 项将对多余属性检查有更多的说明。

由于它们提供了额外的安全检查，除非你有特定的理由使用类型断言，否则你应该使用类型注解。

**注意**

> 您也可能看到看起来像 const bob = {} 的代码。这原本是断言的语法，等同于 {} as Person。现在这种语法较少使用，因为在.tsx 文件（TypeScript + React）中，{} 会被解释为开始标签。

在使用类型注解与箭头函数时可能会有些棘手。如果你想要在代码中使用名为 Person 的接口，该怎么办？

```ts
const people = ['alice', 'bob', 'jan'].map((name) => ({ name }));
// { name: string; }[]... but we want Person[]
```

这里使用类型断言似乎可以解决问题：

```ts
const people = ['alice', 'bob', 'jan'].map((name) => ({ name } as Person));
// Type is Person[]
```

但这种方式同样存在类型断言直接使用时的所有问题。例如：

```ts
const people = ['alice', 'bob', 'jan'].map((name) => ({} as Person));
// No error
```

那么在这种情况下，你该如何使用类型注解呢？最直接的方法是在箭头函数中声明一个变量：

```ts
const people = ['alice', 'bob', 'jan'].map((name) => {
  const person: Person = { name };
  return person;
}); // Type is Person[]
```

但与原始代码相比，这种方式引入了相当多的噪音。更简洁的方式是标注箭头函数的返回类型：

```ts
const people = ['alice', 'bob', 'jan'].map((name): Person => ({ name }));
// Type is Person[]
```

这种写法与之前的版本执行了相同的价值检查。这里的括号非常重要！(name): Person 允许从 name 的类型中推断出返回类型，并指定返回类型为 Person。但如果写成 (name: Person)，则会指定 name 的类型为 Person，同时允许返回类型从上下文中推断，这将导致错误。更多关于函数参数中类型推断的工作原理，请参见第 24 项。

在这种情况下，你也可以直接写出最终所需的类型，让 TypeScript 检查赋值的有效性：

```ts
const people: Person[] = ['alice', 'bob', 'jan'].map((name) => ({ name })); // OK
```

但在较长的函数调用链中，可能需要或希望更早地放置命名类型，这样可以更接近错误发生的地方来标记错误。

那么什么时候应该使用类型断言呢？类型断言在你比 TypeScript 更了解某个类型时最为合理，通常是因为 TypeScript 没有访问到类型检查无法获取的上下文信息。例如，在浏览器环境中，你可能比 TypeScript 更精确地知道一个 DOM 元素的类型：

```ts
document.querySelector('#myButton')?.addEventListener('click', (e) => {
  e.currentTarget;
  // ^? (property) Event.currentTarget: EventTarget | null
  //  currentTarget is #myButton is a button element
  const button = e.currentTarget as HTMLButtonElement;
  // ^? const button: HTMLButtonElement
});
```

由于 TypeScript 没有访问到页面的 DOM，它无法知道 #myButton 是一个按钮元素。它也不知道事件的 currentTarget 应该是同一个按钮。因为你有 TypeScript 没有的信息，所以这里使用类型断言是合理的。关于 DOM 类型的更多信息，请参见第 75 项。

当你使用类型断言时，最好在注释中解释为什么它是合理的。这为人类读者提供了缺失的信息，并帮助他们评估断言是否仍然合理。

如果一个变量的类型包括 null，但你知道从上下文来看这是不可能的，你可以使用类型断言来移除类型中的 null：

```ts
const elNull = document.getElementById('foo');
// ^? const elNull: HTMLElement | null
const el = document.getElementById('foo') as HTMLElement;
// ^? const el: HTMLElement
```

这种类型断言非常常见，因此得到了特殊的语法，并被称为非空断言：

```ts
const el = document.getElementById('foo')!; // ^? const el: HTMLElement
```

作为前缀，! 是 JavaScript 的逻辑非运算符。但作为后缀，! 被解释为一种类型断言，表明值是非空的。这比 as 更好，因为它允许类型中的非空部分保持不变。

尽管如此，你应该像对待其他任何断言一样谨慎地使用 !：在编译过程中它会被消除，因此你只能在类型检查器缺乏相关信息且能确保值为非空的情况下使用它。否则，你应该使用条件语句来检查空值情况。

如果你正在访问一个可能为 null 的对象的属性或方法，可以方便地使用“可选链”运算符 ?.:

```ts
document.getElementById('foo')?.addEventListener('click', () => {
  alert('Hi there!');
});
```

这与 !. 有一些表面的相似之处，但其实差别很大。a?.b 是一个 JavaScript 构造，它在运行时检查对象是否为 null（或 undefined），然后再继续评估表达式。a!.b 是一个类型级别的构造，编译后只是 a.b。如果对象在运行时为 null，它会抛出异常。a?.b 比 a!.b 更安全，但也不要过度使用它。如果你的应用程序需要添加事件监听器，那么最好知道它是否失败！

类型断言也有其局限性：它们不能让你在任意类型之间进行转换。一般来说，你可以使用类型断言将 A 转换为 B，前提是 A 和 B 是“可比较”的。使用第 7 条中的集合术语，这意味着 A 和 B 必须有一个非空交集。特别是，子类型是允许的。HTMLElement 是 HTMLElement | null 的子类型，所以这种类型断言是允许的。（这些类型的交集是 HTMLElement。）HTMLButtonElement 是 EventTarget 的子类型，所以这也是允许的。而 Person 是 {} 的子类型，所以这种断言也是可以的。

但你不能在 Person 和 HTMLElement 之间进行转换，因为它们的交集为空（即，never 类型）：

```ts
interface Person {
  name: string;
}
const body = document.body;
const el = body as Person;
// Conversion of type 'HTMLElement' to type 'Person' may be a mistake because
// neither type sufficiently overlaps with the other. If this was intentional,
// convert the expression to 'unknown' first.
```

错误提示了一个逃生出口，即使用 unknown 类型（第 46 项）。每个类型都是 unknown 的子类型，因此涉及 unknown 的断言总是正确的。这让你可以在任意类型之间进行转换，但至少你明确表示你在做一件可疑的事情！

```ts
const el = document.body as unknown as Person; // OK
```

并非所有的类型断言都使用 as 关键字。第 22 项解释了“自定义类型保护”（is），它允许你在类型断言中关联一些逻辑来检查其有效性。还可能使用泛型类型推断来进行类型断言，但这不是一个好主意，因为你很容易误以为 TypeScript 在检查你的类型，而实际上它并没有。这种模式（“仅返回的泛型”）在第 51 项中进行了探讨。

类型断言有时被称为“类型转换”。然而，这种术语是误导性的，最好避免使用。在像 C 这样的语言中，类型转换可以在运行时改变一个值（例如，从 int 到 float）。类型断言不能做到这一点。它们是类型级别的构造，在运行时会被消除，不会改变一个值。相反，它们“断言”关于该值已经是正确的某些东西。

最后，有 as const。虽然这看起来像是一个类型断言，但它更准确地被称为“常量上下文”。虽然 as T 会让你感到怀疑，但 as const 会使类型更加精确，并且是完全安全的。第 24 项展示了如何使用常量上下文来改进类型推断。

### 注意事项

- 优先使用类型注解（: Type）而不是类型断言（as Type）。
- 了解如何标注箭头函数的返回类型。
- 仅在你知道一些 TypeScript 无法知晓的类型信息时，才使用类型断言和非空断言。
- 当你使用类型断言时，应包含一个注释解释为什么它是有效的。

## 第 10 项：避免使用对象包装类型（String, Number, Boolean, Symbol, BigInt）

除了对象，JavaScript 还有七种原始值类型：字符串、数字、布尔值、null、undefined、symbol 和 bigint。前五种类型自语言诞生之初就存在。symbol 原始值是在 ES2015 中添加的，而 bigint 则是在 ES2020 中加入的。

原始值与对象的区别在于它们是不可变的且没有方法。你可能会认为字符串有方法：

> 'primitive'.charAt(3) 'm'

但实际上情况并非如此。这里其实发生了一些令人惊讶且微妙的事情。虽然字符串原始值没有方法，但 JavaScript 也定义了一个 String 对象类型，该类型有方法。JavaScript 可以自由地在这两种类型之间进行转换。当你在字符串原始值上调用方法（如 charAt）时，JavaScript 会将该原始值包装在一个 String 对象中，调用方法，然后丢弃该对象。

如果你在 \`String.prototype\` 上进行猴 patch（第 47 项），可以观察到这一点：

```ts
// Don't do this
const originalCharAt = String.prototype.charAt;

String.prototype.charAt = function (pos) {
  console.log(this, typeof this, pos);
  return originalCharAt.call(this, pos);
};
console.log('primitive'.charAt(3));
```

这会产生以下输出：

> 原始对象 3 m

该方法中的 this 值是一个 String 对象包装器，而不是字符串原始值。你可以直接实例化一个 String 对象，它有时会表现出字符串原始值的行为。但并不总是如此。例如，一个 String 对象永远只等于它自己：

> "hello" === new String("hello")
> false
> new String("hello") === new String("hello")
> false

隐式转换为对象包装类型解释了 JavaScript 中的一个奇怪现象——如果你将一个属性赋值给一个原始值，该属性会消失：

> \>x = "hello"
> 'hello'
> \>x.language = 'English'
> 'English'
> \> x.language
> undefined

现在你知道原因了：x 被转换为一个 String 实例，然后在其上设置了 language 属性，最后丢弃了这个对象（带有 language 属性的对象）。

此外，还有其他原始类型的对象包装类型：Number 用于数字、Boolean 用于布尔值、Symbol 用于符号，以及 BigInt 用于大整数（null 和 undefined 没有对象包装类型）。

这些包装类型作为方便存在，用于在原始值上提供方法，并提供静态方法（例如，
但通常没有直接实例化它们的理由。

TypeScript 通过为原始类型和它们的对象包装器定义不同的类型来体现这种区别：

- 字符串和 String
- 数字和 Number
- 布尔值和 Boolean
- 符号和 Symbol
- bigint 和 BigInt

很容易不小心输入 String（尤其是如果你是从 Java 或 C# 转过来的），而且看起来似乎可以正常工作：至少在最初是这样的：

```ts
function getStringLen(foo: String) { return foo.length;
}
getStringLen("hello"); / K
getStringLen(new String("hello")); // OK
```

但在尝试将 String 对象传递给期望 string 类型的方法时，问题就出现了：

```ts
function isGreeting(phrase: String) {
  return ['hello', 'good day'].includes(phrase); //
  // Argument of type 'String' is not assignable to parameter of type 'string'.
  // 'string' is a primitive, but 'String' is a wrapper object.
  // Prefer using 'string' when possible.
}
```

所以 string 可以赋值给 String，但 String 不能赋值给 string。这令人困惑吗？请遵循错误信息中的建议，使用 string。所有随 TypeScript 一起提供的类型声明都使用它，几乎所有的其他库也是如此。

另一种情况下，如果你显式地使用大写字母提供类型注解，可能会得到包装对象：

```ts
const s: String = 'primitive';
const n: Number = 12;
const b: Boolean = true;
```

这只会改变 TypeScript 的类型，并且如第 3 条所述，这不会影响运行时的值。它们仍然是原始类型，而不是对象。但 TypeScript 允许这些声明，因为原始类型可以赋值给对象包装器。这些注解既误导又多余（第 18 条）。最好还是使用原始类型。

最后需要注意的是，你可以不使用 new 调用 BigInt 和 Symbol，因为它们会生成原始类型：

> \> typeof BigInt(1234) 'bigint'
> typeof Symbol('sym') 'symbol'

这些是 BigInt 和 Symbol 值，而不是 TypeScript 类型（第 8 项）。调用它们会返回 bigint 和 symbol 类型。你可以通过在数字字面量后面加上“n”来直接构造一个 bigint：123n。

如果你的项目中使用了 typescript-eslint，ban-types 规则会禁止使用对象包装类型。这个规则在@typescript-eslint/recommended 配置中是启用的。

### 注意事项

- 避免使用 TypeScript 的对象包装类型。直接使用原始类型：使用 string 代替 String，使用 number 代替 Number，使用 boolean 代替 Boolean，使用 symbol 代替 Symbol，使用 bigint 代替 BigInt。
- 了解对象包装类型如何为原始值提供方法。避免实例化它们或直接使用它们，除非是 Symbol 和 BigInt。

## 第 11 条：区分多余属性检查与类型检查

当你将一个对象字面量赋值给一个已声明类型的变量时，TypeScript 会确保该对象具有该类型的所有属性且没有其他属性：

```ts
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}
const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present',
  // Object literal may only specify known properties,
  // and 'elephant' does not exist in type 'Room'
};
```

虽然存在一个大象属性很奇怪，但从结构类型的角度来看，这个错误并不太合理（Item 4）。那个常量可以被赋值给 Room 类型，你可以通过引入一个中间变量来验证这一点：

```ts
const obj = { numDoors: 1, ceilingHeightFt: 10, elephant: 'present' };
const r: Room = obj; // OK
```

obj 的类型被推断为 { numDoors: number; ceilingHeightFt: number; elephant: string }。这个类型是 Room 类型的一个子集，因为它只允许字符串类型的大象，而 Room 类型则允许任何类型的大象。因此它可以被赋值给 Room 类型，代码可以通过类型检查器。 （如果对“子集”这个术语不熟悉，请参阅 Item 7 进行复习。）

那么这两个例子有什么不同之处呢？在第一个例子中，你触发了一个被称为“多余属性检查”的过程，这有助于捕捉结构类型系统可能会忽略的重要类别的错误。但这个过程有其局限性，将其与常规的可赋值性检查混淆会使你更难建立起对结构类型的理解。将多余属性检查视为一个独立的过程，将有助于你更清晰地理解 TypeScript 类型系统的模型。

如第 1 项所述，TypeScript 并不仅仅是为了标记在运行时会抛出异常的代码。它还试图找出那些不符合你预期的代码。以下是一个这样的例子：

```ts
interface Options {
  title: string;
  darkMode?: boolean;
}
function createWindow(options: Options) {
  if (options.darkMode) {
    setDarkMode();
  } //
}
createWindow({
  title: 'Spider Solitaire',
  darkmode: true,
  // Object literal may only specify known properties,
  // but 'darkmode' does not exist in type 'Options'.
  // Did you mean to write 'darkMode'?
});
```

这段代码在运行时不会抛出任何错误。但它很可能不会达到你预期的效果，原因正是 TypeScript 所指出的：它应该是 darkMode（大写的 M），而不是 darkmode。

一个纯粹的结构化类型检查器无法发现这种错误，因为 Options 类型非常宽泛：它包括所有具有 title 属性为字符串且其他任何属性的对象，只要这些其他属性中没有将 darkMode 属性设置为除 true 或 false 之外的其他值。

很容易忘记 TypeScript 类型可以有多么宽泛。这里有一些可以赋值给 Options 的其他值：

```ts
const o1: Options = document; // OK
const o2: Options = new HTMLAnchorElement(); // OK
```

两个文档和 HTMLAnchorElement 实例都有 title 属性，这些属性都是字符串，因此这些赋值是允许的。Options 确实是一个广泛的类型！

冗余属性检查试图在不牺牲类型系统基本结构性质的情况下进行限制。它通过在使用声明类型的情况下禁止对象字面量上的未知属性来实现这一点。（有时因为它这个原因被称为“严格对象字面量检查”或“新鲜度检查”，因为它适用于新创建的对象。）

这种上下文可以是具有声明类型的变量的赋值、函数参数或具有声明返回类型的函数的返回值。文档和 new HTMLAnchorElement 都不是对象字面量，因此它们没有触发冗余属性检查。但{title, darkmode}对象是，所以它触发了冗余属性检查：

```ts
const o: Options = { darkmode: true, title: 'Ski Free' };
// 'darkmode' does not exist in type 'Options'.
```

这就是为什么使用没有类型注解的中间变量会使错误消失的原因：

```ts
const intermediate = { darkmode: true, title: 'Ski Free' };
const o: Options = intermediate; // OK
```

第一行右侧是一个对象字面量，而第二行（中间）的右侧不是一个对象字面量，因此不会进行多余的属性检查，错误也随之消失。

在使用类型断言时，多余的属性检查不会发生：

```ts
const o = { darkmode: true, title: 'MS Hearts' } as Options; // OK
```

这说明了更倾向于使用类型注解而非断言（第 9 项）的一个好理由。如果你不想进行这种检查，可以使用索引签名告诉 TypeScript 你期望有额外的属性：

```ts
interface Options {
  darkMode?: boolean;
  [otherOptions: string]: unknown;
}
const o: Options = { darkmode: true }; // OK
```

第 16 项讨论了在什么情况下使用索引签名来建模数据是合适或不合适的。

对于所谓的“弱”类型，即只包含可选属性的类型，也会进行相关检查：

```ts
interface LineChartOptions {
  logscale?: boolean;
  invertedYAxis?: boolean;
  areaChart?: boolean;
}
function setOptions(options: LineChartOptions) {
  /* ... */
}
const opts = { logScale: true };
setOptions(opts);
// Type '{ logScale: boolean; }' has no properties in common
// with type 'LineChartOptions'
```

从结构上看，LineChartOptions 类型应该包含几乎所有对象。对于这种“弱”类型，TypeScript 会添加另一个检查，以确保值类型和声明类型至少有一个共同的属性。这种检查类似于多余的属性检查，能够有效捕捉拼写错误，但并不严格依赖于结构。不过，与多余的属性检查不同，这种检查会在涉及“弱”类型的全部可赋值检查中发生。提取中间变量也无法绕过这种检查。

**注意**

在 TypeScript 中，“弱类型”是一个技术术语，特指只包含可选属性的接口。这与你所定义的类型的质量无关，而“强类型”这一术语在 TypeScript 或编程语言中并没有特定的含义，与“弱类型”互为反义词的说法并不成立。

过度属性检查是一种有效的方法，可以捕获由结构类型系统允许但拼写错误或其他属性名错误导致的问题。它特别适用于包含可选字段的类型，如 Options。但它的适用范围非常有限：仅适用于对象字面量。认识到这一点的局限性，并区分过度属性检查和普通的可赋值性检查，这将有助于你构建对两者都有的认知模型。

过度属性检查如何捕获错误并开启新的设计可能性的具体示例，请参见第 61 条。

## 注意事项

当你将一个对象字面量赋值给已知类型的变量或作为函数参数传递时，会进行过度属性检查。
额外属性检查是一种有效的方法，可以发现错误，但它与 TypeScript 类型检查器通常进行的结构可赋值性检查不同。将这些过程混为一谈会使你更难构建可赋值性的思维模型。TypeScript 类型不是“封闭”的（Item 4）。
要意识到额外属性检查的局限性：引入中间变量会移除这些检查。
“弱类型”是指只包含可选属性的对象类型。对于这些类型，可赋值性检查需要至少有一个匹配的属性。

## Item 12: 尽可能将类型应用于整个函数表达式

JavaScript（以及 TypeScript）区分函数声明和函数表达式：

```ts
function rollDice1(sides: number): number { /* ... */ } // tatement
const rollDice2 = function(sides: number): number { /* .*. */ }; / Expression
const rollDice3 = (sides: number): number => { /* ... */ }; // also expression
```

TypeScript 中函数表达式的一个优势是，你可以一次性为整个函数指定类型声明，而不是分别指定参数类型和返回类型：

```ts
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = (sides) => {
  /* ... */
};
```

如果你在编辑器中将鼠标悬停在 sides 上，你会发现 TypeScript 知道它的类型是 number。在如此简短的例子中，函数类型提供的价值不大，但该技术确实打开了许多可能性。

其中一个就是减少重复。例如，如果你想编写几个用于对数字进行算术运算的函数，你可以这样写：

```ts
function add(a: number, b: number) {
  return a + b;
}
function sub(a: number, b: number) {
  return a - b;
}
function mul(a: number, b: number) {
  return a * b;
}
function div(a: number, b: number) {
  return a / b;
}
```

或者使用单一函数类型来合并重复的函数签名：

```ts
type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
const sub: BinaryFn = (a, b) => a - b;
const mul: BinaryFn = (a, b) => a * b;
const div: BinaryFn = (a, b) => a / b;
```

这样类型注解比之前少了，而且它们与函数实现分离，使逻辑更加清晰。你还可以获得一个检查，确保所有函数表达式的返回类型都是 number。

库通常会提供常见函数签名的类型。例如，React 的类型定义中提供了 MouseEventHandler 类型，你可以将其应用于整个函数，而不需要为函数参数指定 MouseEvent 类型。如果你是库的作者，可以考虑为常见的回调函数提供类型声明。

另一种应该为函数表达式应用类型的情况是使其与某些其他函数的签名匹配。例如，在浏览器中，fetch 函数会发出 HTTP 请求：

```ts
const response = fetch('/quote?by=Mark+Twain'); // ^? const response: Promise<Response>
```

你通过 response.json() 或 response.text() 提取响应中的数据：

```ts
async function getQuote() {
  const response = await fetch('/quote?by=Mark+Twain');
  const quote = await response.json();
  return quote;
}
// {
// "quote": "If you tell the truth, you don't have to remember anything.",
// "source": "notebook",
// "date": "1894"
// }
```

（参见第 27 项了解更多关于 Promise 和 async/await 的内容。）

这里有一个 bug：如果对 /quote 的请求失败，响应体很可能包含类似“404 Not Found”的解释。这不是 JSON，因此 response.json() 会返回一个带有无效 JSON 消息的拒绝 Promise。这掩盖了实际的错误，即 404 错误。

很容易忘记 fetch 的错误响应并不会导致一个被拒绝的 Promise。让我们编写一个 checkedFetch 函数来为我们进行状态检查。在 lib.dom.d.ts 中，fetch 的类型声明如下：

```ts
declare function fetch(
  input: RequestInfo,
  init?: RequestInit
): Promise<Response>;
```

所以你可以这样编写 checkedFetch：

```ts
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
  const response = await fetch(input, init);
  if (!response.ok) {
    // An exception becomes a rejected Promise in an async function.
    throw new Error(`Request failed: ${response.status}`);
  }
  return response;
}
```

这可以写得更简洁一些：

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error(`Request failed: ${response.status}`);
  }
  return response;
};
```

我们从函数声明改为了函数表达式，并将类型（typeof fetch）应用到了整个函数上。这样可以让 TypeScript 推断 input 和 init 参数的类型。

类型注解还保证了 checkedFetch 的返回类型与 fetch 的返回类型相同。例如，如果你写的是 return 而不是 throw，TypeScript 就会捕获这个错误。

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  // 'Promise<Response | HTTPError>' is not assignable to 'Promise<Response>'
  // Type 'Response | HTTPError' is not assignable to type 'Response'
  const response = await fetch(input, init);
  if (!response.ok) {
    return new Error('Request failed: ' + response.status);
  }
  return response;
};
```

在第一个示例中的相同错误很可能会导致错误，但错误发生在调用 \`checkedFetch\` 的代码中，而不是在其实现中。此外，将整个函数表达式的类型而不是参数的类型进行注解，使你获得了更好的安全性。

如果你想要匹配另一个函数的参数类型但改变返回类型呢？可以使用剩余参数和内置的 \`Parameters\` 通用类型来实现：

```ts
async function fetchANumber(
  ...args: Parameters<typeof fetch>
): Promise<number> {
  const response = await checkedFetch(...args);
  const num = Number(await response.text());
  if (isNaN(num)) {
    throw new Error(`Response was not a number.`);
  }
  return num;
}
```

如果你在编辑器中检查 \`fetchANumber\`，你会发现 \`args\` 完全没有出现。它被 \`fetch\` 的参数名称所替代，这正是你想要的：

```ts
fetchANumber;
// ^? function fetchANumber(
// input: RequestInfo | URL, init?: RequestInit | undefined
// ): Promise<number>
```

这里的语法比直接对整个函数应用类型稍微复杂一些。根据具体情况判断是否直接写出参数类型会更好。第 62 项将讨论在通用类型上下文中使用剩余参数。 %%

即使你可能并不知道，当你向另一个函数传递回调时，你就会受益于这种技术。例如，当你使用数组的 \`map\` 或 \`filter\` 方法时，TypeScript 能够推断出回调参数的类型，并将该类型应用到你的函数表达式中。有关上下文在类型推断中如何使用的更多信息，请参见第 24 项。

当你编写具有相同类型签名的函数，或者编写许多具有相同类型签名的函数时，考虑是否可以为整个函数应用类型声明，而不是重复参数和返回值的类型。这里的“许多”和“重复”非常重要。不要将这一点推向极端！你不需要为每个函数提取出一个类型。对于单个独立函数且具有独特类型签名的常见情况，传统的函数声明完全合适。当有许多具有相同或相关类型签名的函数时，使用函数类型。

### 注意事项

- 考虑为整个函数表达式应用类型注解，而不是仅为其参数和返回类型。
- 如果你反复编写相同的类型签名，可以提取出一个函数类型或将它替换为已存在的类型。
- 如果你是库作者，为常见的回调函数提供类型。
- 使用 \`typeof fn\` 匹配另一个函数的类型签名，或者如果需要更改返回类型，可以使用 \`Parameters\` 和剩余参数。

## 第 13 条：了解 \`type\` 和 \`interface\` 之间的区别

如果你想在 TypeScript 中定义一个命名类型，你有两个选择。你可以使用类型别名，如下所示：

```ts
type TState = { name: string; capital: string };
```

或者定义一个接口：

```ts
interface IState {
  name: string;
  capital: string;
}
```

（你也可以使用类，但那是一个 JavaScript 运行时的概念，还会引入一个值。参见第 8 项。）

你应该使用类型别名还是接口呢？这两个选项之间的界限在过去几年中变得越来越模糊，以至于在大多数情况下你可以使用任意一个。你应该了解类型和接口之间仍然存在的区别，并在不同情况下保持一致性地使用它们。但你也应该知道如何用两者来写出相同类型的代码，这样你就能舒适地阅读使用任意一种的 TypeScript 代码。

对于新代码，如果需要选择一种风格，在可能的情况下应使用接口。在需要类型的地方（例如，联合类型）或语法更简洁的地方（例如，函数类型）使用类型。我们将在本项末尾讨论这种选择的理由，但现在让我们探讨这两种构造之间的相似之处和差异之处。

**WARNING**

> 本项中的类型名称前缀 I 或 T 仅用于指示它们是如何定义的。在你的代码中不应该这样做！在 C# 中，接口类型前缀 I 是常见的做法，这种约定在 TypeScript 的早期阶段也有所影响。但今天，这种做法被认为是不良风格，因为它没有必要，增加的价值很小，并且标准库中并不一致地遵循这种做法。

首先，相似之处：这两种 State 类型几乎无法区分。如果你定义了一个 IState 或 TState 值并添加了一个额外的属性，从多余的属性检查（第 11 条）中获得的错误信息是逐字符相同的：

```ts
const wyoming: TState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 578_000,
  // Object literal may only specify known properties,
  // and 'population' does not exist in type 'TState'
};
```

你可以使用索引签名同时与接口和类型一起使用：

```ts
type TDict = { [key: string]: string };
interface IDict {
  [key: string]: string;
}
```

你还可以使用以下任意一种方式定义函数类型：

```ts
type TFn = (x: number) => string;
interface IFn {
  (x: number): string;
}
type TFnAlt = { (x: number): string };
const toStrT: TFn = (x) => '' + x; // OK

const toStrI: IFn = (x) => '' + x; // OK
const toStrTAlt: TFnAlt = (x) => +x; // OK
```

第一种类型别名形式（TFn）看起来更自然，也更简洁，适用于函数类型。这是首选形式，也是你在类型声明中遇到最多的。后两种形式反映了 JavaScript 中的函数是可以调用的对象这一事实。它们有时在重载函数签名（第 52 项）中很有用。

类型别名和接口都可以是泛型：

```ts
type TBox<T> = { value: T };
interface IBox<T> {
  value: T;
}
```

接口可以扩展一种类型（有一些限制，稍后解释），而一种类型也可以扩展一个接口：

```ts
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number };
```

再次强调，这些类型是完全相同的。唯一的限制是接口只能扩展那些可以用接口定义的对象类型（即使你偶然用类型定义了它们）。例如，你不能扩展联合类型。如果你想这样做，你需要使用类型和&。

类可以实现一个接口或一个简单的类型：

```ts
class StateT implements TState {
  name: string = '';
  capital: string = '';
}
class StateI implements IState {
  name: string = '';
  capital: string = '';
}
```

最后，无论是类型还是接口都可以是递归的（第 57 条）。

这些是相似之处。那么不同之处呢？你已经看到了一个例子——有联合类型但没有联合接口：

```ts
type AorB = 'a' | 'b';
```

接口可以扩展某些类型，但不能扩展这种类型。扩展联合类型有时是有用的。如果你有独立的输入和输出变量类型，并且有一个从名称到变量的映射：

```ts
type Input = {
  /* ... */
};
type Output = {
  /* ... */
};
interface VariableMap {
  [name: string]: Input | Output;
}
```

那么你可能需要一个类型来将名称附加到变量上。这个类型应该是：

```ts
type NamedVariable = (Input | Output) & { name: string };
```

这种类型无法用接口来表达。一般来说，类型比接口更强大。类型可以是联合类型，并且还可以利用诸如映射类型（第 15 项）和条件类型（第 52 项）等高级类型级特性。

接口和扩展比类型和 &: 提供了更多的错误检查：

```ts
interface Person {
  name: string;
  age: string;
}
type TPerson = Person & { age: number }; // no error, unusable type

interface IPerson extends Person {
  // Interface 'IPerson' incorrectly extends interface 'Person'.
  // Types of property 'age' are incompatible.
  // Type 'number' is not assignable to type 'string'.
  age: number;
}
```

只要子类型中的属性类型与基类型兼容（参见第 7 条），在子类型中更改属性的类型是可以接受的。通常你更希望有更多的安全检查，因此使用接口和扩展是一个很好的理由。

类型别名是表达元组类型和数组类型的一种自然方式：

```ts
type Pair = [a: number, b: number];
type StringList = string[];
type NamedNums = [string, ...number[]];
```

然而，接口确实有一些类型不具备的能力。其中之一就是接口可以被扩展。回到 State 示例，你还可以通过另一种方式添加 population 字段：

```ts
interface IState {
  name: string;
  capital: string;
}
interface IState {
  population: number;
}
const wyoming: IState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 578_000,
}; // OK
```

这被称为“声明合并”，如果你之前从未见过，这会显得相当令人惊讶。它主要用于类型声明文件（第 8 章），如果你正在编写这类文件，应该遵循规范并使用 interface 来支持它。这个概念是，你的类型声明中可能存在用户需要填补的空白，而声明合并就是他们填补这些空白的方式。（第 71 项会带你了解这一过程。）

为了理解为什么这个看似不寻常的功能很有用，可以看看 TypeScript 本身是如何使用声明合并来模拟 JavaScript 标准库的不同版本的。例如，Array 接口在 lib.es5.d.ts 中定义：

```ts
// lib.es5.d.ts
interface Array<T> {
  /** Gets or sets the length of the array. */
  length: number;
  // ...
  [n: number]: T;
}
```

如果你在 tsconfig.json 中将 target 设置为 ES5（第 2 项），那么你只会得到这些内容。这个定义包含了 2009 年 ES5 发布时数组上可用的所有属性和方法。但如果你将 target 设置为 ES2015，TypeScript 也会包含 lib.es2015.core.d.ts。这个文件中又包含了一个 Array 接口的声明：

```ts
// lib.es2015.core.d.ts
interface Array<T> {
  /** Returns the index of the first element in the array where predicate... */
  findIndex(
    predicate: (value: T, index: number, obj: T[]) => unknown,
    thisArg?: any
  ): number;
  // ... also find, fill, copyWithin
}
```

此声明仅包含在 ES2015 中新增的四个 Array 方法：find、findIndex、fill 和 copyWithin。这些方法通过声明合并添加到 ES5 的 Array 接口中。最终效果是，你将获得一个单一的 Array 类型，正好包含你所针对的 JavaScript 版本所需的所有方法。

正如名称所暗示的，声明合并最适用于声明文件。它可以在用户代码中发生，但前提是这两个接口定义在同一个模块中（即同一个.ts 文件）。这可以防止与全局接口（如 Location 和 FormData 等听起来通用的名字）发生意外冲突。

另一个不同之处是，TypeScript 总是试图通过接口名称来引用接口，而不会随意用类型别名替换其底层定义。你有时会在错误信息和类型显示（第 56 条）中看到这种情况，但它也可能影响具体的输出，例如，如果你在 tsconfig.json 中设置 declaration: true，TypeScript 会生成.d.ts 文件。

例如，考虑这个函数，它使用具有有限作用域的类型别名静态地返回一个对象：

```ts
export function getHummer() {
  type Hummingbird = { name: string; weightGrams: number };
  const ruby: Hummingbird = { name: 'Ruby-throated', weightGrams: 3.4 };
  return ruby;
}
const rubyThroat = getHummer();
// ^? const rubyThroat: Hummingbird
```

有趣的是，TypeScript 使用了一个不在作用域内的类型名称（Hummingbird）来报告这里的类型。更有趣的是，当你为这段代码生成一个 .d.ts 文件时会发生什么：

```ts
// get-hummer.d.ts
export declare function getHummer(): { name: string; weightGrams: number };
```

由于没有函数体来定义类型别名（这是一个类型声明文件），TypeScript 选择将类型别名内联。名称消失了，只剩下结构。由于类型系统是结构性的（第 4 条），这不会影响可赋值给该类型的值。但它会影响显示，并影响生成的 .d.ts 文件。在某些情况下，这种内联行为可能会导致类型重复过多，从而影响编译器性能（第 78 条）。

如果你使用接口而不是类型别名会发生什么：

```ts
export function getHummer() {
  // Return type of exported function has or is using private name'Hummingbird'.
  interface Hummingbird {
    name: string;
    weightGrams: number;
  }
  const bee: Hummingbird = { name: 'Bee Hummingbird', weightGrams: 2.3 };
  return bee;
}
```

因为 Hummingbird 是一个接口，TypeScript 想要通过名称来引用它。但由于名称在类型声明文件中不可用，因此出现了错误。1 虽然在某些情况下，内联行为可能看起来更可取，但它可能导致巨大的类型，并且如第 67 条所述，通常最好还是导出你的类型。这里更好的解决方案是保留接口，并将其作为顶级导出。

回到该条目的开头问题，你应该使用类型还是接口？对于复杂的类型，你别无选择：你需要使用类型别名。而对于函数类型、元组类型和数组类型，类型语法比接口语法更加简洁和自然。但如果是简单的对象类型，你可以用两种方式表示。

如果你在一个已有风格的代码库中工作，那就遵循现有的风格。你大概率不会出错。

对于没有既定风格的新项目，优先使用接口。这样你的类型名称会在错误信息和类型显示中更加一致，并且你会得到更多的检查，确保你正确地扩展了其他接口。这是官方 TypeScript 手册的观点：

大多数情况下，你可以根据个人偏好来选择，TypeScript 会告诉你如果需要使用另一种声明类型。如果你希望有一个启发式规则，那就使用接口，直到你需要使用类型提供的功能。

换句话说，能用接口就用接口，必须用类型时或者用起来更顺手时就用类型。但也不要在这方面过于纠结。

你可以使用 TypeScript-eslint 的 consistent-type-definitions 规则来强制一致地使用类型或接口，该规则属于风格化预设（默认情况下更偏好接口）。

### 注意事项

- 理解类型和接口之间的差异和相似之处。
- 掌握如何使用任一语法编写相同类型。
- 了解接口和类型的声明合并以及类型内联。
- 对于没有既定风格的项目，优先使用接口而非类型来表示对象类型。

## 第 14 条：使用 readonly 以避免与修改相关的错误。

以下是一些用于打印三角数（1, 1 + 2 = 3, 1 + 2 + 3 = 6，等等）的代码：

```ts
function printTriangles(n: number) {
  const nums = [];
  for (let i = 0; i < n; i++) {
    nums.push(i);
    console.log(arraySum(nums));
  }
}
```

（我们稍后会解释 arraySum 的定义。）

这段代码看起来虽然简单但效率不高，但当你运行它时会发生以下情况：

> printTriangles(5); 0 1 2 3 4

哎呀！这些数字不是我们预期的。出了什么问题？让我们看看我实现的 arraySum 函数：

```ts
function arraySum(arr: number[]) {
  let sum = 0,
    num;
  while ((num = arr.pop()) !== undefined) {
    sum += num;
  }
  return sum;
}
```

这个函数确实计算了数组中数字的总和。但它还有一个副作用，即清空了数组！TypeScript 没有意见，因为 JavaScript 数组是可变的。问题在于 printTriangles 假设了 arraySum 不会修改 nums。

可变性是许多难以追踪的 bug 的根源。在 JavaScript 中，默认情况下是可变的，但 TypeScript 的 readonly 修饰符可以帮助你发现并防止意外的可变性。由于它可以防止这类严重的 bug，学习如何在自己的代码中使用这一功能是值得的。

JavaScript 原始类型已经是不可变的。字符串、数字和布尔值上没有方法会改变这些值本身。（你可以用 let 声明一个变量并将其重新赋值为另一个原始类型，但这并不会改变原始值本身。）

正如你所见，数组（和对象）确实是可以改变的。这就是 TypeScript 的 readonly 修饰符发挥作用的地方。

将 readonly 修饰符放在对象类型的属性上，可以防止对该属性的赋值：

```ts
interface PartlyMutableName {
  readonly first: string;
  last: string;
}
const jackie: PartlyMutableName = { first: 'Jacqueline', last: 'Kennedy' };
jackie.last = 'Onassis'; // OK
jackie.first = 'Jacky';
// \~\~\~ Cannot assign to 'first' because it is a read-only property.
```

通常，你希望防止对象上所有属性的赋值。TypeScript 提供了一个通用的工具类型 Readonly，它正是为此目的设计的：

```ts
interface FullyMutableName first: string; last: string;
}
type FullyImmutableName = Readonly<FullyMutableName>;
// ^? type FullyImmutableName = {
// readonly first: string;
// readonly last: string;
// }
```

（注意 readonlys：从 interface 到 type 的改变在这里并不重要。）

如果一个函数接受一个对象作为参数并且不修改它，那么将该类型包装在 \`Readonly\` 中是一个好主意，这可以向调用者宣传这一特性，并在实现中强制执行。

关于 \`readonly\` 属性修饰符和 \`Readonly\`，有两个重要的注意事项。首先，它们是浅层的。就像 \`const\` 声明一样，\`readonly\` 属性不能重新赋值，但它可以被修改：

```ts
interface Outer {
  inner: { x: number };
}
const obj: Readonly<Outer> = { inner: { x: 0 } };
obj.inner = { x: 1 };
// \~\~ Cannot assign to 'inner' because it is a read-only property
obj.inner.x = 1; // OK
```

你可以创建一个类型别名，然后在编辑器中检查它，以了解具体发生了什么：

```ts
type T = Readonly<Outer>;
// ^? type T = {
// readonly inner: { // x: number;
// };
// }
```

需要注意的重要一点是，\`inner\` 上有 \`readonly\` 修饰符，但 \`x\` 上没有。没有内置的深层 \`readonly\` 类型支持，但可以通过编写泛型类型来生成它们。正确实现这一点是相当复杂的，因此我建议使用库而不是自己实现。\`ts-essentials\` 中的 \`DeepReadonly\` 泛型就是一个实现。

关于 Readonly 的第二个注意事项是，它只影响属性。如果你将其应用于包含会修改底层对象的方法的类型，它不会移除这些方法：

```ts
const date: Readonly<Date> = new Date();
date.setFullYear(2037); // OK, but mutates date!
```

如果你想为一个类同时提供可变和不可变版本，通常需要你自己将它们分开。标准库中的一个很好的例子是 Array 和 ReadonlyArray 接口。以下是 Array 的样子（在 lib.es5.d.ts 中）：

```ts
interface Array<T> {
  length: number;
  // (non-mutating methods)
  toString(): string;
  join(separator?: string): string;
  // ...
  // (mutating methods)
  pop(): T | undefined;
  shift(): T | undefined;
  // ...
  [n: number]: T;
}
```

而对应的不可变版本 ReadonlyArray 如下：

```ts
interface ReadonlyArray<T> {
  readonly length: number; // (non-mutating methods)
  toString(): string;
  join(separator?: string): string;
  // ...
  readonly [n: number]: T;
}
```

主要的区别在于，修改方法（如 pop 和 shift）没有定义在 ReadonlyArray 上，而且两个属性 length 以及索引类型 (\[n: number\]: T) 都带有 readonly 修饰符。这防止了数组的重新调整大小以及对数组元素的赋值。（number 作为索引类型是你自己的代码中不应该使用的；参见第 17 项。）

由于 Array 和 ReadonlyArray 非常常见，因此它们获得了特殊的语法：T\[\] 和 readonly T\[\]。因为 T\[\] 的功能严格上比 readonly T\[\] 更强大，所以 T\[\] 是 readonly T\[\] 的子类型。（很容易把这一点记反——记得第 7 条！）

所以你可以将可变数组赋值给只读数组，但反过来不行：

```ts
const a: number[] = [1, 2, 3];
const b: readonly number[] = a;
const c: number[] = b;
// \~ Type 'readonly number[]' is 'readonly' and cannot be
// assigned to the mutable type 'number[]'
```

这合乎逻辑：如果只读修饰符没有类型断言就能被移除，那它就没什么用处了。

现在我们有了改进 printTriangles 和 arraySum 函数所需的工具。如果 printTriangles 想阻止 arraySum 修改 nums 数组，它可以通过传递一个只读视图来实现：

```ts
function printTriangles(n: number) {
  const nums = [];
  for (let i = 0; i < n; i++) {
    nums.push(i);
    console.log(arraySum(nums as readonly number[]));
    // The type 'readonly number[]' is 'readonly' and cannot be
    // assigned to the mutable type 'number[]'.
  }
}
```

我们不能声明 nums 是 readonly number\[\]，因为我们仍然需要对其进行修改。我们只是希望确保 arraySum 不会这样做。由于它被声明为接受可变数组，因此会引发类型错误。

你可以通过使其接受 readonly 数组来解决这个问题。现在在 arraySum 中会引发类型错误：

```ts
function arraySum(arr: readonly number[]) {
  let sum = 0,
    num;
  while ((num = arr.pop()) !== undefined) {
    // 'pop' does not exist on type 'readonly number[]'
    sum += num;
  }
  return sum;
}
```

这条错误信息在我们之前看到的 Array 和 ReadonlyArray 接口中是有意义的。pop 方法存在于 Array 中，但不存在于 ReadonlyArray 中。

我们可以通过不修改数组来解决 arraySum 中的类型错误：

```ts
function arraySum(arr: readonly number[]) {
  let sum = 0;
  for (const num of arr) {
    sum += num;
  }
  return sum;
}
```

现在 printTriangles 的行为符合预期：

> printTriangles(5) 0 1 3 6 10

当你给一个参数指定只读类型（对于数组是 readonly，对于对象类型是 Readonly）时，会发生一些事情：

- TypeScript 会检查该参数在函数体内没有被修改。
- 您向调用者宣传您的函数不会修改参数。
- 调用者可以向您的函数传递只读数组或只读对象

如果您的函数不会修改其参数，那么您应该声明这些参数为只读。这样做几乎没有明显的缺点：用户可以用更广泛的数据类型调用它们（见第 30 条），并且意外的修改会被捕获。

（请注意，您仍然可以重新赋值只读参数。它们就像使用 let 而不是 const 声明的变量。重新赋值对函数的调用者是不可见的，而修改则是可见的。）

一个问题是，你可能需要调用没有将参数标记为只读的函数。如果这些函数不会修改其参数，并且你能够控制它们，那么请将它们标记为只读！只读往往会具有传染性：一旦你将一个函数标记为只读，你还需要标记它调用的许多其他函数。这是一件好事，因为它会导致更清晰的契约和更好的类型安全性。但如果你正在调用另一个库中的函数，你可能无法更改其类型声明。在这种情况下，你将不得不要么使用类型断言（param as number\[\]），要么修补类型声明（第 71 条）。

在 JavaScript（以及 TypeScript）中，通常假设函数不会修改其参数，除非明确指出。但正如本书中我们将反复看到的（特别是第 31 条和第 33 条），这种隐含的理解可能会导致类型检查方面的问题。最好将它们明确表示出来，既对人类读者，也对 tsc。

### 注意事项

- 如果函数不修改其参数，请声明为 readonly（对于数组）或 Readonly（对于对象类型）。这会使函数的契约更加清晰，并防止在其实现中发生意外的修改。
- 请注意 readonly 和 Readonly 是浅层的，Readonly 只影响属性，不影响方法。
- 使用 readonly 可以防止因修改而导致的错误，并找出代码中发生修改的地方。
- 理解 const 和 readonly 之间的区别：前者防止重新赋值，后者防止修改。

## 第 15 条：使用类型操作和泛型类型避免重复代码

这段脚本打印了几根圆柱的尺寸、表面积和体积：

```ts
console.log(
  'Cylinder r=1 × h=1',
  'Surface area:',
  6.283185 * 1 * 1 + 6.283185 * 1 * 1,
  'Volume:',
  3.14159 * 1 * 1 * 1
);
console.log(
  'Cylinder r=1 × h=2',
  'Surface area:',
  6.283185 * 1 * 1 + 6.283185 * 2 * 1,
  'Volume:',
  3.14159 * 1 * 2 * 1
);
console.log(
  'Cylinder r=2 × h=1',
  'Surface area:',
  6.283185 * 2 * 1 + 6.283185 * 2 * 1,
  'Volume:',
  3.14159 * 2 * 2 * 1
);
```

这段代码看着不舒服吗？确实如此。它极其重复，仿佛是复制粘贴了相同的代码行，然后进行了修改。它既重复了数值也重复了常量。这导致了一个错误潜入其中（你发现了吗？）。

更好的做法是提取一些函数、常量和循环：

```ts
type CylinderFn = (r: number, h: number) => number;
const surfaceArea: CylinderFn = (r, h) => 2 * Math.PI * r * (r + h);
const volume: CylinderFn = (r, h) => Math.PI * r * r * h;
for (const [r, h] of [
  [1, 1],
  [1, 2],
  [2, 1],
]) {
  console.log(
    `Cylinder r=${r} × h=${h}`,
    `Surface area: ${surfaceArea(r, h)}`,
    `Volume: ${volume(r, h)}`
  );
}
```

公式写得清楚明了后，错误消失了（最后一个例子中表面积计算时用的是 \\(r \\times h\\) 而不是 \\(r \\times r\\)）。这就是 DRY 原则：

不要重复自己。这是软件开发中能找到的最接近通用建议的建议之一。然而，那些在代码中尽力避免重复的开发者可能不会在类型上多加考虑。

```ts
interface Person {
  firstName: string;
  lastName: string;
}
interface PersonWithBirthDate {
  firstName: string;
  lastName: string;
  birth: Date;
}
```

类型中的重复与代码中的重复有很多相同的问题。如果你决定向 Person 添加一个可选的 middleName 字段，那么 Person 和 PersonWithBirthDate 就会分道扬镳。

类型中重复出现的原因之一是，提取共享模式的机制不如代码中熟悉：类型系统中对应于提取辅助函数的是什么？通过学习如何映射类型，你可以将 DRY 原则应用到你的类型定义中。

减少重复的最简单方法是命名你的类型。而不是这样写距离函数：

```ts
function distance(a: { x: number; y: number }, b: { x: number; y: number }) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}
```

为类型起一个名字并使用它：

```ts
interface Point2D {
  x: number;
  y: number;
}
function distance(a: Point2D, b: Point2D) {
  /*...*/
}
```

这相当于在类型系统中提取常量而不是重复书写。重复的类型有时并不那么容易被发现。有时它们可能会被语法所掩盖。

例如，如果几个函数共享相同的类型签名：

```ts
function get(url: string, opts: Options): Promise<Response> {
  /* ... */
}
function post(url: string, opts: Options): Promise<Response> {
  /* ... */
}
```

然后你可以遵循第 12 条建议，提取一个命名类型来表示这个签名：

```ts
type HTTPFunction = (url: string, opts: Options) => Promise<Response>;
const get: HTTPFunction = (url, opts) => {
  /* ... */
};
const post: HTTPFunction = (url, opts) => {
  /* ... */
};
```

本文开头的 CylinderFn 类型就是另一个这样的例子。

至于 Person / PersonWithBirthDate 的例子？你可以通过让一个接口继承另一个接口来消除重复：

```ts
interface Person {
  firstName: string;
  lastName: string;
}
interface PersonWithBirthDate extends Person {
  birth: Date;
}
```

现在你只需要编写额外的字段即可。如果两个接口共享一部分字段，那么你可以提取一个包含这些公共字段的基接口。例如，而不是为鸟类和哺乳动物定义独立的类型：

```ts
interface Bird {
  wingspanCm: number;
  weightGrams: number;
  color: string;

  isNocturnal: boolean;
}
interface Mammal {
  weightGrams: number;
  color: string;
  isNocturnal: boolean;
  eatsGardenPlants: boolean;
}
```

你可以提取一个脊椎动物类来包含一些共享的属性：

```ts
interface Vertebrate {
  weightGrams: number;
  color: string;
  isNocturnal: boolean;
}
interface Bird extends Vertebrate {
  wingspanCm: number;
}
interface Mammal extends Vertebrate {
  eatsGardenPlants: boolean;
}
```

现在如果你更改基础属性或在它们上添加 TSDoc 注释（第 68 条），这些更改将会反映在鸟类和哺乳类中。继续用代码重复的类比，这类似于编写 PI 和 2\*PI 而不是 3.141593 和 6.283185。

你还可以使用交集运算符 (&) 来扩展现有类型，尽管这种情况比较少见：

```ts
type PersonWithBirthDate = Person & { birth: Date };
```

这种技术在你想要向联合类型添加一些额外属性（你不能扩展联合类型）时最为有用。有关此内容的更多信息，请参见第 13 条。

你也可以反向操作。假设你有一个类型 \`State\`，它代表整个应用程序的状态，还有一个类型 \`TopNavState\`，

这仅仅代表一部分吗？

```ts
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}
interface TopNavState {
  userId: string;
  pageTitle: string;
  recentFiles: string[]; // omits pageContents
}
```

与其通过扩展 TopNavState 来构建 State，你希望将 TopNavState 定义为 State 字段的子集。这样可以保持一个接口来定义整个应用的状态。

可以通过索引 State 来消除属性类型的重复：

```ts
interface TopNavState {
  userId: State['userId'];
  pageTitle: State['pageTitle'];
  recentFiles: State['recentFiles'];
}
```

虽然更长了一些，但这已经是进步：State 中 \`pageTitle\` 类型的变化会在 TopNavState 中反映出来。但仍然有些重复。你可以通过映射类型来改进：

```ts
type TopNavState = {
  [K in 'userId' | 'pageTitle' | 'recentFiles']: State[K];
};
```

将鼠标悬停在 TopNavState 上会显示，这个定义实际上与之前的定义完全相同（参见图 2-12）。

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/b0b4499367e41b929a76664739a1e3e1d237f61188f9bdcf9c01ed48f2c19a42.jpg)图 2-12. 在文本编辑器中显示映射类型的展开版本。这与初始定义相同，但减少了重复。

映射类型相当于遍历数组中的字段。这种模式非常常见，已经作为标准库的一部分，名为 Pick：

```ts
type Pick<T, K> = { [k in K]: T[k] };
```

（这个定义还不完整。我们将在第 50 项中重新审视它。）你可以这样使用它：

```ts
type TopNavState = Pick<State, 'userId' 'pageTitle' 'recentFiles'>;
```

Pick 是一个通用类型的示例。继续使用消除代码重复的类比，使用 Pick 就相当于调用一个函数。Pick 接受两个类型 T 和 K，并返回第三个类型，这与函数可能接受两个值并返回第三个值的情况类似。第 6 章全部关于在类型级别编程，而第 50 条则探讨了通用类型作为“类型上的函数”的概念。

带有标记联合体时，还可能出现另一种重复情况。如果你只需要标记的类型呢？

```ts
interface SaveAction {
  type: 'save';
  // ...
}
interface LoadAction {
  type: 'load'; // ...
}
type Action = SaveAction | LoadAction;
type ActionType = 'save' | 'load'; // Repeated types!
```

你可以通过在 Action 联合中进行索引来定义 ActionType，从而避免重复自己：

type ActionType = Action\['type'\]; // ^? type ActionType = "save" | "load"

随着你向 Action 联合类型中添加更多的类型，ActionType 会自动包含它们。这种类型与使用 Pick 获取的类型不同，后者会给你一个带有 type 属性的接口：

```ts
type ActionRecord = Pick<Action, 'type'>;
// ^? type ActionRecord = { type: "save" | "load"; }
```

如果你正在定义一个可以初始化并在之后更新的类，那么更新方法的参数类型可以选地包含与构造函数相同的大部分参数：

```ts
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
interface OptionsUpdate {
  width?: number;
  height?: number;
  color?: string;
  label?: string;
}
class UIWidget {
  constructor(init: Options) {
    /* ... */
  }
  update(options: OptionsUpdate) {
    /* ... */
  }
}
```

你可以使用映射类型和 keyof 从 Options 构造 OptionsUpdate：

type OptionsUpdate = {\[k in keyof Options\]?: Options\[k\]};

keyof 可以接受一个类型并返回其键的联合类型：

```ts
type OptionsKeys = keyof Options;
// ^? type OptionsKeys = keyof Options
// (equivalent to "width" | "height" | "color" | "label")
```

映射类型 (\[k in keyof Options\]) 会遍历这些键并查找 Options 中对应的值类型。问号（?）使每个属性成为可选的。这种模式也非常常见，并且在标准库中作为 Partial 包含：

```ts
class UIWidget {
  constructor(init: Options) {
    /* ... */
  }
  update(options: Partial<Options>) {
    /* ... */
  }
}
```

映射类型还有一些其他的技巧。你可以在其中包含一个 as 子句来重命名键。这种用法有很多，其中一个用途是反转映射中的键和值：

```ts
interface ShortToLong q: 'search'; n: 'numberOfResults';
}
type LongToShort = { [k in keyof ShortToLong as ShortToLong[k]]: k };
// ^? type LongToShort = { search: "q"; numberOfResults: "n"; }
```

这种做法特别适用于模板字面量类型，它允许你在类型级别操作字面量字符串类型。这方面的内容详见第 54 项。

如果在映射类型中的索引条件形式为 K in keyof T 或其几种变体形式，那么 TypeScript 会将其视为“同构”映射类型。这意味着修饰符（如 readonly 和 ? 用于可选属性）和文档会被转移到新类型中：

```ts
interface Customer {
  /** How the customer would like to be addressed. */
  title?: string;
  /** Complete name as entered in the system. */
  readonly name: string;
}
type PickTitle = Pick<Customer, 'title'>;
// ^? type PickTitle = { title?: string; }
type PickName = Pick<Customer, 'name'>;
// ^? type PickName = { readonly name: string; }
type ManualName = { [K in 'name']: Customer[K] };
// ^? type ManualName = { name: string; }
```

在这种情况下，Pick 是一个同构映射类型，保留了可选和 readonly 修饰符。而 ManualName 映射类型没有使用 keyof 表达式，因此它不是同构的，不会转移修饰符。如果你使用同构类型之一定义一个值，你会发现文档也被转移过来了（图 2-13）。

const title: PickTitle = {

![](https://cdn-mineru.openxlab.org.cn/extract/f086402d-0ff8-45b5-86a7-21a6fc3bf945/f71a1350978b39385098d00e93acb9092377f38a354152d0bf3d0b9c01572cdc.jpg)图 2-13. TSDoc 文档已被复制到同态映射类型中。

同态映射类型另一个有趣的特性是，它们允许原始（非对象）类型未经修改地通过：

```ts
type PartialNumber = Partial<number>; // ^? type PartialNumber = number
```

这看起来有些奇怪，但在构建你自己的泛型类型时会很方便，如第 56 项所述。

当你定义映射类型时，考虑一下它们是否是同态的，以及你是否希望它们是同态的。

你可能也希望定义一个与某个值的结构相匹配的类型：

```ts
const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: '#00FF00',
  label: 'VGA',
};
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
```

你可以使用 \`typeof\` 来实现这一点：

```ts
type Options = typeof INIT_OPTIONS;
```

它有意模仿了 JavaScript 运行时的 \`typeof\` 操作符，但作用于 TypeScript 类型层面，并且更加精确。关于 \`typeof\` 的更多信息，请参见第 8 条。不过，从值中推导类型时要小心。通常来说，先定义类型，然后声明值可以赋给这些类型，这样做可以使你的类型更加明确，并且减少宽化带来的不确定性（参见第 20 条）。

\`typeof\` 的典型用例是当你有一个单一的值，希望它成为某个类型的来源（也许它是一种模式或 API 规范）。通过让值成为类型的来源，可以避免在定义类型时的重复工作。

同样，你可能希望为函数或方法推断出的返回值创建一个命名类型：

```ts
function getUserInfo(userId: string) {
  // ...
  return { userId, name, age, height, weight, favoriteColor };
}
// Return type inferred as { userId: string; name: string; age: number, ... }
```

直接这样做需要使用条件类型（参见第 52 项）。但如我们之前所见，标准库为常见的模式定义了通用类型。在这种情况下，ReturnType 通用类型正好满足你的需求：

请注意，ReturnType 操作的是 getUserInfo 函数的类型，而不是 getUserInfo 函数的值。就像 typeof 一样，使用此技术时要谨慎，不要混淆你的事实来源。

当你在类型中提取重复内容时，也不要过度。仅仅因为两个类型声明在源代码中共享相同的字符，并不意味着它们就是同一件事。例如，这两种类型共享一些共同的属性：

```ts
interface Product {
  id: number;
  name: string;
  priceDollars: number;
}
interface Customer {
  id: number;
  name: string;
  address: string;
}
```

但这不是一个明智的重构：

```ts
// Don't do this!
interface NamedAndIdentified {
  id: number;
  name: string;
}
interface Product extends NamedAndIdentified {
  priceDollars: number;
}
interface Customer extends NamedAndIdentified {
  address: string;
}
```

这是因为虽然 id 和 name 属性恰好具有相同的名字和类型，但它们并不指向相同的事物。将来你可能会将其中一个 id 改为字符串类型，但另一个不改。或者你可能会将客户名称拆分为 firstName 和 lastName，但这对产品来说没有意义。在这种情况下，提取出公共的基础接口可能会导致未来两种类型难以独立演化，这是一种过早的抽象。

一个不错的经验法则是，如果很难命名一个类型（或函数），那么它可能不是一个有用的抽象。在这种情况下，NamedAndIdentified 只描述了该类型的结构，而不是其含义。相比之下，之前提到的 Vertebrate 类型本身就有意义。记住，“重复是比错误抽象更便宜的。”2

在类型空间中，重复和复制粘贴编程与在值空间中一样糟糕。你用来避免类型空间中重复的构造可能不如用于程序逻辑的构造那么熟悉，但它们值得你去学习。不要重复自己！

### 注意事项

- DRY（不要重复自己）原则同样适用于类型，而不仅仅是逻辑。
- 尽量命名类型，而不是重复它们。使用 extends 来避免在接口中重复字段。
- 构建对 TypeScript 提供的工具的理解，以便在类型之间进行映射。这些工具包括 keyof、typeof、索引和映射类型。
- 泛型类型相当于类型中的函数。使用它们在类型之间进行映射，而不是重复类型级别的操作。
- 熟悉标准库中定义的泛型类型，如 Pick、Partial 和 ReturnType。
- 避免过度应用 DRY 原则：确保你共享的属性和类型确实是相同的东西。

## 第 16 条建议：优先使用更精确的替代方案而非索引签名

JavaScript 最好的特性之一是其方便的对象创建语法：

```ts
const rocket = { name: 'Falcon 9', variant: 'Block 5', thrust: '7,607 kN' };
```

JavaScript 中的对象将字符串（或符号）键映射到任何类型的价值。TypeScript 允许通过在类型上指定索引签名来表示这种灵活的映射：

```ts
type Rocket = { [property: string]: string };
const rocket: Rocket = {
  name: 'Falcon 9',
  variant: 'v1.0',
  thrust: '4,940 kN',
}; // OK
```

\[property: string\]: string 是索引签名。它指定了三件事：

_键的名称_ 这纯粹是为了文档说明，并未以任何方式被类型检查器使用。

_键的类型_

This 需要是 string | number | symbol（即 PropertyKey）的子类型。通常它是 string 或 string 的子类型，如字符串字面量的联合类型。number 类型的索引最好避免使用，如第 17 条所述。symbol 在应用代码中很少见。

_值的类型_

这可以是任何内容。

虽然这段代码可以类型检查，但它有几个缺点：

- 它允许使用任何键，包括错误的键。如果你把 Name 写成了 name，它仍然可以是一个有效的 Rocket 类型。
- 它不需要特定的键存在。{} 也是一个有效的 Rocket。
- 它不能为不同的键设置不同的类型。例如，我们可能希望 thrust 是一个数字而不是一个字符串。
- TypeScript 的语言服务无法帮助你处理这种类型的类型。当你输入 name: 时，没有自动补全功能，因为键可以是任何内容。

简而言之，索引签名并不十分精确。几乎总是有更好的替代方案。在这种情况下，Rocket 可以是一个接口：

```ts
interface Rocket {
  name: string;
  variant: string;
  thrust_kN: number;
}
const falconHeavy: Rocket = {
  name: 'Falcon Heavy',
  variant: 'v1',
  thrust_kN: 15200,
};
```

现在 thrust_kN 是一个数字，TypeScript 会检查所有必需的字段是否存在。TypeScript 提供的所有强大语言服务都可用：自动补全、跳转到定义和重命名。

你应该用索引签名做什么？历史上，索引签名是表示真正动态数据的最佳方式。例如，这些数据可能来自一个 CSV 文件，其中有一行表头，你想将数据行表示为列名到值的对象映射：

```ts
function parseCSV(input: string): { [columnName: string]: string }[] {
  const lines = input.split('\n');
  const [headerLine, ...rows] = lines;
  const headers = headerLine.split(',');
  return rows.map((rowStr) => {
    const row: { [columnName: string]: string } = {};
    rowStr.split(',').forEach((cell, i) => {
      row[headers[i]] = cell;
    });
    return row;
  });
}
```

在这种通用情况下，无法提前知道列名是什么，因此无法获得更精确的类型。如果 parseCSV 的使用者在特定上下文中对列有更多的了解，他们可以使用断言来获得更具体的类型：

```ts
interface ProductRow {
  productId: string;
  name: string;
  price: string;
}

declare let csvData: string;
const products = parseCSV(csvData) as unknown[] as ProductRow[];
```

当然，运行时的列可能并不符合你的预期。你可以通过将值类型改为 string|undefined 或设置 noUncheckedIndexedAccess 编译选项（参见第 48 条）来防范这种可能性。

但更好地处理动态数据的方法是使用 Map 类型，也称为关联数组。你可以这样实现 parseCSV：

```ts
function parseCSVMap(input: string): Map<string, string>[] {
  const lines = input.split('\n');
  const [headerLine, ...rows] = lines;
  const headers = headerLine.split(',');
  return rows.map((rowStr) => {
    const row = new Map<string, string>();
    rowStr.split(',').forEach((cell, i) => {
      row.set(headers[i], cell);
    });
    return row;
  });
}
```

现在，字段必须通过 get 方法访问，结果总是包含 undefined 的可能性：

```ts
const rockets = parseCSVMap(csvData);
const superHeavy = rockets[2];
const thrust_kN = superHeavy.get('thrust_kN'); // 74,50
// ^? const thrust_kN: string | undefined
```

如果你想从 Map 中获取对象类型，你需要编写一些解析代码：

```ts
function parseRocket(map: Map<string, string>): Rocket {
  const name = map.get('name');
  const variant = map.get('variant');
  const thrust_kN = Number(map.get('thrust_kN'));
  if (!name || !variant || isNaN(thrust_kN)) {
    throw new Error(`Invalid rocket: ${map}`);
  }
  return { name, variant, thrust_kN };
}
const rockets = parseCSVMap(csvData).map(parseRocket);
// ^? const rockets: Rocket[]
```

虽然这可能会显得繁琐，但它确实能确保你的数据实际具有你所期望的形状。这样可以在加载数据时就发现错误，而不是在稍后尝试使用数据时才发现。在 TypeScript 中，将宽泛类型（Map<string, string>）的数据验证转换为更具体类型（Rocket）的模式是常见的。第 74 条将探讨更多系统化的运行时类型验证方法。

此外，Map 还能绕过一些与原型链相关的著名问题。

如果你的类型具有有限的可能字段集，不要使用索引签名来建模。例如，如果你知道数据将包含 A、B、C、D 这样的键，但不知道会有多少个这样的键，你可以将类型建模为可选字段或联合类型：

```ts
interface Row1 {
  [column: string]: number;
} // too broad
interface Row2 {
  a: number;
  b?: number;
  c?: number;
  d?: number;
} // better
type Row3 =
  | { a: number }
  | { a: number; b: number }
  | { a: number; b: number; c: number }
  | { a: number; b: number; c: number; d: number }; // also better
```

最后一种形式是最精确的，但可能不太方便使用。第 29 条将更详细地讨论如何构建类型以排除无效状态。

如果使用索引签名的问题是字符串太宽泛，那么可以使用 Record。Record 是一种泛型类型，提供了更多在键类型上的灵活性。特别是，你可以传递字符串的子集：

```ts
type Vec3D = Record<'x' | 'y' | 'z', number>;
// ^? type Vec3D = {
// x: number;
// y: number;
// z: number;
// }
```

Record 是一个内置的映射类型（第 15 条）的包装器。

最后，你可以使用索引类型来禁用多余的属性检查（第 11 条）。例如，你可能在 ButtonProps 类型上定义了几种已知的属性，但仍希望允许它有其他任何属性：

```ts
declare function renderAButton(props: ButtonProps): void;
interface ButtonProps { title: string; onClick: () => void;
}
renderAButton({ title: 'Roll the dice', onClick: () => alert(1 + Math.floor(6 \* Math.random())), theme: 'Solarized',
// \~\~ Object literal may only specify known properties…
});
```

添加一个索引签名可以使这个错误消失：

```ts
interface ButtonProps {
  title: string;
  onClick: () => void;
  [otherProps: string]: unknown;
}
renderAButton({
  title: 'Roll the dice',
  onClick: () => alert(1 + Math.floor(20 * Math.random())),
  theme: 'Solarized', // ok
});
```

至关重要的是，标题和 onClick 仍然保持了与之前相同的类型。将数字作为标题传递会导致类型错误。

你还可以将这些额外的属性限制为匹配某种模式。例如，某些 Web 组件允许任意属性，但前提是这些属性必须以 "data-" 开头。你可以使用索引签名和模板字面量类型来模拟这种模式。第 54 项会向你展示如何操作。

总之，在你的数据类型中添加索引签名之前，请三思。是否有更精确的替代方案？你是否可以不用索引类型就使用接口？你是否可以使用 Map 或映射类型？无论如何，至少你可以限制键的类型吗？

### 注意事项

- 理解索引签名的缺点：就像任何其他特性一样，它们会侵蚀类型安全性并降低语言服务的价值。
- 尽可能使用更精确的类型而非索引签名：接口、Map、记录、映射类型或受限键空间的索引签名。

## 第 17 条：避免使用数值索引签名

JavaScript 是一种著名的古怪语言。其中一些最著名的怪癖涉及隐式类型转换：

> "0" == 0 true

这些通常可以通过使用===和!==而不是它们更具强制性的同类来避免。

JavaScript 的对象模型也有一些怪癖，而这些怪癖更为重要需要理解，因为其中一些在 TypeScript 的类型中有所体现

系统。你已经在第 10 项中看到了一个类似的怪癖，该部分讨论了对象包装类型。本项将讨论另一个。

什么是对象？在 JavaScript 中，对象是一个键值对的集合。键通常是字符串（从 ES2015 及以后版本开始，也可以是符号）。值可以是任何类型。

这比你在许多其他语言中找到的要更严格。JavaScript 没有像 Python 或 Java 中那样的“可哈希”对象的概念。如果你尝试使用一个更复杂的对象作为键，JavaScript 会通过调用其 \`toString\` 方法将其转换为字符串：

> Translation A

特别是，数字不能用作键。如果你尝试使用一个数字作为属性名，JavaScript 运行时会将其转换为字符串：

> Translation B

那么什么是数组呢？它们当然也是对象：

> Translation C

然而，使用数值索引它们也很常见：

> Translation D %%

这些被转换成字符串了吗？在所有奇怪的特性中，答案是“是的”。你还可以使用索引访问数组的元素。

字符串键：

> x\['1'\] 2

如果你使用 Object.keys 列出数组的键，会得到字符串返回：

> \> Object.keys(x) \[ '0', '1', '2' \]

TypeScript 通过允许数值键并区分这些键和字符串来模拟这一点。如果你深入研究 Array（第 6 项）的类型声明，你会在 lib.es5.d.ts 中找到这一点：

```ts
interface Array<T> {
  // ...
  [n: number]: T;
}
```

这纯粹是一个虚构的内容——字符串键在运行时被接受，因为 ECMAScript 标准规定必须接受字符串键，但这是一个很有帮助的虚构内容，可以捕捉错误：

```ts
const xs = [1, 2, 3];
const x0 = xs[0]; // OK
const x1 = xs['1']; // stringified numeric constants are also OK const inputEl = document.getElementsByTagName('input')[0];
const xN = xs[inputEl.value];
// Index expression is not of type 'number'.
```

在这种情况下，使用 inputEl.valueAsNumber 会更合适，并且可以解决类型错误。

虽然数字键的概念很有帮助，但重要的是要记住这只是个概念。就像 TypeScript 类型系统的所有方面一样，它在运行时会被擦除（Item 3）。这意味着像 Object.keys 这样的构造函数仍然会返回字符串：

```ts
const keys = Object.keys(xs); // ^? const keys: string[]
```

这里的模式是，数字索引签名意味着你通常需要输入一个数字，但你得到的是字符串。

如果这些听起来令人困惑，那是因为确实如此！一般来说，没有太多理由将 number 作为类型的索引签名。如果你想指定使用数字索引的内容，你可能应该使用数组或元组类型。将 number 作为索引类型可能会造成误解，认为数字属性在 JavaScript 中是真实存在的，无论是对你自己还是对你的代码的读者来说都是如此。

如果你因为数组类型有其他许多你可能不会用到的属性（来自其原型）而不愿意接受它，比如 push 和 concat，那么这是很好的——你正在从结构上思考！（如果你需要复习这一点，可以参考第 4 条建议。）如果你确实想要接受任意长度的元组或任何类似数组的构造，TypeScript 提供了 ArrayLike 类型供你使用：

```ts
function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
  if (i >= 0 && i < xs.length) {
    return xs[i];
  }
  throw new Error(`Attempt to access \${i} which is past end of array.`);
}
```

（TypeScript 还有一个 noUncheckedIndexedAccess 选项，你可以设置它以确保数组访问的安全性。参见第 48 项。）

ArrayLike 只包含 length 属性和数值索引签名。正如其名所示，这允许像 NodeList 这样的类似数组结构被传递进来。在极少数你需要这种情况时，你应该使用 ArrayLike 而不是普通数组。但请记住，键仍然是字符串！

```ts
const tupleLike: ArrayLike<string> = {
  '0': 'A',
  '1': 'B',
  length: 2,
}; // OK
```

如果你只需要一个可以迭代的对象，你可以使用 Iterable 类型，它允许你将生成器表达式传递给你的函数（请参阅第 30 条建议）。

JavaScript（以及 TypeScript）中的对象键要么是字符串，要么是符号。数字索引类型最好被视为为了使 Array 类型在 TypeScript 中使用起来方便而做出的一种妥协。但请记住，数字索引并不是真实的。在你自己的类型中尽量避免使用它们。

### 注意事项

- 请理解数组是对象，因此它们的键是字符串，而不是数字。使用 number 作为索引签名是一种纯粹的 TypeScript 构造，旨在帮助捕获错误。
- 尽量使用 Array、元组、ArrayLike 或 Iterable 类型，而不是在索引签名中自己使用 number。
