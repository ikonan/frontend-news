# 第五章 不稳定性和 any 类型

类型系统传统上是二元的：要么是一种语言具有完全静态的类型系统，要么是具有完全动态的类型系统。TypeScript 模糊了这条线，因为其类型系统是可选的且渐进的。你可以自由地为程序的部分添加类型，但不是全部。

这对于将现有的 JavaScript 代码库逐步迁移到 TypeScript 至关重要（第 10 章）。关键是 any 类型，它实际上禁用了代码部分类型的检查。它既强大又容易滥用。明智地使用 any 对于编写有效的 TypeScript 至关重要。本章将指导你如何限制 any 的缺点，同时保留其优点。

any 类型只是更普遍问题不稳定性的最极端例子：当符号的静态类型与其运行时类型不匹配时。即使你从代码中消除了所有 any，你仍然可能陷入稳定性陷阱。第 48 条提出了这些陷阱的一些，并展示了如何避免它们。

## 使用尽可能窄的作用域来处理任何类型

考虑以下代码：

```ts
declare function getPizza(): Pizza;
function eatSalad(salad: Salad) {
  /* ... */
}
function eatDinner() {
  const pizza = getPizza();
  eatSalad(pizza); //
  // Argument of type 'Pizza' is not assignable to parameter of type 'Salad'

  pizza.slice();
}
```

如果你知道调用 eatSalad 是安全的，最好的做法是调整你的类型，让 TypeScript 也能理解这一点。（帕尔玛干酪和柠檬的芝麻菜披萨有点像沙拉！）但如果出于任何原因，你不能这样做，你可以使用 any 强制 TypeScript 以两种方式接受这段代码：

```ts
function eatDinner1() {
  const pizza: any = getPizza();
  // don't do this
  eatSalad(pizza); // Ok
  pizza.slice(); // This call is unchecked!
}

function eatDinner2() {
  const pizza = getPizza();
  eatSalad(pizza as any); // his is preferable
  pizza.slice(); // this is safe
}
```

其中，第二种形式更可取。为什么？因为 any 类型的作用域仅限于函数参数的单个表达式。它对此参数或此行之外没有影响。当 eatSalad 调用之后的代码引用 pizza 时，它的类型仍然是 Pizza，并且仍然可以触发类型错误；而在第一个例子中，它的类型在整个生命周期内都是 any，直到它结束函数的作用域。这意味着 pizza.slice()调用完全不受检查。拼写错误或参数类型不正确将通过类型检查，但在运行时抛出异常。

也会使 eatSalad 接受任何类型变得很糟糕。虽然这会让 eatDinner 中的 pizza 保持 Pizza 类型，但它会阻止程序中所有对 eatSalad 的调用对此参数进行类型检查，而不仅仅是这次调用。

如果从 eatDinner 返回 pizza，风险会显著增加。看看会发生什么：

```ts
function eatDinner1() {
  const pizza: any = getPizza();
  eatSalad(pizza);
  pizza.slice();
  return pizza; // unsafe pizza!
}
function spiceItUp() {
  const pizza = eatDinner1();
  // ^? const pizza: any pizza.addRedPepperFlakes();
  // This call is also unchecked!
}
```

任何返回类型都是“传染性”的，它可以在代码库中传播。由于我们对 eatDinner1 的更改，any 类型已经悄然出现在 spiceItUp 中。在 eatDinner2 中，更窄范围的 any 不会发生这种情况。

这正是考虑包含显式返回类型注解的好理由，即使返回类型可以推断出来。它可以防止任何类型意外“逃脱”。您必须显式地写出 any。请参阅第 18 条了解更多关于注释返回类型的好处和坏处。标准库中有几个函数返回任何类型，特别是 JSON.parse。这些非常危险！第 71 条探讨了保护自己的方法。

我们在这里使用 any 来抑制我们认为不正确的错误。另一种方法是使用@ts-ignore 或@ts-expect-error：

```ts
function eatDinner1() {
  const pizza = getPizza();
  // @ts-ignore
  eatSalad(pizza);
  pizza.slice();
}

function eatDinner2() {
  const pizza = getPizza();
  // @ts-expect-error
  eatSalad(pizza);
  pizza.slice();
}
```

这些可以在下一行静默错误，同时保持披萨的类型不变。在这两种形式中，@ts-expect-error 更可取，因为如果错误后来消失了（比如 eatSalad 的签名发生了变化），TypeScript 会告诉你，你就可以移除这个指令。

因为它们明确地限制在一行，所以@ts-ignore 和@ts-expect-error 不会像 any 那样“传染”。尽管如此，尽量不要过度依赖这些指令：类型检查器通常有很好的理由来抱怨，如果下一行的错误变成了更严重的问题，你将阻止 TypeScript 通知你。如果同一行出现第二个错误，你将永远无法发现它。

你也可能遇到在更大的对象中只有一个属性出现类型错误的情况：

```ts
const config: Config = {
  a: 1,
  b: 2,
  c: {
    key: value, // \~\~\~ Property ... missing in type 'Bar' but required in type 'Foo'
  },
};
```

你可以通过将整个配置对象抛出为 any 来静默错误：

```ts
const config: Config = { a: 1, b: 2, c: { key: value } } as any; // Don't do this!
```

但这会带来副作用，禁用了其他属性（a 和 b）的类型检查。使用更窄范围的 any 可以限制损害范围：

```ts
const config: Config = {
  a: 1,
  b: 2, // These properties are still checked
  c: { key: value as any },
};
```

如果第一个例子是限制 any 的作用域在时间上，那么这是限制作用域在空间上。在两种情况下，目标都是相同的：如果你必须使用 any，尽可能减少其作用域以避免附带损害。

如果你采用 typescript-eslint 推荐的 recommended-type-checked 预设，你将启用一组规则，如 no-unsafe-assignment 和 no-unsafereturn，这些规则有助于突出显示 any 类型的传播。

### 要记住的事情

- 尽可能将任何类型的使用范围缩小，以避免在代码中丢失类型安全。
- 从不从一个函数中返回任何类型。这会导致调用该函数的代码类型安全无声地丢失。
- 在大型对象的单个属性上使用 any，而不是整个对象。

## 项目 44：优先选择更精确的“any”变体，而不是普通的“any”

“any”类型包含 JavaScript 中可以表示的所有值。这是一个庞大的领域！它不仅包括所有数字和字符串，还包括所有数组、对象、正则表达式、函数、类和 DOM 元素，更不用说 null 和 undefined 了。当你使用“any”类型时，请考虑你是否真的需要更具体的东西。传递一个正则表达式或函数是否可以接受？

通常答案是“不”，在这种情况下，你可能可以通过使用更具体的类型来保留一些类型安全：

```ts
function getLengthBad(array: any) {
  // don't do this!
  return array.length;
}
function getLength(array: any[]) {
  // this is better
  return array.length;
}
```

使用 any\[\]而不是 any 的后者在三个方面更好：

- 函数体内对 array.length 的引用进行了类型检查。
- 函数的返回类型推断为 number 而不是 any。
- 将对 getLength 的调用进行检查，以确保参数是一个数组：

```ts
getLengthBad(/123/); // No error, returns undefined
getLength(/123/);
//
// Argument of type 'RegExp' is not assignable to parameter of type 'any[]'.
getLengthBad(null); // No error, throws at runtime
getLength(null);
//
// Argument of type 'null' is not assignable to parameter of type 'any[]'.
```

如果你期望一个参数是一个数组数组，但不在乎其类型，可以使用 any[][].

如果你期望某种对象，但不知道值是什么，你可以使用`{[key: string]: any}`或 `Record<string, any>`：

```ts
function hasAKeyThatEndsWithZ(o: Record<string, any>) {
  for (const key in o) {
    if (key.endsWith("z")) {
      console.log(key, o[key]);
      return true;
    }
  }
  return false;
}
```

你也可以在这种情况下使用对象类型，它包括所有非原始类型。这略有不同，虽然你仍然可以枚举键，但不能访问它们的值：

```ts
function hasAKeyThatEndsWithZ(o: object) {
  for (const key in o) {
    if (key.endsWith("z")) {
      console.log(key, o[key]);
      // Element implicitly has an 'any' type
      // because type '{}' has no index signature
      return true;
    }
  }
  return false;
}
```

在 TypeScript 中迭代对象类型尤其棘手。第 60 项将详细介绍如何解决这个特定问题。

如果你期望函数类型，避免使用 any。这里你有几个选项，具体取决于你想要多具体：

```ts
type Fn0 = () => any; // any function callable with no params
type Fn1 = (arg: any) => any; // with one param
type FnN = (...args: any[]) => any;
// with any number of params
// same as "Function" type
```

所有这些都比“任何”更精确，因此更可取。注意最后一个例子中使用了 any\[\]作为剩余参数的类型：

```ts
const numArgsBad = (...args: any) => args.length; // ^? const numArgsBad: (...args: any) => any
const numArgsBetter = (...args: any[]) => args.length; // ^? const numArgsBetter: (...args: any[]) => number
```

注意不同的返回类型。剩余参数可能是最常见使用 any\[\]类型的情况。

如果你想得到一个数组，但不在乎元素类型，你可能可以使用 unknown\[\]代替 any\[\]。这是更安全的，因为它是更安全的。请参阅第 46 项了解更多关于 unknown 类型的信息。

### 要记住的事项

- 使用任何时，请考虑任何 JavaScript 值是否真正允许。
- 如果更精确的“any”形式（如 any[]或{[id: string]: any}或() => any）能更准确地描述你的数据，请优先使用。

## 项目 45：在类型良好的函数中隐藏不安全类型断言

在理想的世界里，你的函数具有你想要的精确类型签名，它们的实现（也在 TypeScript 中）通过类型检查，不包含任何类型断言或 any 类型，并且不会落入任何其他类型安全陷阱（项目 48）。幸运的是，对于你将要编写的多数函数来说，情况就是这样。但这是关于 any 和不安全性的章节，所以你不会对事情总是理想化感到惊讶。

如果您必须在安全的、无断言的函数实现和您想要的类型签名之间做出选择，请选择类型签名。这是您函数的公共 API，对您的代码和用户可见。函数的实现是隐藏在用户视线之外的细节。您的断言和任何类型都将隐藏在那里。拥有一个不安全（但经过良好测试）的实现，比采用让用户生活变得困难的类型签名要好得多。

为了了解这种情况可能如何出现，考虑以下获取山峰信息的代码：

```ts
interface MountainPeak {
  name: string;
  continent: string;
  elevationMeters: number;
  firstAscentYear: number;
}
async function checkedFetchJSON(url: string): Promise<unknown> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Unable to fetch! ${response.statusText}`);
  }
  return response.json();
}
export async function fetchPeak(peakId: string): Promise<MountainPeak> {
  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`);
  // \~ Type 'unknown' is not assignable to type 'MountainPeak'.
}
```

checkedFetchJSON 包装器在这里提供了两项服务。首先，它检查 fetch 是否成功，如果没有成功则抛出（从而拒绝 Promise）。其次，它给 JSON 响应赋予一个未知的类型（第 46 项），这比默认得到的 any 类型更安全。

不幸的是，这里有一个类型错误，因为 unknown 不能赋值给 MountainPeak。如果您想在 fetchPeak 实现中避免类型断言或任何类型，您必须更改返回类型以匹配：

```ts
export async function fetchPeak(peakId: string): Promise<unknown> {
  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`); // Ok
}
```

这通过了类型检查，并且不包含任何不安全的断言（很好！），但这代价是巨大的。现在 fetchPeak 函数的使用变得极其困难：

```ts
const sevenPeaks = [
  "aconcagua",
  "denali",
  "elbrus",
  "everest",
  "kilimanjaro",
  "vinson",
  "wilhelm",
];
async function getPeaksByHeight(): Promise<MountainPeak[]> {
  const peaks = await Promise.all(sevenPeaks.map(fetchPeak));
  return peaks.toSorted(
    // \~\~\~ Type 'unknown' is not assignable to type 'MountainPeak'.
    (a, b) => b.elevationMeters - a.elevationMeters // \~ 'b' and 'a' are of type 'unknown'
  );
}
```

任何调用它的代码很可能需要使用类型断言：

```ts
async function getPeaksByDate(): Promise<MountainPeak[]> {
  const peaks = (await Promise.all(
    sevenPeaks.map(fetchPeak)
  )) as MountainPeak[];
  return peaks.toSorted((a, b) => b.firstAscentYear - a.firstAscentYear);
}
```

这将在你每次调用 fetchPeak 时在你的代码中散布类型断言。这是重复的、繁琐的，并且引入了你在不同地方断言不同类型的可能性。

而不是改变 fetchPeak 的返回类型来取悦类型检查器，更好的方法是在函数体中添加一个断言，同时保持类型签名不变：

```ts
export async function fetchPeak(peakId: string): Promise<MountainPeak> {
  return checkedFetchJSON(
    `/api/mountain-peaks/${peakId}`
  ) as Promise<MountainPeak>;
}
```

将类型断言隐藏在函数实现中，调用代码可以干净地编写，而不需要了解我们的不安全秘密：

```ts
async function getPeaksByContinent(): Promise<MountainPeak[]> {
  const peaks = await Promise.all(sevenPeaks.map(fetchPeak)); // no assertion!
  return peaks.toSorted((a, b) => a.continent.localeCompare(b.continent));
}
```

通过局部化类型断言，我们还使它更容易提高其安全性。这里有一个至少检查响应形状的版本：

```ts
export async function fetchPeak(peakId: string): Promise<MountainPeak> {
  const maybePeak = checkedFetchJSON(`/api/mountain-peaks/${peakId}`);
  if (
    !maybePeak ||
    typeof maybePeak !== "object" ||
    !("firstAscentYear" in maybePeak)
  ) {
    throw new Error(`Invalid mountain peak: ${JSON.stringify(maybePeak)}`);
  }
  return checkedFetchJSON(
    `/api/mountain-peaks/${peakId}`
  ) as Promise<MountainPeak>;
}
```

你不太可能在每个调用点都进行这种形状检查，但使用一个地方的类型断言来做这件事很容易。（如果你发现自己经常编写这种验证代码，第 74 条介绍了一些更系统的运行时验证 TypeScript 类型的方法。所有这些方法都将类型断言隐藏在良好类型的函数中！）

隐藏类型断言的另一种方法是提供一个函数的单个重载：

```ts
export async function fetchPeak(peakId: string): Promise<MountainPeak>;
export async function fetchPeak(peakId: string): Promise<unknown> {
  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`); // OK
}
const denali = fetchPeak("denali");
// ^? const denali: Promise<MountainPeak>
```

在这种情况下，重载向函数的调用者呈现了与实现中使用的不同类型签名。这里有一些安全性：TypeScript 将检查这两个签名是否兼容。但这与类型断言并没有本质区别，你仍然应该进行某种数据验证。

你可能也会发现自己被迫使用类型断言，因为 TypeScript 的类型检查器无法跟随你的代码。例如，这个函数检查两个对象是否浅等于彼此：

```ts
function shallowObjectEqual(a: object, b: object): boolean {
  for (const [k, aVal] of Object.entries(a)) {
    if (!(k in b) || aVal !== b[k]) {
      // \~ Element implicitly has an 'any' type
      // because type '{}' has no index signature
      return false;
    }
  }
  return Object.keys(a).length === Object.keys(b).length;
}
```

看起来有点令人惊讶，TypeScript 对 b[k] 访问提出了抱怨，尽管你刚刚检查了 b 中的 k 是真的。但是它确实这样做了，所以你需要求助于 @ts-expect-error 或任何类型。

这不是修复类型错误的正确方法：

```ts
function shallowObjectEqualBad(a: object, b: any): boolean {
  for (const [k, aVal] of Object.entries(a)) {
    if (!(k in b) || aVal !== b[k]) {
      // Ok
      return false;
    }
  }
  return Object.keys(a).length === Object.keys(b).length;
}
```

通过将 b 的类型更改为 any，我们允许在运行时崩溃的代码：

```ts
shallowObjectEqual({ x: 1 }, null); // Type 'null' is not assignable to type 'object'.
shallowObjectEqualBad({ x: 1 }, null); // ok, throws at runtime
```

### 最好将 any 类型隐藏在函数实现中：

```ts
function shallowObjectEqualGood(a: object, b: object): boolean {
  for (const [k, aVal] of Object.entries(a)) {
    if (!(k in b) || aVal !== (b as any)[k]) {
      // `(b as any)[k]` is OK because we've just checked `k in b`
      return false;
    }
  }
  return Object.keys(a).length === Object.keys(b).length;
}
```

这种 any 类型是窄范围的（项目 43），不影响函数的类型签名，甚至还包括一个解释为什么它是有效的注释。这是使用 any 类型和一个类型断言的良好示例。您的代码是正确的，类型签名是清晰的，并且您的用户不会察觉到这一点。

当然，您应该对所有代码进行单元测试，但使用类型断言时尤其如此。既然您已经告诉 TypeScript 相信您，那么一切正常，证明的责任在于您来证明。解释为什么类型断言是有效的注释很有帮助，但彻底的测试是证明正确性的更好方式。

### 要记住的事情

- 有时使用类型断言和 any 类型是必要的或方便的。当你需要使用它们时，请将它们隐藏在具有正确签名的函数中。
- 不要为了修复实现中的类型错误而妥协函数的类型签名。
- 确保解释你的类型断言为什么是有效的，并彻底测试你的代码。

## 使用 unknown 而不是 any 来表示未知类型的值

假设你想编写一个 YAML 解析器（YAML 可以表示与 JSON 相同的值集，但允许 JSON 的语法子集）。你的 parseYAML 方法的返回类型应该是什么？像 JSON.parse 一样返回 any 类型可能很有吸引力：

```ts
function parseYAML(yaml: string): any {
  // ...
}
```

但这与 Item 43 的建议相矛盾，即避免“传染性”的 any 类型，特别是不要从函数中返回它们。（Item 71 将探讨如何“修复” JSON.parse，使其不返回 any。）理想情况下，你希望用户立即将结果分配给另一个类型：

```ts
interface Book {
  name: string;
  author: string;
}
const book: Book = parseYAML(`
name: Wuthering Heights 
author: Emily Brontë
`);
```

然而，如果没有类型注解，book 变量将默默地获得 any 类型，从而在它被使用的地方阻止类型检查：

```ts
const book = parseYAML(`name: Jane Eyre author: Charlotte Brontë  `);
console.log(book.title); // No error, logs "undefined" at runtime
book("read"); // No error, throws "book is not a function" at runtime
```

一个更安全的替代方案是让 parseYAML 返回未知类型：

```ts
function safeParseYAML(yaml: string): unknown {
  return parseYAML(yaml);
}
const book = safeParseYAML(
  `name: The Tenant of Wildfell Hall author: Anne Brontë  `
);
console.log(book.title);
// 'book' is of type 'unknown'
book("read");
// Error: 'book' is of type 'unknown'
```

要理解未知类型，考虑任何类型在赋值方面的意义很有帮助。任何类型的强大和危险之处在于两个属性：

- 所有类型都可以赋值给 any 类型。
- any 类型可以赋值给所有其他类型。1

如果我们“将类型视为值的集合”（第 7 项），第一个属性意味着任何是所有其他类型的超类型，而第二个属性意味着它是子类型。这很奇怪！这意味着任何不适合类型系统，因为一个集合不能同时是所有其他集合的子集和超集。这是 any 的力量的来源，但也是它有问题的原因。由于类型检查器是基于集合的，使用 any 实际上禁用了它。

unknown 类型是 any 的替代品，它适合类型系统。它具有第一个属性（任何类型都可以赋值给 unknown），但没有第二个属性（unknown 只能赋值给 unknown，当然，还有 any）。它被称为“顶层”类型，因为它位于类型层次结构的顶部。never 类型则相反：它具有第二个属性（可以赋值给任何其他类型），但没有第一个属性（没有其他类型可以赋值给 never）。它被称为“底层”类型。

尝试访问未知类型的值上的属性是一个错误。尝试调用它或对其进行算术运算也是错误。对未知类型几乎无法进行任何操作，这正是其目的所在。关于未知类型的错误会更加合理。由于未知类型不能赋值给其他类型，你需要进行类型断言。但这也是合适的：我们确实比 TypeScript 更了解结果的类型。

```ts
const book = safeParseYAML(`name: Villette author: Charlotte Brontë  `) as Book;
console.log(book.title);
// Property 'title' does not exist on type 'Book'
book("read");
// Error: This expression is not callable
```

这些错误更加合理。由于未知类型不能赋值给其他类型，你需要进行类型断言。但这也是合适的：我们确实比 TypeScript 更了解结果的类型。

当你知道将会有一个值，但你不知道或不在乎它的类型时，未知类型是合适的。parseYAML 的结果就是一个例子，但还有其他情况。例如，在 GeoJSON 规范中，特征的 properties 属性是一个包含任何可序列化 JSON 的集合。因此，未知类型是合适的：

```ts
interface Feature {
  id?: string | number;
  geometry: Geometry;
  properties: unknown;
}
```

如果你编写一个函数来检查数组是否有少于 10 个元素，你并不关心元素的类型。因此，未知类型在这里也是合适的：

```ts
function isSmallArray(arr: readonly unknown[]): boolean {
  return arr.length < 10;
}
```

如你所见，你可以通过类型断言从未知类型获得更具体的类型。但这并非唯一的方法。你也可以使用 instanceof 检查：

```ts
function processValue(value: unknown) {
  if (value instanceof Date) {
    value; // ^? (parameter) value: Date
  }
}
```

你还可以使用用户定义的类型守卫：

```ts
function isBook(value: unknown): value is Book {
  return (
    typeof value === "object" &&
    value !== null &&
    "name" in value &&
    "author" in value
  );
}
function processValue(value: unknown) {
  if (isBook(value)) {
    value; // ^? (parameter) value: Book
  }
}
```

TypeScript 需要大量的证明来缩小未知类型：为了避免 in 检查时的错误，你首先必须证明 val 是一个对象类型，并且它不是 null（因为 typeof null === 'object'）。与任何用户定义的类型守卫一样，请记住，它并不比类型断言更安全。没有任何东西可以检查你是否正确实现了守卫，或者是否将其与类型保持同步。（第 74 条讨论了解决这个难题的方法。）

有时你会看到使用类型参数而不是 unknown。你可以这样声明 safeParseYAML 函数：

```ts
function safeParseYAML<T>(yaml: string): T {
  return parseYAML(yaml);
}
```

这通常被认为在 TypeScript 中是坏风格。它与类型断言看起来不同，但并不更安全，功能上也是相同的。最好是直接返回 unknown 并强制用户使用断言，或者缩小到他们想要的类型。这是对第 51 条中提到的不必要的泛型使用的一个常见例子。

unknown 也可以在“双重断言”中使用代替 any。

```ts
declare const foo: Foo;
let barAny = foo as any as Bar;
let barUnk = foo as unknown as Bar;
```

这些在功能上是等效的，但 unknown 版本可以防止你和你同事在看到 as any 时产生的直观反应。

最后要注意的是，你可能会看到使用 object 或 {} 的代码，与这一条中描述的 unknown 的用法类似。它们也是宽泛的类型，但比 unknown 略窄：

- {} 类型包含除了 null 和 undefined 以外的所有值。
- 对象类型（大写“O”）几乎与 {} 相同。字符串、数字、布尔值和其他原始类型都可以赋值给对象。
- 对象类型（小写“o”）包含所有非原始类型。这并不包括 true 或 12 或 "foo"，但包括对象、数组和函数。

真正想要允许除了 null 和 undefined 以外的任何值的情况非常罕见，因此 unknown 通常比 {} 或 Object 更可取。

### 要记住的事情

- 未知类型是一种类型安全的 any 替代品。当你知道你有一个值，但不知道或不在乎它的类型时，请使用它。
- 使用未知来强制你的用户使用类型断言或其他形式的缩小。
- 避免使用仅返回类型参数，这可能会产生错误的安全感。
- 理解{}、对象和未知的区别。

## 项目 47：优先选择类型安全的猴子补丁方法。

JavaScript 最著名的特性之一是其对象和类是“开放”的，这意味着你可以向它们添加任意属性。这有时被用来在网页上创建全局变量，通过将值赋给 window 或 document：

```ts
window.monkey = "Tamarin";
document.monkey = "Howler";
```

或者将数据附加到 DOM 元素上：

```ts
const el = document.getElementById("colobus");
el.home = "tree";
```

在运行时向内置对象添加属性称为“猴子补丁”，这在使用 jQuery 或 D3 的代码中尤为常见。

你甚至可以将属性附加到内置对象的原型上，有时会有令人惊讶的结果：

> RegExp.prototype.monkey = '卷尾猴'
> 卷尾猴
> /123/.monkey
> 猴子

这些方法通常不是好的设计。当你将数据附加到 window 或 DOM 节点时，你实际上是在将其变成全局变量。这使得你很容易在不经意间在你的程序的不同部分之间引入依赖关系，并且意味着每次调用函数时你都必须考虑副作用。在严格模式之外，JavaScript 非常容易引入全局变量：只需从赋值中省略 let、var 或 const 即可。

添加 TypeScript 引入了另一个问题：虽然类型检查器知道 Document 和 HTMLElement 的内置属性，但它当然不知道你添加的属性：

```ts
document.monkey = "Tamarin"; // Property 'monkey' does not exist on type 'Document'
```

最直接修复这个错误的方法是使用任何断言：

```ts
(document as any).monkey = "Tamarin"; // OK
```

这满足了类型检查器，但正如你所预料的那样，它有一些缺点。使用任何断言都会失去类型安全性和语言服务：

```ts
(document as any).monky = "Tamarin"; // also OK, mis pel ed
(document as any).monkey = /Tamarin/; // also OK, wrong type
```

最佳解决方案是将你的数据从 window、document 或 DOM 中移除。但如果你不能（可能你正在使用需要它的库，或者你正在迁移 JavaScript 应用程序），那么猴子补丁就是你的环境的一部分（第 76 项），你应该使用 TypeScript 来模拟它。没有完美的方法来做这件事，但任何断言为安全性和开发者体验设定了一个低标准，而且有方法可以做得更好。

假设你正在构建一个 Web 应用程序，并且你有一个包含当前登录用户信息的对象。你通过 API 在页面加载时获取它，并将其存储为全局变量，以便在代码中方便地访问：

```ts
interface User {
  name: string;
}
document.addEventListener("DOMContentLoaded", async () => {
  const response = await fetch("/api/users/current-user");
  const user = (await response.json()) as User;
  window.user = user;
  // \~\~ Property 'user' does not exist
  // on type 'Window & typeof globalThis'.
});
// ... elsewhere .
export function greetUser() {
  alert(`Hello ${window.user.name}!`);
  // \~\~\~ Property 'user' does not exist on type Window...
}
```

TypeScript 类型错误产生是因为 TypeScript 不知道我们对全局对象的修补。而不是写(window as any)，一个选择是使用增强（接口的特别能力之一）：

```ts
declare global {
  interface Window {
    /** The currently logged-in user */
    user: User;
  }
}
```

这告诉 TypeScript，Window 有一个它从内置 DOM 类型中不知道的另一个属性。增强到位后，我们的代码通过了类型检查：

```ts
document.addEventListener("DOMContentLoaded", async () => {
  const response = await fetch("/api/users/current-user");
  const user = (await response.json()) as User;
  window.user = user; // OK
});
// ... elsewhere
export function greetUser() {
  alert(`Hello ${window.user.name}!`); // OK
}
```

这在几个方面优于使用 any：

- 你获得了类型安全。类型检查器将标记拼写错误或错误类型的赋值。
- 您可以将文档附加到属性（项目 68）上。
- 您可以在属性上获得自动完成和其他语言服务。
- 有关于猴子补丁的详细记录。

增强方法有几个问题。在（例如用户）全局变量在您的应用程序运行时设置的情况下，在发生后无法引入增强。这掩盖了我们代码中的竞争条件。如果我们调用 greetUser()之前 window.user 未设置，会发生什么？

为了避免此类问题，您可能想在全局中包含未定义的可能性。这将迫使您处理用户在任何地方都可能不可用的可能性：

```ts
declare global {
  interface Window {
    /** The currently logged-in user */
    user: User | undefined;
  }
}
//
export function greetUser() {
  alert(`Hello ${window.user.name}!`); // 'window.user' is possibly 'undefined'.
}
```

这里在正确性和便利性之间有一个权衡。

如果您的服务基础设施允许，针对这种情况的另一个解决方案是将用户变量内联到页面的 HTML 中：

```ts
<script type="text/javascript"> window.user = { name: 'Bill Withers' }; </script>
<script src="your-code.js"></script>
```

这样，您就可以安全地移除未定义的可能性，因为用户在您的代码运行之前已被无条件设置，并且不存在竞争条件。

增强带来的另一个问题是，正如声明全局所暗示的，它会影响全局。您无法将其隐藏在代码的其他部分或库中。如果您的应用程序包含多个页面，而用户只存在于其中一些页面，全局增强将无法准确地进行建模。

一种不会污染全局作用域的替代方法是使用更窄的类型断言。我们不必使用（window as any），而是可以定义另一个具有我们添加的属性的类型：

```ts
type MyWindow = typeof window & {
  /** The currently logged-in user */
  user: User | undefined;
};
document.addEventListener("DOMContentLoaded", async () => {
  const response = await fetch("/api/users/current-user");
  const user = (await response.json()) as User;
  (window as MyWindow).user = user; // OK
});
//
export function greetUser() {
  alert(`Hello ${(window as MyWindow).user.name}!`); // Object is possibly 'undefined'.
}
```

TypeScript 对类型断言持开放态度，因为 Window 和 MyWindow 具有相同的属性（项目 9）。您在赋值时可以获得类型安全。作用域问题也更容易管理：没有修改 Window 类型，只是引入了一个新的类型（只有当您导入它时才在作用域内）。

缺点是每次您引用猴子补丁属性时，都必须编写断言（或引入新变量）。您可能还想通过使用 linter 规则来强制执行不允许使用（window as any）。

但你可以把这当作鼓励你重构为更结构化的东西。猴子补丁不应该太容易！

### 要记住的事情

- 倾向于使用结构化代码，而不是将数据存储在全局变量或 DOM 上。
- 如果必须在内置类型上存储数据，请使用一种类型安全的方案（增强或断言自定义接口）。
- 理解增强的作用域问题。如果运行时可能为未定义，请包含 undefined。

## 项目 48：避免安全性陷阱

在互联网上闲逛，你会听到人们对 TypeScript“不安全”的抱怨，认为这使其成为语言选择的一个糟糕选择。本条目将解释这意味着什么，并带您了解 TypeScript 中常见的非安全性来源。请放心，TypeScript 是一种非常好的语言，永远不要听信互联网上的人！

一种语言被称为“安全”，如果每个符号的静态类型都保证与其运行时值兼容。使用第 7 条目中的术语，这意味着每个符号的运行时值都保持在那个符号的静态类型域内。

这里是一个声音类型的例子：

```ts
const x = Math.random(); // ^? const x: number
```

TypeScript 推断出 x 的静态类型为 number，这是合理的：无论 Math.random()在运行时返回什么值，它都将是一个数字。这并不意味着 x 在运行时可以是任何数字：一个更精确的类型应该是半开区间\[0, 1)，但 TypeScript 没有表达这种类型的方法。number 已经足够好了。合理性更多关乎准确性而不是精确性。

这里是一个 TypeScript 中不合理的例子：

```ts
const xs = [0, 1, 2]; // ^? const xs: number[]
const x = xs[3]; // ^? const x: number
```

x 的静态类型被推断为 number，但在运行时其值为 undefined，这不是一个数字。所以这是不合理的，可能会导致运行时问题，例如，如果你尝试在 x 上调用一个方法：

```ts
console.log(x.toFixed(1));
```

没有类型错误，但当你运行此代码时，它将抛出错误：console.log(x.toFixed(1));

TypeError: 无法读取未定义的属性（读取 toFixed）

不稳定的类型容易导致运行时错误，因此稳定的类型系统通常被认为是编程语言的一个理想属性。

然而，稳定性是有代价的。对于不那么表现力的类型系统来说，实现稳定性更容易。例如，如果 TypeScript 不支持泛型类型，那么它将消除你稍后将要读到的许多不稳定性的来源。但泛型类型是有用的！这种假设版本的 TypeScript 将更难模拟 JavaScript 模式，并且会捕获更少的错误。

换句话说，在类型系统的表现力、其正确性和便利性之间有一个权衡。TypeScript 允许你在这一谱系中选择你想要的位置：通过启用 strictNullChecks（项目 2），你接受一些不便（需要注释空类型和执行空检查）以换取更高的表现力。

如我们之前所看到的，TypeScript 整体上明确不是正确的。事实上，正确性并不是 TypeScript 的设计目标。相反，它更注重便利性和与现有 JavaScript 库协同工作的能力。

然而，不正确性可能导致崩溃、错误甚至数据损坏，你应该尽量避免。未检查的数组访问是一个众所周知的正确性陷阱，但在 TypeScript 中还有许多其他陷阱。本条目将探讨 TypeScript 中一些不正确性的来源，并展示如何重构你的代码来避免它们。

### any

如果你“在上面放一个任何”，那么任何事都可以。静态类型可能与实际运行时类型没有关系：

```ts
function logNumber(x: number) {
  console.log(x.toFixed(1));
  // s a string at runtime
  // ^? (parameter) x: number
}
const num: any = "forty two";
logNumber(num); // no error
```

这里没有类型错误，但这段代码在运行时会抛出异常。

解决方案很简单：限制你使用 any 的范围，或者最好根本不使用它！本章提供了很多关于如何减轻和避免 any 带来的静态类型灾难的建议，重点是要限制 any 的作用域，并在可能的情况下使用 unknown 作为更安全的替代品。对于像 JSON.parse 这样的内置函数，它们返回 any 类型，第 71 项展示了如何使用声明合并来获得更安全的替代品。

### 类型断言

任何的轻微不那么冒犯性的表亲就是“类型断言”。我们已经在第 9 项中讨论过这个话题，但这里再回顾一下它的样子：

```ts
function logNumber(x: number) {
  console.log(x.toFixed(1));
}
const hour = new Date().getHours() || null;
// ^? const hour: number | null

logNumber(hour);
// Type 'null' is not assignable to type 'number'.
logNumber(hour as number);
// type checks, but might blow up at runtime
```

最后那行的 as number 就是类型断言，它使得错误消失。

你能对此做些什么？你可以用条件语句（if 语句或三元运算符）来替换许多断言：

```ts
if (hour !== null) {
  logNumber(hour); // Ok // ^? const hour: number
}
```

在 if 块中，基于条件，hour 的静态类型被缩小，因此不需要类型断言（更多关于缩小的内容请参阅第 22 项）。

类型断言通常出现在输入验证的上下文中。采用一种系统化的方法来保持你的 TypeScript 类型与你的运行时验证逻辑同步是个好主意。第 74 项将为你介绍你的选项。

### 对象和数组查找

即使在严格模式下，TypeScript 也不会对数组查找进行任何类型的边界检查。正如我们在本项的介绍中所看到的，这可能导致不稳定性以及运行时错误。

当你通过索引类型引用对象的属性时，同样也可能发生这种情况：

```ts
type IdToName = { [id: string]: string };
const ids: IdToName = { "007": "James Bond" };
const agent = ids["008"]; // undefined at runtime.
// ^? const agent: string
```

TypeScript 允许这种代码的原因是它非常常见，而且很难证明任何特定的索引/数组访问是否有效。如果您想让 TypeScript 尝试，可以开启 noUncheckedIndexedAccess 选项。如果您开启它，它会在介绍中的示例中找到错误，但也会标记出完全有效的代码：

```ts
const xs = [1, 2, 3];
alert(xs[3].toFixed(1));
// invalid code
// Object is possibly 'undefined'.
alert(xs[2].toFixed(1)); // valid code // Object is possibly 'undefined'.
```

这个选项将您带到了一个不同的“安全性”与“便利性”的谱系：TypeScript 能够捕获更多的错误，但因为它也会标记出不是错误的代码，所以使用起来不那么方便。noUncheckedIndexedAccess 至少足够聪明，能够理解一些常见的数组结构：

```ts
const xs = [1, 2, 3];
for (const x of xs) {
  console.log(x.toFixed(1)); // OK
}
const squares = xs.map((x) => x * x); // also OK
```

如果您担心对特定数组或对象的访问不安全，可以显式地将 undefined 添加到它们的值类型中：

```ts
const xs: (number | undefined)[] = [1, 2, 3];
alert(xs[3].toFixed(1));
// \~ Object is possibly 'undefined'.
type IdToName = { [id: string]: string | undefined };
const ids: IdToName = { "007": "James Bond" };
const agent = ids["008"];
// ^? const agent: string | undefined
alert(agent.toUpperCase());
// 'agent' is possibly 'undefined'.
```

与 noUncheckedIndexedAccess 相比，这种方法的优点是可以限制作用域（以及可能出现的误报）。缺点是它缺乏标记的智能：使用这种方法，for-of 循环会给出错误。它还引入了将 undefined 推送到数组中的可能性。

通常，你可以重构代码以减少这类查找的需求。与其传递索引或键给函数，不如直接操作它们所引用的对象。

### 不准确的类型定义

JavaScript 库的类型声明就像一个巨大的类型断言：它们声称可以静态地模拟库的运行时行为，但没有任何东西可以保证这一点。（除非，这个库是用 TypeScript 编写的，声明是由 tsc 生成的，并且库没有不合理的类型！）

由于这类错误一旦被指出就往往会得到修复，尤其是在 DefinitelyTyped (@types) 的声明中，所以很难在这里展示一个当前的例子。但一个著名的例子是 @types/react 中的 React.FC 定义，它让 UI 组件接受子组件，尽管这在逻辑上并不合理。

如何解决这个问题？最好的办法是修复这个 bug！对于 DefinitelyTyped 上的类型，这个处理时间通常是一周或更少。如果这不是一个选项，你可以通过增强或在最坏的情况下使用类型断言来绕过一些问题。

还值得注意的是，一些函数的类型很难静态建模。以 String.prototype.replace 的参数列表为例，它可能让你感到困惑：

```ts
"foo".replace(/f(.)/, (fullMatch, group1, offset, fullString, namedGroups) => {
  console.log(fullMatch); // fo"
  console.log(group1); // o"
  console.log(offset); // 0

  console.log(fullString); // foo"
  console.log(namedGroups); // undefined
  return fullMatch;
});
```

如果你感兴趣的是偏移量参数，它的位置将取决于你的正则表达式中的捕获组（括号表达式）的数量。TypeScript 没有正则字面量类型的概念，所以无法静态地确定捕获组的数量。因此，回调参数被赋予 any 类型。

此外，还有一些函数由于历史原因类型不正确，例如 Object.assign。如果你因此遇到麻烦，请参考第 71 项解决方案。

类型声明不仅描述了 JavaScript 库，还描述了你的代码运行的环境：预期的 JavaScript 运行时和其他全局环境。第 76 项详细说明了创建准确环境模型的重要性。

### 类层次结构中的二向异性

函数类型的可赋值性思考起来比较棘手。对于返回类型和参数类型，它们的工作方式略有不同。对于返回类型，可赋值性与其他类型完全相同：

```ts
declare function f(): number | string;
const f1: () => number | string | boolean = f; // OK
const f2: () => number = f;
// \~\~ Type '() => string | number' is not assignable to type '() => number'.
// Type 'string | number' is not assignable to type 'number'.
```

这是有道理的：如果你调用一个期望返回数字但可能返回字符串的函数，那么就会出现麻烦。我们说函数在返回类型上是协变的。

参数类型走的是相反的方向：

```ts
declare function f(x: number | string): void;
const f1: (x: number | string | boolean) => void = f;
//
// Type 'string | number | boolean' is not assignable to type 'string | number'.
const f2: (x: number) => void = f; // OK
```

这也很有道理：你不应该能够调用一个期望接收数字或字符串的函数，而传入一个布尔值。函数在参数类型上是逆变。

现在我们来看看将这个原则应用到类上会发生什么：

```ts
class Parent {
  foo(x: number | string) {}
  bar(x: number) {}
}
class Child extends Parent {
  foo(x: number) {} // OK
  bar(x: number | string) {} // OK
}
```

回想一下第 7 条规则，\`extends\` 关键字在类或接口上的使用可以读作“子类型”。但根据我们刚刚学到的函数可赋值性原则，Child 类中的两个方法中肯定有一个会出错。由于函数在参数类型上是逆变，Child 类的 \`foo\` 方法不应该能够赋值给 Parent 类的 \`foo\` 方法。

你可以将这种不稳定性适应为未检测到的异常：

```ts
class FooChild extends Parent {
  foo(x: number) {
    console.log(x.toFixed());
  }
}
const p: Parent = new FooChild();
p.foo("string"); // No type error, crashes at runtime
```

TypeScript 将类上的模型方法视为二变异性：如果父方法或子方法可赋值给对方，则有效。从历史上看，所有函数赋值都是这样建模的。但是，随着 2017 年 TypeScript 2.6 中引入的 strictFunctionTypes，独立的函数类型被更准确地处理。

strictFunctionTypes，它是在 2017 年推出的 TypeScript 2.6 中引入的，它将独立的函数类型处理得更准确。

实际上这意味着当你从类继承时，你需要格外小心地获取方法签名。通常，子类应该有与父类完全相同的方法签名。但如果随着时间的推移更改了父类的签名，并期望为所有子实现获取类型错误，它们可能会变得不一致。请注意这一点！当你在类层次结构中更改方法签名时，请检查任何父类或子类中的相同方法。

### TypeScript 对对象和数组的不准确变体模型

这个例子在网上已经被广泛讨论。这里有一个标准的例子来说明它是如何工作的：

```ts
function addFoxOrHen(animals: Animal[]) {
  animals.push(Math.random() > 0.5 ? new Fox() : new Hen());
}
const henhouse: Hen[] = [new Hen()];
addFoxOrHen(henhouse); // oh no, a fox in the henhouse!
```

问题是，只有在不修改数组的情况下，将 Hen\[\] 赋值给 Animal\[\] 才是安全的。换句话说，只有 readonly Hen\[\] 才可以被赋值给 readonly Animal\[\]。然而，TypeScript 并非一直都有 readonly，在早期它选择允许这种代码。也许在将来会有一个新的严格选项来处理这种不安全来源。

你能做什么？最好的办法是不修改函数参数，你可以使用 readonly 注解来强制执行（第 14 条）：

```ts
function addFoxOrHen(animals: readonly Animal[]) {
  animals.push(Math.random() > 0.5 ? new Fox() : new Hen());
  // \~ Property 'push' does not exist on type 'readonly Animal[]'.
}
```

您可以通过重写初始示例，使函数返回一个 Animal 对象，而不是将其添加到数组中，来完全避免这个问题：

```ts
function foxOrHen(): Animal {
  return Math.random() > 0.5 ? new Fox() : new Hen();
}
const henhouse: Hen[] = [new Hen(), foxOrHen()];
// error, yay! Chickens are safe.
// Type 'Animal' is missing the following properties from type 'Hen': .
```

您可能会遇到类似的问题，任何被函数修改的对象都可能遇到这种情况，而不仅仅是数组。如果您为您的对象创建一个别名（项目 23），然后修改它，即使没有函数调用，也可能遇到麻烦。

虽然方差可能难以理解，但这里的教训很简单：避免修改函数参数！为了确保您不会这样做，请将它们声明为 readonly 或 Readonly。

### 函数调用不会使改进无效

这段代码乍一看并不太可疑（至少从类型安全的角度来看是这样）：

```ts
interface FunFact {
  fact: string;
  author?: string;
}
function processFact(fact: FunFact, processor: (fact: FunFact) => void) {
  if (fact.author) {
    processor(fact);
    console.log(fact.author.blink()); // Ok // ^? (property) FunFact.author?: string
  }
}
```

然而，根据处理器的情况，对 blink() 的调用可能会在运行时抛出异常：

```ts
processFact(
  { fact: "Peanuts are not actually nuts", author: "Botanists" },
  (f) => delete f.author
);
// Type checks, but throws `Cannot read property 'blink' of undefined`.
```

问题在于，if (fact.author) 将 fact.author 的类型从 string|undefined 精炼为 string。这是合理的。然而，调用 processor(fact) 应该使这种精炼失效。fact.author 的类型应该恢复为 string|undefined，因为 TypeScript 无法知道回调函数会对我们的精炼后的 fact 做什么。

为什么 TypeScript 允许这样做？因为大多数函数不会修改它们的参数，这种模式在 JavaScript 中很常见。

你如何避免这种情况？再次强调，不要修改你的函数参数！你可以通过传递对象的只读版本（第 14 项）来强制回调这样做。

### 可赋值性和可选属性

重要的是要记住，TypeScript 类型中的对象类型并不是“密封”的：它们可能具有你未声明的属性（第 4 项）。当与可选属性结合使用时，这可能导致不稳定性。

这可能就是这样发生的：

```ts
interface Person {
  name: string;
}
interface PossiblyAgedPerson extends Person {
  age?: number;
}
const p1 = { name: "Serena", age: "42 years" };
const p2: Person = p1;
const p3: PossiblyAgedPerson = p2;
console.log(`${p3.name} is ${p3.age?.toFixed(1)} years old.`);
```

从 p1 到 p2 的赋值绕过了过多的属性检查（条目 11）。p2 的静态类型为 Person。这是合理的，因为类型 {name: string; age: string} 可以赋值给 Person。在结构化类型中，允许有额外的属性。

赋值给 p3 时，我们失去了合理性。如果你认为类型是密封的，没有额外的属性，那么这个赋值应该是允许的：Person 不会有年龄属性，由于这个属性在 PossiblyAgedPerson 上是可选的，所以这是可以的。但是类型不是密封的，就像这里发生的那样，它们可能有额外的属性，这些属性与可选属性的类型不兼容。

如果遇到这个问题，可能是因为你在过于通用的属性名（例如，type）之间发生了名称冲突。在这个例子中，尝试选择更具体的属性名。将属性命名为 ageInYears 和 ageFormatted 可以防止这个错误。

不合理性只是可选属性的问题之一。条目 37 讨论了在添加可选属性之前应该仔细考虑的其他原因。

TypeScript 中存在一些不稳定的来源，但在实践中你很可能会遇到这些。记住，不稳定性并不是语言的缺陷。它反映了 TypeScript 在便利性、表达性和安全性这一谱系中的定位选择。如果你想移动到该谱系中的不同位置，有一些旋钮可以让你做到这一点（例如，strictNullChecks 和 noUncheckedIndexedAccess）。否则，请注意可能导致不稳定性的常见模式，并尽量避免。

### 需要记住的事项

- “不稳定性”是指符号在运行时的值与其静态类型不一致。它可能导致崩溃和其他不良行为，而不会出现类型错误。
- 注意一些可能导致不稳定性的常见方式：any 类型、类型断言（as、is）、对象和数组查找以及不准确类型定义。
- 避免修改函数参数，因为这可能导致不稳定性。如果您不打算修改它们，请将它们标记为只读。确保子类与其父类的方法声明相匹配。
- 注意可选属性可能导致类型不安全。

## 项目 49：跟踪您的类型覆盖率以防止类型安全回归

您已启用 noImplicitAny 并添加了类型注解到所有具有隐式 any 类型的值。您是否安全地免受与 any 类型相关的问题？答案是“不”；any 类型仍然可以通过两种主要方式进入您的程序：

通过显式任何类型

即使你遵循第 43 和 44 项建议，使你的任何类型既窄又具体，它们仍然是任何类型。特别是，像 any[]和{[key: string]: any}这样的类型，一旦你索引到它们，就会变成普通的任何类型，并且这些结果类型可以流过你的代码。

### 来自第三方类型声明

这尤其令人不安，因为来自@types 声明文件的任何类型会无声地进入：即使你启用了 noImplicitAny，并且你从未写过“any”这个词，你仍然有任何类型在代码中流动。

因为任何类型都可能对类型安全和开发者体验产生负面影响（第 5 项），所以在代码库中跟踪它们的数量是个好主意。有很多方法可以做到这一点，包括 npm 上的 type-coverage 包：

```bash
$ npx type-coverage
9985 / 10117 98.69%
```

这意味着在这个项目中，共有 10,117 个符号，其中 9,985 个（98.69%）的类型不是 any 或 any 的别名。如果某个更改意外地引入了 any 类型，并且它通过你的代码流动，你将看到这个百分比相应下降。

在某些方面，这个百分比是衡量你遵循本章其他建议情况的一种方式。使用范围狭窄的 any 将减少具有 any 类型的符号数量，使用更具体的类型如 any\[\]也是如此。从数量上跟踪这有助于你确保事情只会随着时间的推移而变得更好。

即使收集一次类型覆盖率信息也可能很有帮助。使用--detail 标志运行 type-coverage 将打印出代码中每个 any 类型出现的位置：

```bash
$ npx type-coverage --detail
path/to/code.ts:1:10 getColumnInfo
path/to/module.ts:7:1 pt2
```

这些值得调查，因为它们可能会揭示你未曾考虑过的来源。让我们看看一些例子。

显式的 any 类型往往是早期为了方便做出的选择的结果。可能你遇到了一个你不愿花时间解决的类型错误。也许这个类型是你还没有写出来的。或者你可能只是赶时间。

使用 any 的类型断言可能会阻止类型流动到它们本应流动的地方。也许你构建了一个处理表格数据的应用程序，需要一个单参数函数来构建某种类型的列描述：

```ts
function getColumnInfo(name: string): any {
  return utils.buildColumnInfo(appState.dataSchema, name); // returns any
}
```

在某个时候，utils.buildColumnInfo 函数返回了 any。作为提醒，你添加了一个注释和一个显式的：any 注解到该函数。

然而，在这几个月里，你还添加了一个 ColumnInfo 类型，utils.buildColumnInfo 现在不再返回任何内容。any 注释现在正在丢弃有价值的信息。去掉它！

第三方 any 类型可以有多种形式，但最极端的是当你给整个模块赋予 any 类型：

```ts
declare module "my-module";
```

现在，你可以从 my-module 中导入任何内容而不会出错。这些符号都具有 any 类型，并且如果通过它们传递值，将会产生更多的 any 类型：

```ts
import { someMethod, someSymbol } from "my-module"; // OK
const pt1 = { x: 1, y: 2 };
// ^? const pt1: { x: number; y: number; }
const pt2 = someMethod(pt1, someSymbol); // OK
// ^? const pt2: any
```

由于使用方式与良好类型化的模块相同，很容易忘记你已替换了该模块。或者可能是你的同事做了这件事，而你从未意识到。时不时地回顾这些内容是值得的。也许有该模块的官方类型声明。或者也许在阅读第 8 章后，你已经对模块有了足够的了解，可以自己编写类型并将其贡献给社区。

任何类型错误的常见来源之一是类型声明中的错误。可能是因为声明没有遵循第 30 项建议，将函数声明为返回联合类型，而实际上它返回的却是更具体的东西。当你第一次使用这个函数时，你可能觉得修复它不值得，所以使用了 any 断言。但也许声明已经被修复了，或者也许是你自己修复它们的时候了！

如果你希望持续关注代码中的任何类型，你可以设置 TypeScript 语言服务插件中的类型覆盖率。这就像拥有 X 射线视力，让你看到代码中隐藏的所有任何类型（图 5-1）。

[![20250528163805.jpg](https://i.postimg.cc/rpLnvqYr/20250528163805.jpg)](https://postimg.cc/pmqJjMvW)

图 5-1. 在编辑器中突出显示的 anyn 类型符号。这些都不会有 noImplicitAny 错误。

如果你将类型覆盖率添加到你的持续集成系统中，你将能够在类型安全性出现意外下降时立即发现。

你使用“any”类型的考虑可能已经不再适用。也许你现在可以插入一个类型，而之前你使用的是“any”。也许不再需要不安全的类型断言。也许你正在绕过的类型声明中的错误已经被修复。跟踪你的类型覆盖率可以突出这些选择，并鼓励你不断回顾它们。

### 需要记住的事项

- 即使设置了 noImplicitAny，任何类型仍然可以通过显式的“any”或第三方类型声明（@types）进入你的代码。
- 使用像 type-coverage 这样的工具跟踪你的程序类型化程度。这将鼓励你回顾使用“any”的决定，并随着时间的推移提高类型安全性。
