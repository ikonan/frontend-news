# 第 3 章 类型推断与控制流分析

在工业界使用的编程语言中，"静态类型"与"显式类型"传统上是同义词。C、C++、Java 这些语言都要求开发者显式声明类型。但学术界的语言从未将这两个概念混为一谈：像 ML 和 Haskell 这样的语言早就拥有复杂的类型推断系统，这种特性正逐渐被工业界语言所采纳。C++增加了 auto 关键字，Java 引入了 var 声明。Rust 和 Swift 等新兴语言则从诞生之初就内置了类型推断功能。

TypeScript 大量运用类型推断机制。若运用得当，它能显著减少代码中为实现完全类型安全所需的类型注解数量。区分 TypeScript 初学者与资深开发者的最直观方式，就是观察其代码中的类型注解数量。经验丰富的 TypeScript 开发者会使用相对较少的注解（但每个注解都发挥关键作用），而初学者往往会让冗余的类型注解淹没整个代码库。

在大多数编程语言中，变量的类型是固定不变的。但 TypeScript 略有不同——变量的类型会随着代码位置而变化，这种因周边代码导致类型改变的过程被称为控制流分析。

本章将教你理解类型推断与控制流分析的原理，展示可能遇到的问题及解决方案。阅读后，你将掌握 TypeScript 的类型推断机制，明确何时需要显式类型标注，以及即便类型可推断时仍建议标注的场景。

## 条款 18：避免为可推断类型添加冗余注解

许多 TypeScript 新手在将 JavaScript 代码库迁移时，第一反应就是添加大量类型注解。毕竟 TypeScript 的核心就是类型系统！但实际上，多数注解在 TypeScript 中是多余的。为所有变量声明类型不仅适得其反，还会被视为不良代码风格。

不要写成：

```ts
let x: number = 12;
```

只需写成：

```ts
let x = 12;
```

如果将鼠标悬停在编辑器中的 x 上，你会看到它的类型已被推断为数字（如图 3-1 所示）。

![](https://cdn-mineru.openxlab.org.cn/extract/e4d7b222-0a3e-4434-a349-f734d14e6c27/8c92bf8b98f9b32d00c743dcc02fe0a491c63e1297e43c171681a74d93d14d63.jpg)
图 3-1. 文本编辑器显示 x 的推断类型为数字。

显式类型注解是多余的。编写它只会增加干扰。如果不确定类型，可以在编辑器中查看。

TypeScript 也能推断更复杂对象的类型。与其这样写：

```ts
const person: {
  name: string;
  born: { where: string; when: string };
  died: {
    where: string;
    when: string;
  };
} = {
  name: "Sojourner Truth",
  born: { where: "Swartekill, NY", when: "c.1797" },
  died: { where: "Battle Creek, MI", when: "Nov. 26, 1883" },
};
```

你只需写成：

```ts
const person = {
  name: "Sojourner Truth",
  born: { where: "Swartekill, NY", when: "c.1797" },
  died: { where: "Battle Creek, MI", when: "Nov. 26, 1883" },
};
```

同样，类型是完全相同的。在值之外再写类型只会增加干扰。（第 20 条将解释 TypeScript 如何推断对象字面量的类型。）

对象适用的规则同样适用于数组。TypeScript 能轻松根据输入参数和操作推断出该函数的返回类型：

```ts
function square(nums: number[]) {
  return nums.map((x) => x * x);
}
const squares = square([1, 2, 3, 4]); // ^? const squares: number[]
```

TypeScript 的推断结果可能比你预期的更为精确。这通常是件好事。例如：

```ts
const axis1: string = "x"; // ^? const axis1: string
const axis2 = "y"; // ^? const axis2: "y"
```

对于 axis2 变量而言，"y"是更精确的类型。而 axis1 显式添加的字符串注解反而增加了冗余并降低了类型安全性。

允许类型推断还能方便代码重构。假设你有一个 Product 类型和对应的日志记录函数：

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}
```

某个时刻，你会意识到产品 ID 可能不仅包含数字还包含字母。于是你修改了 Product 中的 id 类型：

```ts
interface Product {
  id: string;
  name: string;
  price: number;
}
```

由于你在 logProduct 中为所有变量都添加了显式类型注解，这会导致报错：

```ts
function logProduct(product: Product) {
  const id: number = product.id;
  // \~\~ Type 'string' is not assignable to type 'number'
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}
```

如果你在 logProduct 函数体中省略所有类型注解，这段代码无需修改就能通过类型检查（在运行时也能正常工作）。

以下是 logProduct 的更优实现方案，它能自动推断所有局部变量的类型（同时改用解构赋值语法）：

```ts
function logProduct(product: Product) {
  const { id, name, price } = product;
  console.log(id, name, price);
}
```

带有显式类型注解的对应版本显得重复且杂乱：

```ts
function logProduct(product: Product) {
  const { id, name, price }: { id: string; name: string; price: number } =
    product;
  console.log(id, name, price);
}
```

你不能直接将类型注解放在解构语句中，因为正如第 8 条所述，它们会被解释为值空间的重命名指令。解构赋值是让代码更简洁的好方法。它能促进命名一致性，并且与类型推断配合得更好。

在某些 TypeScript 无法自行确定类型的场景下，仍然需要显式类型注解。你之前已经见过其中一种情况：函数参数。

有些语言会根据参数的最终用途来推断其类型，但 TypeScript 不会。在 TypeScript 中，变量的类型通常在其首次引入时就已确定。（第 25 条讨论了这个规则的一个重要例外情况。）

理想的 TypeScript 代码会为函数/方法签名添加类型注解，但不会为函数体内创建的局部变量添加。这样可以最大限度减少干扰，让读者专注于实现逻辑。

在某些情况下，函数参数也可以省略类型注解。例如当存在默认值时：

```ts
function parseNumber(str: string, base = 10) {
  // ^? (parameter) base: number
  // ...
}
```

由于默认值为 10，这里 base 的类型会被推断为 number。

当函数作为带有类型声明的库的回调时，通常可以推断出参数类型。在这个使用 express HTTP 服务器库的示例中，request 和 response 上的声明就不是必需的：

```ts
// Don't do this:
app.get("/health", (request: express.Request, response: express.Response) => {
  response.send("OK");
});

// Do this:
app.get("/health", (request, response) => {
  // ^? (parameter) request: Request<...>
  response.send("OK");
  // ^? (parameter) response: Response<...>
});
```

第 24 条将详细阐述上下文在类型推断中的运用。

在某些情况下，即便类型可以自动推断，您可能仍需要显式指定类型。

其中一种情况是定义对象字面量时：

```ts
const elmo: Product = {
  name: "Tickle Me Elmo",
  id: "048188 627152",
  price: 28.99,
};
```

当您像这样在定义中指定类型时，就会启用额外属性检查（第 11 条）。这有助于捕获错误，尤其对于含有可选字段的类型。

添加类型注解还能提高错误被准确报告位置的几率。如果省略注解，对象定义中的错误会引发类型报错，但报错位置会出现在使用处而非定义处：

```ts
const furby = { name: "Furby", id: 630509430963, price: 35 };
logProduct(furby);
// Argument ... is not assignable to parameter of type 'Product'
// Types of property 'id' are incompatible
// Type 'number' is not assignable to type 'string'
```

在大型代码库中，这类类型错误可能出现在与对象定义毫无关联的其他文件中。而添加注解后，错误会精准定位到问题源头，给出更简洁的报错信息：

```ts
const furby: Product = {
  name: "Furby",
  id: 630509430963,
  // \~\~ Type 'number' is not assignable to type 'string' price: 35,
};
logProduct(furby);
```

函数的返回类型也适用相同原则。即使类型可被推断，仍建议添加注解，这能防止实现错误渗透到函数调用环节。对于作为公共 API 导出的函数而言，这一点尤为重要。

假设你有一个获取股票报价的函数：

```ts
function getQuote(ticker: string) {
  return fetch(`https://quotes.example.com/?q=${ticker}`).then((response) =>
    response.json()
  );
}
```

你决定添加缓存以避免重复的网络请求：

```ts
const cache: { [ticker: string]: number } = {};
function getQuote(ticker: string) {
  if (ticker in cache) {
    return cache[ticker];
  }
  return fetch(`https://quotes.example.com/?q=${ticker}`)
    .then((response) => response.json())
    .then((quote) => {
      cache[ticker] = quote;
      return quote as number;
    });
}
```

这个实现存在一个错误，通过查看 getQuote 的推断返回类型就能发现：

```ts
getQuote;
// ^? function getQuote(ticker: string): number | Promise<number>
```

实际上应该返回 Promise.resolve(cache\[ticker\])，这样 getQuote 始终返回 Promise。这个错误很可能导致报错...但错误会出现在调用 getQuote 的代码中，而非 getQuote 本身：

```ts
getQuote("MSFT").then(considerBuying);
// Property 'then' does not exist on type // 'number | Promise<number>'
```

如果事先标注了预期的返回类型（Promise），错误就会在正确的位置被报告：

```ts
const cache: { [ticker: string]: number } = {};
function getQuote(ticker: string): Promise<number> {
  if (ticker in cache) {
    return cache[ticker];
    // \~\~\~ Type 'number' is not assignable to type 'Promise<number>'
  }
  // ...
}
```

为返回值添加类型注解可以防止实现错误演变为用户代码中的错误。这对于像 getQuote 这样包含多个返回语句的函数尤为重要。若希望 TypeScript 检查所有返回语句是否类型一致，就必须通过类型注解明确声明意图。

（第 27 条将阐述为何异步函数能有效规避此类错误）

显式声明返回类型还能促使开发者更清晰地思考函数设计：在实现前就应明确其输入输出类型。虽然具体实现可能有所调整，但函数的契约（类型签名）通常不应改变。这与测试驱动开发（TDD）的理念相通——在实现功能前先编写测试用例。先完善类型签名有助于获得符合设计初衷的函数，而非受限于临时实现方案。

另一个需要注解返回类型的情况是使用命名类型。例如对于这个函数，你可能选择不写返回类型：

```ts
interface Vector2D {
  x: number;
  y: number;
}
function add(a: Vector2D, b: Vector2D) {
  return { x: a.x + b.x, y: a.y + b.y };
}
```

TypeScript 将返回类型推断为 { x: number; y: number; }。虽然这与 Vector2D 兼容，但当代码使用者发现输入参数类型是 Vector2D 而输出类型却不是时，可能会感到意外（图 3-2）。

![](https://cdn-mineru.openxlab.org.cn/extract/e4d7b222-0a3e-4434-a349-f734d14e6c27/28d4378023d2863db77f06df49759c6d7915bb6418a9b172688e9d46bdaed56d.jpg)
图 3-2：add 函数的参数具有命名类型，但推断的返回值却没有

如果显式注解返回类型，代码表达会更加直观。若已为该类型编写过文档说明（条款 68），这些文档也会与返回值关联。随着推断返回类型的复杂度增加，为其提供命名类型会愈发必要。

最后，注解返回类型意味着 TypeScript 无需再费力推断它们。对于大型代码库，这将显著影响编译器性能。当构建变慢时，条款 78 提供了更多优化建议。

那么是否应该标注返回类型？为了精简代码并便于重构，默认答案是"不需要"。但这个决定很容易就会转向"需要"。如果函数包含多个返回语句、属于公共 API 的一部分，或者你想使用具名返回类型，那么就应该添加类型标注。

如果使用代码检查工具，typescript-eslint 的 no-inferrable-types 规则（注意拼写变体）可以帮助确保所有类型标注都是真正必要的。

### 要点备忘

- 当 TypeScript 能够推断出相同类型时，应避免编写类型标注。
- 理想的 TypeScript 代码应在函数/方法签名中包含类型标注，但不要在函数体内的局部变量上添加类型标注。
- 建议为对象字面量使用显式类型注解，以启用多余属性检查，确保错误能在发生位置附近被报告。
- 除非函数包含多个返回路径、属于公共 API 的一部分，或需要返回具名类型，否则无需标注函数返回类型。

## 条款 19：为不同类型使用不同变量

在 JavaScript 中，为不同目的复用变量来存储不同类型值并无问题：

```ts
let productId = "12-34-56";
fetchProduct(productId); // Expects a string
productId = 123456;
fetchProductBySerialNumber(productId); // excepects a number
```

在 TypeScript 中，这会导致两个错误：

```ts
let productId = "12-34-56";
fetchProduct(productId);
productId = 123456;
// \~\~ Type 'number' is not assignable to type 'string'
fetchProductBySerialNumber(productId);
// Argument of type 'string' is not assignable to parameter of type 'number'
```

将鼠标悬停在编辑器中的第一个 productId 上会提示问题所在（见图 3-3）。

![](https://cdn-mineru.openxlab.org.cn/extract/e4d7b222-0a3e-4434-a349-f734d14e6c27/6c85e81428b5e903e5bec8fa1eb4407416b2fbe42f73723a11a173f703895752.jpg)
图 3-3. productId 被推断为 string 类型

根据值"12-34-56"，TypeScript 已将 productId 的类型推断为字符串。因此无法将数字赋值给字符串类型，从而产生错误。

这让我们对 TypeScript 中的变量有了一个关键认识：虽然变量的值可以改变，但其类型通常不会改变。类型可能改变的一种常见方式是缩小范围（条款 22），但这涉及类型变小，而不是扩展以包含新值。条款 25 提出了这一规则的一个显著例外，但它只是例外而非普遍情况。

如何运用这一理念来修复示例？为了使 productId 的类型保持不变，它必须足够宽泛以同时涵盖字符串和数字。这正是联合类型 string|number 的定义：

```ts
let productId: string | number = "12-34-56";
fetchProduct(productId);
productId = 123456; // OK
fetchProductBySerialNumber(productId); // OK
```

这样就修复了错误。有趣的是，TypeScript 能够判断出在第一次调用时 id 实际上是字符串，而在第二次调用时实际上是数字。它根据赋值操作缩小了联合类型的范围。

虽然联合类型确实有效，但它可能会在后续使用中带来更多问题。联合类型比简单的 string 或 number 类型更难处理，因为通常在对它们进行任何操作之前，你必须先检查它们的具体类型。

更好的解决方案是引入一个新变量：

```ts
const productId = "12-34-56";
fetchProduct(productId);
const serial = 123456; // OK
fetchProductBySerialNumber(serial); // OK
```

在之前的版本中，第一个和第二个 productId 在语义上并无关联。它们之间的联系仅在于你复用了同一个变量。这不仅会让类型检查器困惑，也会让人类读者感到费解。

采用两个变量的版本具有多重优势：

- 它理清了两个无关的概念（ID 和序列号）。
- 它允许你使用更具体的变量名。
- 它改进了类型推断，无需类型注解。
- 它会产生更简单的类型（字符串和数字字面量，而非 string|number 联合类型）。
- 它允许你将变量声明为 const 而非 let，这使得人和类型检查器都能更容易理解这些变量。

本章反复强调的核心观点是：变量类型变化会增加类型检查器追踪代码逻辑的难度。应当尽量避免使用会改变类型的变量。若能为不同概念使用不同命名，代码对人类阅读者和类型检查器都会更加清晰。你的代码中应该大量使用 const 而非 let。

这与"变量遮蔽"现象不同，如下例所示：

```ts
const productId = "12-34-56";
fetchProduct(productId);
{
  const productId = 123456; // OK
  fetchProductBySerialNumber(productId); // OK
}
```

虽然这两个 productId 名称相同，但实际上是两个毫无关联的独立变量，它们拥有不同类型是允许的。TypeScript 虽然能正确区分，但人类读者可能会产生困惑。通常更好的做法是为不同概念使用不同命名。许多团队会通过诸如 eslint 的 no-shadow 等规则来禁止这种遮蔽行为。

本条虽然聚焦于标量值，但同样适用于对象类型。更多相关内容请参阅条款 21。

### 要点备忘

- 变量的值可以改变，但其类型通常不会改变。
- 为避免人类读者和类型检查器产生混淆，请避免对不同类型的值重用变量。

## 第 20 条：理解变量如何获取其类型

如第 7 条所述，在运行时每个变量都具有单一值。但在静态分析阶段（即 TypeScript 检查代码时），变量拥有的是可能值的集合，也就是其类型。当你用常量初始化变量却未指定类型时，类型检查器需要确定一个类型。换句话说，它需要从你指定的单一值中确定可能值的集合。在 TypeScript 中，这个过程被称为类型拓宽。理解它将帮助你解读错误信息，并更有效地使用类型注解。

假设你正在编写一个处理向量的库。你定义了一个三维向量的类型，并编写了一个获取其任意分量值的函数：

```ts
interface Vector3 {
  x: number;
  y: number;
  z: number;
}
function getComponent(vector: Vector3, axis: "x" | "y" | "z") {
  return vector[axis];
}
```

但当你尝试使用时，TypeScript 却报错了：

```ts
let x = "x";
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x);
// \~ Argument of type 'string' is not assignable // to parameter of type '"x" | "y" | "z"'
```

这段代码明明能正常运行，为何会报错？

问题在于变量 x 的类型被推断为 string，而 getComponent 函数期望其第二个参数是更具体的类型。这是类型拓宽在作祟，此处导致了类型错误。

"拓宽"这一概念具有模糊性，因为任何给定值都可能对应多种类型。以这个声明为例：

```ts
const mixed = ["x", 1];
```

mixed 变量的类型应该是什么？以下是几种可能性：

```ts
('x' | 1)[]
['x', 1]
[string, number]
readonly [string, number]
(string|number)[]
readonly (string|number)[]
[any, any]
any[]
```

在没有更多上下文的情况下，TypeScript 无法判断哪种类型是"正确"的。它只能猜测你的意图（本例中它猜测为(string|number)\[\]）。尽管 TypeScript 足够智能，但它毕竟无法读心，不可能每次都作出完全正确的推断。这就导致了我们刚才看到的那种意外错误。

在最初的示例中，x 的类型被推断为 string，因为 TypeScript 选择允许这样的代码：

```ts
let x = 'x';
x = 'a'
x = 'Four score and seven years ago...
```

但这样写也是合法的 JavaScript 代码：

```ts
let x = "x";
x = /x|y|z/;
x = ["x", "y", "z"];
```

在将 x 的类型推断为 string 时，TypeScript 试图在精确性与灵活性之间取得平衡。变量的类型在声明后不会彻底改变（条款 19），因此 string 比 string|RegExp 或 string|string\[\]或 any 更合理。

对于用 let 声明的基本类型值，通用规则是它们会扩展为"基础类型"："x"扩展为 string，39 扩展为 number，true 扩展为 boolean，以此类推（null 和 undefined 的处理方式不同，参见条款 25）。

TypeScript 提供了几种控制类型拓宽过程的方式。其一是使用 const。如果用 const 而非 let 声明变量，它会获得更窄的类型。实际上，使用 const 就能修复我们最初示例中的错误：

```ts
const x = "x"; // ^? const x: "x"
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); // OK
```

由于 x 不可重新赋值，TypeScript 能够推断出更精确的类型，而不会在后续赋值时意外标记错误。由于字符串字面量类型"x"可赋值给"x"|"y"|"z"，这段代码能通过类型检查器的验证。

然而 const 并非万能解药。对于对象和数组，类型推断仍存在模糊性。混合类型的示例展示了数组的问题：TypeScript 应该推断为元组类型吗？它应该为元素推断什么类型？

对象也存在类似问题。这段代码在 JavaScript 中是合法的：

```ts
const obj = { x: 1 };
obj.x = 3;
obj.x = "3";
obj.y = 4;
obj.z = 5;
obj.name = "Pythagoras";
```

对象 obj 的类型可以在具体性光谱上的任意位置被推断。最具体的是{readonly x: 1}，更通用的是{x: number}，再进一步泛化可以是{\[key: string\]: number}、object，而最宽泛的则是 any 或 unknown。

对于对象的情况，TypeScript 会推断出它所谓的"最佳通用类型"。其判断方式是将每个属性视为通过 let 声明来赋值。因此 obj 的类型会被推断为{x: number}。这允许你将 obj.x 重新赋值为另一个数字，但不能赋值为字符串。同时它也会阻止你通过直接赋值添加其他属性。（这正是第 21 条建议一次性构建对象的充分理由。）

因此以下四个语句都会报错：

```ts
const obj = {
  x: 1,
};
obj.x = 3; // OK
obj.x = "3";
// \~ Type 'string' is not assignable to type 'number'
obj.y = 4;
// \~ Property 'y' does not exist on type '{ x: number; }'
obj.z = 5;
// \~ Property 'z' does not exist on type '{ x: number; }'
obj.name = "Pythagoras";
// \~\~\~ Property 'name' does not exist on type '{ x: number; }'
```

TypeScript 再次试图在精确性与灵活性之间取得平衡。它需要推断出足够具体的类型来捕获错误，但又不能过于具体以致产生误报。其实现方式是将初始化为 1 这类值的属性推断为 number 类型。

如果你有更明确的需求，有几种方法可以覆盖 TypeScript 的默认行为。其一是提供显式的类型注解：

```ts
const obj: { x: string | number } = { x: 1 }; // ^? const obj: { x: string | number; }
```

另一种方式是为类型检查器提供额外上下文，例如将值作为函数参数传递（条款 24）。

第三种方式是使用常量断言。注意不要与 let 和 const 混淆，后者是在值空间引入符号。而常量断言纯粹是类型层面的构造。观察以下变量推断出的不同类型：

```ts
const obj1 = { x: 1, y: 2 };
// ^? const obj1: { x: number; y: number; }
const obj2 = { x: 1 as const, y: 2 };
// ^? const obj2: { x: 1; y: number; }
const obj3 = { x: 1, y: 2 } as const;
// ^? const obj3: { readonly x: 1; readonly y: 2; }
```

当你在值后书写 as const 时，TypeScript 会为其推断出最精确的类型，不会发生类型拓宽。对于真正的常量而言，这通常正是你需要的效果。你也可以对数组使用 as const 来推断元组类型：

```ts
const arr1 = [1, 2, 3]; // ^? const arr1: number[]
const arr2 = [1, 2, 3] as const; // ^? const arr2: readonly [1, 2, 3]
```

尽管语法相似，但常量断言不应与类型断言（as T）混淆。虽然最好避免使用类型断言（条款 9），但常量断言不会损害类型安全性，可以放心使用。

若希望 TypeScript 推断出元组类型而非数组类型，同时仍允许元组中各元素的类型拓宽至其基础类型/最佳公共类型，这里有个实用技巧：

```ts
function tuple<T extends unknown[]>(...elements: T) {
  return elements;
}
const arr3 = tuple(1, 2, 3);
// ^? const arr3: [number, number, number]
const mix = tuple(4, "five", true);
// ^? const mix: [number, string, boolean]
```

此处的元组函数在运行时并无实际作用，但能引导 TypeScript 推断出你想要的类型。另一个能引导类型推断的函数是 JavaScript 的 Object.freeze：

```ts
const frozenArray = Object.freeze([1, 2, 3]);
// ^? const frozenArray: readonly number[]
const frozenObj = Object.freeze({ x: 1, y: 2 });
// ^? const frozenObj: Readonly<{ x: 1; y: 2; }>
```

与 const 断言类似，Object.freeze 会在推断类型中引入 readonly 修饰符（尽管显示方式不同，但 frozenObj 的类型与 obj3 完全一致）。不同于 const 断言的是，"冻结"效果会在 JavaScript 运行时强制执行。但这是浅层冻结/只读，而 const 断言是深层作用。第 14 条将讨论 readonly 及其如何帮助预防错误。

最后，控制类型拓宽的第四种方式是 satisfies 运算符。它能确保值满足类型要求，并通过阻止 TypeScript 推断出更宽泛的类型来引导推断。其工作原理如下：

```ts
type Point = [number, number];
const capitals1 = { ny: [-73.7562, 42.6526], ca: [-121.4944, 38.5816] };
// ^? const capitals1: { ny: number[]; ca: number[]; }
const capitals2 = {
  ny: [-73.7562, 42.6526],
  ca: [-121.4944, 38.5816],
} satisfies Record<string, Point>;
capitals2;
// ^? const capitals2: { ny: [number, number]; ca: [number, number]; }
```

如果放任不管，TypeScript 会从对象字面量中提取键名并将值类型拓宽为 number\[\]，就像使用 let 声明时那样。而通过 satisfies，我们可以阻止值类型被拓宽到超出 Point 类型的范围。

这与使用相同类型注解得到的结果形成对比：

```ts
const capitals3: Record<string, Point> = capitals2;
capitals3.pr; // undefined at runtime
// ^? Point
capitals2.pr;
// \~\~ Property 'pr' does not exist on type '{ ny: ...; ca: ...; }'
```

来自 satisfies 的类型具有精确的键名，这有助于捕获错误。

如果对象的某部分无法分配给指定类型，satisfies 运算符会报错：

```ts
const capitalsBad = {
  ny: [-73.7562, 42.6526, 148],
  // \~\~ Type '[number, number, number]' is not assignable to type 'Point'. ca: [-121.4944, 38.5816, 26],
  // \~\~ Type '[number, number, number]' is not assignable to type 'Point'.
} satisfies Record<string, Point>;
```

这比常量断言更优，因为它会在定义对象时就报错，而非等到使用时才报错。

若遇到疑似因类型拓宽导致的错误提示，可尝试将 let 改为 const、添加显式类型注解、使用元组或 Object.freeze 等辅助函数、采用常量断言或 satisfies 子句。切记，在编辑器中实时查看类型始终是理解其运作原理的关键（参见第 6 条）。

### 要点备忘

- 理解 TypeScript 如何通过拓宽字面量来推断类型。
- 熟悉影响此行为的各种方式：const 声明、类型注解、上下文、辅助函数、as const 断言以及 satisfies 操作符。

## 第 21 条：一次性创建完整对象

正如第 19 条所述，虽然变量的值可能改变，但其在 TypeScript 中的类型通常不会变化。这使得某些 JavaScript 模式比其它模式更容易在 TypeScript 中建模。具体而言，这意味着你应该倾向于一次性创建完整对象，而非逐属性构建。

以下是 JavaScript 中创建表示二维点对象的一种方式：

```ts
const pt = {};
pt.x = 3;
pt.y = 4;
```

在 TypeScript 中，这种写法会在每次属性赋值时报错：

```ts
const pt = {};
// ^? const pt: {}
pt.x = 3;
// \~ Property 'x' does not exist on type '{}'
pt.y = 4;
// \~ Property 'y' does not exist on type '{}'
```

这是因为第一行的 pt 类型是根据其值 {} 推断出来的，你只能为已知属性赋值。

如果你定义一个 Point 接口，会遇到相反的问题：

```ts
interface Point {
  x: number;
  y: number;
}
const pt: Point = {};
// \~\~ Type '{}' is missing the following properties from type 'Point': x, y
pt.x = 3;
pt.y = 4;
```

类型断言看似提供了解决方案：

```ts
const pt = {} as Point; // ^? const pt: Point
pt.x = 3;
pt.y = 4; // OK
```

这种模式的问题在于，TypeScript 不会检查你在使用 pt 之前是否已为其分配了所有属性。例如，如果你漏掉了对 pt.y 的赋值，代码仍能通过类型检查，但可能导致 NaN 或运行时异常。正如第 9 条所述，类型断言不应成为你首选的工具。

最佳解决方案是使用类型声明一次性定义对象：

```ts
const pt: Point = { x: 3, y: 4 };
```

如果需要从较小的对象构建更大的对象，应避免分多个步骤进行：

```ts
const pt = { x: 3, y: 4 };
const id = { name: "Pythagoras" };
const namedPoint = {};
Object.assign(namedPoint, pt, id);
namedPoint.name;
// \~\~\~\~ Property 'name' does not exist on type '{}'
```

你可以改用对象展开语法...一次性构建更大的对象：

```ts
const namedPoint = { ...pt, ...id };
// ^? const namedPoint: { name: string; x: number; y: number; }
namedPoint.name; // OK
// ^? (property) name: string
```

还可以通过对象展开语法以类型安全的方式逐个字段构建对象。关键在于每次更新时都使用新变量，以便每个变量获得新类型（条款 19）：

```ts
const pt0 = {};
const pt1 = { ...pt0, x: 3 };
const pt: Point = { ...pt1, y: 4 }; // OK
```

最后一行中的类型声明确保我们已添加所有必要属性。虽然这种构建简单对象的方式略显迂回，但它不失为一种向对象添加属性并让 TypeScript 推断新类型的实用技巧。

要以类型安全的方式有条件地添加属性，可以使用展开语法配合空对象{}或任何假值（null、undefined、false 等），这些值不会添加任何属性：

```ts
declare let hasMiddle: boolean;
const firstLast = { first: "Harry", last: "Truman" };
const president = { ...firstLast, ...(hasMiddle ? { middle: "S" } : {}) };
// ^? const president: {
// middle?: string;
// first: string;
// last: string;
// }
// or: const president = {...firstLast, ...(hasMiddle && {middle: 'S'})};
```

如你所见，推断出的类型包含一个可选属性。

你还可以使用展开语法来有条件地添加多个字段：

```ts
declare let hasDates: boolean;
const nameTitle = { name: "Khufu", title: "Pharaoh" };
const pharaoh = { ...nameTitle, ...(hasDates && { start: -2589, end: -2566 }) };
// ^? const pharaoh: {
// start?: number;
// end?: number;
// name: string;
// title: string;
// }
```

在这种情况下，start 和 end 都变成了可选字段。如果读取这种类型的 start 值，就必须考虑它可能未定义的情况：

有时需要通过转换另一个对象或数组来构建新对象。这种情况下，与"一次性构建对象"等效的做法是使用内置函数式结构或 Lodash 等工具库，而非循环结构。更多内容详见条款 26。

### 要点备忘

- 建议一次性完整构建对象，而非零散拼装。
- 使用多个对象配合对象展开语法({...a, ...b})能以类型安全的方式添加属性。
- 掌握如何有条件地为对象添加属性

## 第 22 条：理解类型收窄

类型收窄（或称"细化"）是 TypeScript 从宽泛类型过渡到更具体类型的过程。最常见的例子莫过于空值检查：

```ts
const elem = document.getElementById("what-time-is-it");
// ^? const elem: HTMLElement | null
if (elem) {
  elem.innerHTML = "Party Time".blink();
  // ^? const elem: HTMLElement
} else {
  elem;
  // ^? const elem: null
  alert("No element #what-time-is-it");
}
```

如果 elem 为 null，那么第一个分支的代码就不会执行。因此 TypeScript 能够在该代码块中将 null 从联合类型中排除，从而得到更易处理的收窄类型。由于编译器会追踪代码的执行路径，这种机制

这被称为控制流分析。类型检查器通常非常擅长追踪你的逻辑，并在类似这样的条件语句中收窄类型，尽管偶尔会因为变量别名问题而受阻（参见第 23 条）。

注意同一个符号 elem 在代码的不同位置具有不同的静态类型。这在编程语言中是一种较为罕见的能力：例如在 C++、Java 和 Rust 中，变量在其整个生命周期内都保持单一类型。如果你想收窄其类型，还需要创建一个新变量。但在 TypeScript 中，符号在特定位置具有特定类型。学会利用这一点，你就能写出更简洁、更符合 TypeScript 惯用法的代码。

有多种方式可以收窄类型。在分支中抛出异常或返回会收窄代码块剩余部分中变量的类型：

```ts
const elem = document.getElementById("what-time-is-it"); // ^? const elem: HTMLElement | null
if (!elem) throw new Error("Unable to find #what-time-is-it");
elem.innerHTML = "Party Time".blink();
// ^? const elem: HTMLElement
```

你也可以使用 instanceof 操作符：

```ts
function contains(text: string, search: string | RegExp) {
  if (search instanceof RegExp) {
    return !!search.exec(text);
  } // ^? (parameter) search: RegExp
  return text.includes(search);
  // ^? (parameter) search: string
}
```

属性检查同样适用：

```ts
interface Apple {
  isGoodForBaking: boolean;
}
interface Orange {
  numSlices: number;
}
function pickFruit(fruit: Apple | Orange) {
  if ("isGoodForBaking" in fruit) {
    fruit; // ^? (parameter) fruit: Apple
  } else {
    fruit; // ^? (parameter) fruit: Orange
  }
  fruit; // ^? (parameter) fruit: Apple | Orange
}
```

某些内置函数（如 Array.isArray）也能缩小类型范围：

```ts
function contains(text: string, terms: string | string[]) {
  const termList = Array.isArray(terms) ? terms : [terms]; // ^? const termList: string[] //
}
```

TypeScript 通常非常擅长通过条件语句追踪类型。在添加类型断言前请三思——它可能察觉到了你未注意到的情况！例如，以下是从联合类型中排除 null 的错误方式：

```ts
const elem = document.getElementById("what-time-is-it");
// ^? const elem: HTMLElement | null
if (typeof elem === "object") {
  elem; // ^? const elem: HTMLElement | null
}
```

由于 JavaScript 中 typeof null 返回 "object"，实际上这种检查并未排除 null！类似的意外可能来自假值原始类型：

```ts
function maybeLogX(x?: number | string | null) {
  if (!x) {
    console.log(x); // ^? (parameter) x: string | number | null | undefined
  }
}
```

因为空字符串和 0 都属于假值，在该分支中 x 仍可能是字符串或数字。TypeScript 的判断是正确的！

另一种帮助类型检查器缩小类型范围的常见方法是为类型添加显式"标签"：

```ts
interface UploadEvent {
  type: "upload";
  filename: string;
  contents: string;
}
interface DownloadEvent {
  type: "download";
  filename: string;
}
type AppEvent = UploadEvent | DownloadEvent;
function handleEvent(e: AppEvent) {
  switch (e.type) {
    case "download":
      console.log("Download", e.filename); // ^? (parameter) e: DownloadEvent
      break;
    case "upload":
      console.log("Upload", e.filename, e.contents.length, "bytes"); // ^? (parameter) e: UploadEvent
      break;
  }
}
```

这种模式被称为"标签联合"或"可辨识联合"，在 TypeScript 中极为常见。第 4 章将重新讨论这种模式。编写 switch 语句时，最好测试是否覆盖了所有可能性。第 59 条将展示具体方法。

如果 TypeScript 无法推断出类型，你可以引入特殊函数来协助类型推断：

```ts
function isInputElement(el: Element): el is HTMLInputElement {
  return "value" in el;
}
function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    return el.value; // ^? (parameter) el: HTMLInputElement
  }
  return el.textContent; // ^? (parameter) el: HTMLElement
}
```

这被称为"用户定义的类型守卫"，而\`el is HTMLInputElement\`子句则称为"类型谓词"。作为返回类型，它向类型检查器表明：若函数返回 true，则可收窄该参数的类型范围。

某些函数能够利用类型守卫来收窄数组或对象中的类型，特别是数组的 filter 方法：

```ts
const formEls = document.querySelectorAll(".my-form *");
const formInputEls = [...formEls].filter(isInputElement); // ^? const formInputEls: HTMLInputElement[]
```

需特别注意，用户定义的类型守卫并不比类型断言（如\`el as HTMLInputElement\`）更安全：没有任何机制会校验类型守卫的函数体与其返回的类型谓词是否匹配。（本例中，实际上存在某些具有 value 属性但并非 HTMLInputElement 的元素。）

通常可以通过轻微调整代码来帮助 TypeScript 理解类型。这段使用 Map 的代码虽然逻辑正确，但会产生类型错误：

```ts
const nameToNickname = new Map<string, string>();
declare let yourName: string;
let nameToUse: string;
if (nameToNickname.has(yourName)) {
  nameToUse = nameToNickname.get(yourName);
  // \~\~\~ Type 'string | undefined' is not assignable to type 'string'.
} else {
  nameToUse = yourName;
}
```

问题在于 TypeScript 无法理解 Map 的 has 和 get 方法之间的关联性。它不知道通过 has 检查后，后续使用 get 查找时就不会出现 undefined 的情况。稍作调整即可消除类型错误（同时保持原有行为）：

```ts
const nickname = nameToNickname.get(yourName);
let nameToUse: string;
if (nickname !== undefined) {
  nameToUse = nickname;
} else {
  nameToUse = yourName;
}
```

这种模式很常见，使用"空值合并"运算符（??）可以更简洁地表达：

```ts
const nameToUse = nameToNickname.get(yourName) ?? yourName;
```

如果你发现自己在条件语句中与类型检查器较劲，不妨思考是否能重构代码来帮助 TypeScript 更好地理解逻辑。

理解类型何时不会收窄也很有帮助。回调函数就是一个典型例子：

```ts
function logLaterIfNumber(obj: { value: string | number }) {
  if (typeof obj.value == "number") {
    setTimeout(() => console.log(obj.value.toFixed()));
    // Property 'toFixed' does not exist on type 'string | number'.
  }
}
```

我们进行了类型检查，本应缩小 obj.value 的类型范围。但为何它又回退到联合类型，从而引发了类型错误？

这是因为调用代码可能如下所示：

```ts
const obj: { value: string | number } = { value: 123 };
logLaterIfNumber(obj);
obj.value = "Cookie Monster";
```

当回调函数执行时，obj.value 的类型已经改变，导致之前的类型收窄失效。这段代码在运行时抛出异常，TypeScript 对此发出警告是完全正确的。

理解类型收窄机制将帮助你建立对类型推断工作原理的直觉，更好地理解错误信息，从而与类型检查器建立更高效的协作关系。

### 要点备忘

- 理解 TypeScript 如何根据条件语句和其他控制流类型来收窄类型范围。
- 使用标记/可辨识联合类型和用户自定义类型守卫来辅助类型收窄过程。
- 考虑是否可以通过代码重构让 TypeScript 更容易跟随类型推断。

## 条款 23：保持类型别名的使用一致性

当你为某个值引入新名称时：

```ts
const place = { name: "New York", latLng: [41.6868, -74.2692] };
const loc = place.latLng;
```

即创建了一个别名。对该别名属性的修改也会反映在原始值上：

> loc\[0\] = 0;
> 0
> \> place.latLng
> \[ 0, -74.2692 \]

如果你使用过支持指针或引用类型的语言，这与指针概念相同。两个变量指向同一个底层对象。

别名是所有语言中编译器编写者的噩梦，因为它们使得控制流分析变得困难。如果你能谨慎使用别名，TypeScript 就能更好地理解你的代码，并帮助你发现更多真正的错误。

假设你有一个表示多边形的数据结构：

```ts
interface Coordinate {
  x: number;
  y: number;
}

interface BoundingBox {
  x: [number, number];
  y: [number, number];
}

interface Polygon {
  exterior: Coordinate[];
  holes: Coordinate[][];
  bbox?: BoundingBox;
}
```

多边形的几何形状由 exterior 和 holes 属性定义。（holes 数组允许你表示环形结构，即内部有孔洞的形状。）bbox 属性是一个可能存在的优化项。你可以利用它来加速点是否在多边形内的检测：

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  if (polygon.bbox) {
    if (
      pt.x < polygon.bbox.x[0] ||
      pt.x > polygon.bbox.x[1] ||
      pt.y < polygon.bbox.y[0] ||
      pt.y > polygon.bbox.y[1]
    ) {
      return false;
    }
  } // ... more complex check
}
```

这段代码能正常运行（且通过类型检查），但略显重复：polygon.bbox 在三行代码中出现了五次！这里尝试通过提取中间变量来减少重复：

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (polygon.bbox) {
    if (
      pt.x < box.x[0] ||
      pt.x > box.x[1] || // 'box' is possibly 'undefined'
      pt.y < box.y[0] ||
      pt.y > box.y[1]
    ) {
      // 'box' is possibly 'undefined'
      return false;
    }
  }
  // ...
}
```

这段代码仍然有效，为何会报错？通过提取 box 变量，你实际上创建了 polygon.bbox 的别名，这破坏了第一个示例中默默生效的控制流分析。

你可以检查 box 和 polygon.bbox 的类型来理解原因：

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  polygon.bbox; // ^? (property) Polygon.bbox?: BoundingBox | undefined
  const box = polygon.bbox; // ^? const box: BoundingBox | undefined
  if (polygon.bbox) {
    console.log(polygon.bbox); // ^? (property) Polygon.bbox?: BoundingBox
    console.log(box); // ^? const box: BoundingBox | undefined
  }
}
```

属性检查会细化 polygon.bbox 的类型，但不会细化 box 的类型，因此产生错误。这引出了别名的黄金法则：如果引入了别名，就要保持使用的一致性。

在属性检查中使用 box 即可修复错误：

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (box) {
    if (
      pt.x < box.x[0] ||
      pt.x > box.x[1] ||
      pt.y < box.y[0] ||
      pt.y > box.y[1]
    ) {
      // OK
      return false;
    }
  } //
}
```

类型检查器现在满意了，但人类读者却遇到了问题。我们对同一事物使用了两个名称：box 和 bbox。这是无实质差异的命名区分（条款 41）。

对象解构语法通过允许我们编写更简洁的代码，回报了一致命名的做法。你甚至可以将其用于数组和嵌套结构：

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const { bbox } = polygon;
  if (bbox) {
    const { x, y } = bbox;
    if (pt.x < x[0] || pt.x > x[1] || pt.y < y[0] || pt.y > y[1]) {
      return false;
    }
  }
  // ...
}
```

其他几点注意事项：

如果 x 和 y 属性是可选的，而非整个 bbox 属性可选，这段代码将需要更多的属性检查。我们受益于遵循条款 33 的建议，该条款讨论了将空值推到类型边界的重要性。可选属性对 bbox 是合适的，但对 holes 就不合适。如果 holes 是可选的，那么它可能缺失也可能是空数组（\[\]）。这将形成无实质差异的区分。空数组是表示"无孔洞"的理想方式。

在与类型检查器交互时，别忘了别名在运行时也可能引发混淆：

```ts
const { bbox } = polygon;
if (!bbox) {
  calculatePolygonBbox(polygon); // Fills in polygon.bbox
  // Now polygon.bbox and bbox refer to different values!
}
```

TypeScript 的控制流分析通常能很好地处理局部变量。但对于属性，你应当保持警惕：

```ts
function expandABit(p: Polygon) {
  /* ... */
}
polygon.bbox;
// ^? (property) Polygon.bbox?: BoundingBox | undefined
if (polygon.bbox) {
  polygon.bbox; // ^? (property) Polygon.bbox?: BoundingBox
  expandABit(polygon);
  polygon.bbox; // ^? (property) Polygon.bbox?: BoundingBox
}
```

调用 expandABit(polygon)很可能会取消设置 polygon.bbox，因此更安全的做法是让类型回退到 BoundingBox | undefined。但这会令人沮丧：每次调用函数时都必须重复属性检查。因此 TypeScript 做出了务实的选择——假定函数不会使其类型细化失效。条款 48 将讨论 TypeScript 为便利性而牺牲安全性的其他类似场景。

如果你提取了一个局部 bbox 变量而不是直接使用 polygon.bbox，bbox 的类型将保持准确，但其值可能与 polygon.bbox 不同。若担心这类副作用，最佳方案是向函数传递 polygon 的只读版本（条款 14）。通过阻止数据变更，我们还能提升类型安全性。这尤其适用于对象类型（包括数组），因为它们是可变的。原始值（数字、字符串等）本身不可变。

### 要点备忘

- 变量别名可能阻碍 TypeScript 的类型收窄。若为变量创建了别名，请保持使用一致性。
- 注意函数调用可能导致属性类型收窄失效。相比属性，应更信任局部变量的类型收窄。

## 条款 24：理解上下文在类型推断中的运用

TypeScript 的类型推断不仅基于值本身，还会考虑值所处的上下文环境。这种机制通常运作良好，但偶尔也会产生意料之外的结果。理解上下文在类型推断中的运用，将帮助你在遇到这类情况时准确识别并妥善处理。

在 JavaScript 中，你可以将表达式提取为常量而不会改变代码行为（只要不改变执行顺序）。换句话说，以下两种写法是等价的：

```ts
// Inline form
setLanguage("JavaScript");

// Reference form
let language = "JavaScript";
setLanguage(language);
```

在 TypeScript 中，这种重构方式依然适用：

```ts
function setLanguage(language: string) {
  /* ... */
}
setLanguage("JavaScript"); // OK
let language = "JavaScript";
setLanguage(language); // OK
```

现在假设你认真遵循了条款 35 的建议，将字符串类型替换为更精确的字面量类型联合：

```ts
type Language = "JavaScript" | "TypeScript" | "Python";
function setLanguage(language: Language) {
  /* ... */
}
setLanguage("JavaScript"); // OK

let language = "JavaScript";
setLanguage(language);
// Argument of type 'string' is not assignable
// to parameter of type 'Language'
```

哪里出错了？在内联形式中，TypeScript 通过函数声明知道参数应该是 Language 类型。字符串字面量'JavaScript'可以赋值给该类型，因此没有问题。但当你提取出一个变量时，TypeScript 必须在赋值时推断其类型。它应用了常规算法（条款 20）并推断为 string 类型，而 string 不可赋值给 Language 类型，因此报错。

**注意**

> 某些语言能够根据变量的最终用途推断其类型。但这也会造成困惑。TypeScript 的创建者 Anders Hejlsberg 将其称为"远距离的诡异作用"。总体而言，TypeScript 会在变量首次引入时确定其类型。关于此规则的一个显著例外，请参阅条款 25。

有两种好方法可以解决这个问题。一种是通过类型注解限制 language 的可能值：

```ts
let language: Language = "JavaScript";
setLanguage(language); // OK
```

这种做法还有个额外好处：如果语言名称拼写有误（比如把'Typescript'的首字母'S'写成小写），系统会立即报错提示。

另一种解决方案是将变量声明为常量：

```ts
const language = "JavaScript"; // ^? const language: "JavaScript"
setLanguage(language); // OK
```

通过使用 const，我们向类型检查器明确该变量不可更改。因此 TypeScript 能推断出更精确的 language 类型——即字符串字面量类型"JavaScript"。这个类型可赋值给 Language 类型，自然就能通过类型检查。当然，若确实需要重新赋值 language 变量，那就必须使用类型注解。

这个问题的本质在于：我们将变量值与其使用场景割裂开了。有时这无伤大雅，但多数情况下会引发问题。接下来我们将探讨几个因上下文缺失导致错误的典型案例，并展示修复方法。

### 元组类型

除了字符串字面量类型外，元组类型也可能引发问题。假设你正在开发一个支持编程式平移的地图可视化功能：

```ts
// Parameter is a (latitude, longitude) pair.
function panTo(where: [number, number]) {
  /* ... */
}
panTo([10, 20]); // OK
const loc = [10, 20];
// ^? const loc: number[]
panTo(loc);
// Argument of type 'number[]' is not assignable to
// parameter of type '[number, number]'
```

与之前情况类似，这里出现了值与上下文的分离。第一个例子中，\[10, 20\]可以赋值给元组类型\[number, number\]。而在第二个例子中，TypeScript 将 loc 推断为 number\[\]类型（即长度未知的数字数组）。由于许多数组的元素数量不符合要求，这种类型无法赋值给元组类型。

那么如何在不使用 any 的情况下修复这个错误？虽然已经用 const 声明过变量，但这无济于事。不过你仍然可以通过类型注解来明确告知 TypeScript 你的意图：

```ts
const loc: [number, number] = [10, 20];
panTo(loc); // OK
```

如第 20 条所述，另一种方法是提供"常量上下文"。这会告知 TypeScript 你希望该值具有深层常量性，而非 const 赋予的浅层常量性：

```ts
const loc = [10, 20] as const;
// ^? const loc: readonly [10, 20]
panTo(loc);
// The type 'readonly [10, 20]' is 'readonly'
// and cannot be assigned to the mutable type '[number, number]'
```

现在 loc 的类型被推断为 readonly \[10, 20\]，而非 number\[\]。遗憾的是这过于精确了！panTo 的类型签名并未承诺不会修改其 where 参数的内容。由于 loc 参数具有 readonly 类型，这就不适用了。

最佳解决方案是为 panTo 函数添加 readonly 标注：

```ts
function panTo(where: readonly [number, number]) {
  /* ... */
}
const loc = [10, 20] as const;
panTo(loc); // OK
```

若类型签名不受你控制，则需使用类型断言。（关于 readonly 与类型安全性，第 14 条有更详细说明。）

常量上下文可以优雅地解决推理过程中丢失上下文的问题，但它们确实存在一个明显的缺点：如果在定义时出错（比如给元组添加了第三个元素），错误会在调用处而非定义处被标记。这可能造成困惑，尤其当错误发生在远离定义位置的深层嵌套对象中时：

```ts
const loc = [10, 20, 30] as const; // error is real y here.
panTo(loc);
// \~\~\~ Argument of type 'readonly [10, 20, 30]' is not assignable to
// parameter of type 'readonly [number, number]'
// Source has 3 element(s) but target allows only 2.
```

因此，更推荐使用内联形式或应用类型声明。

### 对象

当从包含字符串字面量或元组的较大对象中提取常量时，也会出现将值与上下文分离的问题。例如：

```ts
type Language = "JavaScript" | "TypeScript" | "Python";
interface GovernedLanguage {
  language: Language;
  organization: string;
}
function complain(language: GovernedLanguage) {
  /* ... */
}
complain({ language: "TypeScript", organization: "Microsoft" }); // OK
const ts = { language: "TypeScript", organization: "Microsoft" };
complain(ts);
// \~\~ Argument of type '{ language: string; organization: string; }'
// is not assignable to parameter of type 'GovernedLanguage'
// Types of property 'language' are incompatible
// Type 'string' is not assignable to type 'Language'
```

在 ts 对象中，语言类型被推断为字符串。与之前一样，解决方案是添加类型注解（const ts: GovernedLanguage = ...）、使用常量断言（as const）或 satisfies 运算符（第 20 条）。

### 回调函数

当你将回调函数传递给另一个函数时，TypeScript 会利用上下文来推断回调函数的参数类型：

```ts
function callWithRandomNumbers(fn: (n1: number, n2: number) => void) {
  fn(Math.random(), Math.random());
}
callWithRandomNumbers((a, b) => {
  // ^? (parameter) a: number
  console.log(a + b);
  // ^? (parameter) b: number
});
```

由于 callWithRandomNumbers 的类型声明，a 和 b 的类型被推断为数字。如果将回调函数提取为常量，就会失去该上下文并触发 noImplicitAny 错误：

```ts
const fn = (a, b) => {
  // Parameter 'a' implicitly has an 'any' type
  // \~ Parameter 'b' implicitly has an 'any' type
  console.log(a + b);
};
callWithRandomNumbers(fn);
```

解决方案有两种：要么为参数添加类型注解：

```ts
const fn = (a: number, b: number) => {
  console.log(a + b);
};
callWithRandomNumbers(fn);
```

要么对整个函数表达式应用类型声明（参见第 12 条）。如果函数仅在一处使用，优先采用内联形式，这样可以减少注解的需求。

### 要点备忘

- 要注意上下文在类型推断中的运用方式。
- 如果提取变量导致类型错误，可能需要添加类型注解。
- 若变量确为常量，应使用常量断言（as const）。但需注意，这可能导致错误在使用时而非定义时暴露。
- 在可行的情况下优先内联值，以减少类型注解的需求。

## 条款 25：理解渐进式类型

在 TypeScript 中，变量的类型通常在声明时确定。此后类型可以被收窄（例如通过检查是否为 null，参见条款 22），但不能扩展以包含新值。然而存在一个显著例外——"渐进式类型"。理解其运作机制能减少代码中的类型注解需求，并帮助您阅读采用这种便捷模式的 TypeScript 代码。

在 JavaScript 中，你可能会编写一个函数来生成数字范围，像这样：

```ts
function range(start, limit) {
  const nums = [];
  for (let i = start; i < limit; i++) {
    nums.push(i);
  }
  return nums;
}
```

当你将其转换为 TypeScript 时，它的工作方式完全符合预期：

```ts
function range(start: number, limit: number) {
  const nums = [];
  for (let i = start; i < limit; i++) {
    nums.push(i);
  }
  return nums;
  // ^? const nums: number[]
}
```

然而仔细观察后，令人惊讶的是这居然能正常运行！当 nums 被初始化为\[\]（可能是任何类型的数组）时，TypeScript 如何知道 nums 的类型是 number\[\]？显然 TypeScript 没有遵循其从字面值推导类型的常规规则（条款 20）。通过检查 nums 的三处出现位置来揭示其推断类型，故事开始明朗：

```ts
function range(start: number, limit: number) {
  const nums = []; // ^? const nums: any[]
  for (let i = start; i < limit; i++) {
    nums.push(i); // ^? const nums: any[]
  }
  return nums; // ^? const nums: number[]
}
```

nums 的类型最初是 any\[\]，一个未区分的数组。但当我们向其推入数字值后，其类型"进化"为了 number\[\]。

这与类型收窄（又称"细化"）不同。空数组的类型可以通过向其添加不同元素而扩展：

```ts
const result = [];
// ^? const result: any[]
result.push("a");
result;
// ^? const result: string[]
result.push(1);
result;
// ^? const result: (string | number)[]
```

在条件语句中，类型甚至可以在不同分支间变化。这里你可以通过一个简单值（而非数组）观察到相同行为：

```ts
let value;
// ^? let value: any
if (Math.random() < 0.5) {
  value = /hello/;
  value; // ^? let value: RegExp
} else {
  value = 12;
  value; // ^? let value: number
}
value;
// ^? let value: number | RegExp
```

**注意**

> 这种行为在编辑器中可能令人困惑，因为类型只有在赋值或添加元素后才会"演变"。在赋值行检查类型时，仍会显示为 any 或 any\[\]类型。

这种结构是一种减少类型注解需求的便捷方式。您可以在自己的代码中使用它，并且在阅读代码时应当能够识别它。有时它被称为"渐进式 any"，因为变量隐式具有 any 类型，但这并非危险的 any（稍后会详细说明）。它有时也被称作"渐进式 let"或"渐进式数组"。

另一个触发这种"渐进式"行为的情况是变量初始设置为 null 或 undefined。当您在 try/catch 块中设置值时经常会出现这种情况：

```ts
let value = null;
// ^? let value: any
try {
  value = doSomethingRiskyAndReturnANumber();
  value; // ^? let value: number
} catch (e) {
  console.warn("alas!");
}

value; // ^? let value: number | null
```

如果您在设置值或向其推送值之前尝试使用渐进式类型，将会收到隐式 any 错误：

```ts
function range(start: number, limit: number) {
  const nums = [];
  // \~ Variable 'nums' implicitly has type 'any[]' in some
  // locations where its type cannot be determined
  if (start === limit) {
    return nums; // Variable 'nums' implicitly has an 'any[]' type
  }
  for (let i = start; i < limit; i++) {
    nums.push(i);
  }
  return nums;
}
```

换句话说，渐进式类型仅在写入时表现为 any。如果在它们仍为 any 时尝试读取，就会出错。这不是第 5 条警告您需要警惕的那种 any 类型。它不会像其他 any 类型那样在应用程序中扩散。

隐式 any 类型不会通过函数调用进行类型演化。此处的箭头函数会干扰类型推断：

```ts
function makeSquares(start: number, limit: number) {
  const nums = []; // Variable 'nums' implicitly has type 'any[]' in some locations
  range(start, limit).forEach((i) => {
    nums.push(i * i);
  });
  return nums; // Variable 'nums' implicitly has an 'any[]' type
}
```

改进的类型推断是 TypeScript 中优先选择 for-of 循环而非 forEach 循环的一个充分理由。不过针对这个特定案例，更好的做法是使用内置的数组 map 方法通过单条语句转换数组，从而完全避免迭代和类型演化问题。更多关于函数式结构如何辅助类型流动的内容，请参阅条款 26。

类型演化机制伴随着类型推断的所有常见注意事项。你的数组正确类型真的是(string|number)\[\]吗？或者它本应是 number\[\]却错误地推入了字符串？你可能仍需要显式类型注解来获得更好的错误检查，而非依赖类型演化机制，至少应该注解函数返回类型以确保实现错误不会渗透到类型签名中（条款 18）。

当通过推入元素构建数组或条件式设置值时，可考虑利用类型演化机制来减少类型注解需求，并促进类型在代码中的自然流动。

### 要点备忘

- 虽然 TypeScript 的类型通常只能细化，但初始化为 null、undefined 或\[\]的值的类型允许动态演变。
- 当遇到这种结构时，请识别并理解它，利用它来减少自己代码中对类型注解的需求。
- 为了更好的错误检查，建议提供显式类型注解而非使用动态演变类型。

## 第 26 条：使用函数式结构和辅助类型流动的库

JavaScript 从未像 Python、C 或 Java 那样拥有标准库。多年来，许多库试图填补这一空白。jQuery 不仅提供了 DOM 操作辅助工具，还提供了对象和数组的迭代与映射方法。Underscore 更侧重于提供通用工具函数，而 Lodash 在此基础上进一步发展。如今

像 Ramda 这样的库继续将函数式编程理念引入 JavaScript 世界。

这些库中的部分功能（如 map、flatMap、filter 和 reduce）已被纳入 JavaScript 语言本身。虽然这些结构（以及 Lodash 提供的其他功能）在 JavaScript 中非常实用，通常优于手动编写的循环，但当你加入 TypeScript 时，这种优势会更加明显。这是因为它们的类型声明能确保类型通过这些结构正确传递。而手动编写循环时，类型安全需自行保证。

例如解析 CSV 数据时，可以用命令式风格的纯 JavaScript 实现：

```ts
const csvData = "...";
const rawRows = csvData.split("\n");
const headers = rawRows[0].split(",");
const rows = rawRows.slice(1).map((rowStr) => {
  const row = {};
  rowStr.split(",").forEach((val, j) => {
    row[headers[j]] = val;
  });
  return row;
});
```

更注重功能性的 JavaScript 开发者可能更倾向于使用 reduce 构建行对象：

```ts
const rows = rawRows
  .slice(1)
  .map((rowStr) =>
    rowStr
      .split(",")
      .reduce((row, val, i) => ((row[headers[i]] = val), row), {})
  );
```

这个版本节省了一些字符，但根据个人偏好可能会显得更晦涩。Lodash 的 zipObject 函数通过"压缩"键数组和值数组来形成对象，可以进一步简化代码：

```ts
import _ from "lodash";
const rows = rawRows
  .slice(1)
  .map((rowStr) => _.zipObject(headers, rowStr.split(",")));
```

就个人而言，我认为这是所有方案中最清晰的。但值得为此在项目中添加第三方库依赖，并让所有同事学习如何使用它吗？

当引入 TypeScript 后，天枰开始更明显地倾向于 Lodash 解决方案。

CSV 解析器的原生 JavaScript 版本在 TypeScript 中都会产生相同的错误：

```ts
const rowsImperative = rawRows.slice(1).map((rowStr) => {
  const row = {};
  rowStr.split(",").forEach((val, j) => {
    row[headers[j]] = val;
    // \~ No index signature with a parameter of
    // type 'string' was found on type '{}'
  });
  return row;
});

const rowsFunctional = rawRows.slice(1).map((rowStr) =>
  rowStr.split(",").reduce(
    (row, val, i) => ((row[headers[i]] = val), row),
    // \~ No index signature with a parameter of
    // type 'string' was found on type'{}'
    {}
  )
);
```

每种情况的解决方案都是为{}提供类型注解，可以是{\[column: string\]: string}或 Record<string, string>。

而 Lodash 版本则无需修改就能通过类型检查：

```ts
const rowsLodash = rawRows
  .slice(1)
  .map((rowStr) => _.zipObject(headers, rowStr.split(",")));
rowsLodash;
// ^? const rowsLodash: _.Dictionary<string>[]
```

Dictionary 是 Lodash 的类型别名。Dictionary 等同于{\[key: string\]: string}或 Record<string, string>。关键在于 rows 的类型完全正确，无需额外类型注解。

随着数据处理逻辑的复杂化，这些优势会愈发明显。例如，假设你有一个包含 NBA 各队球员名单的对象：

```ts
interface BasketballPlayer {
  name: string;
  team: string;
  salary: number;
}
declare const rosters: { [team: string]: BasketballPlayer[] };
```

若要通过循环构建扁平化列表，你可能会对数组使用 concat 方法。这段代码可以运行但无法通过类型检查：

```ts
let allPlayers = [];
// Variable 'allPlayers' implicitly has type 'any[]'
// in some locations where its type cannot be determined
for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players); // \~ Variable 'allPlayers' implicitly has an 'any[]' type
}
```

（concat 方法不会触发第 25 条所述的"渐进式类型推导"行为。）

要修正这个错误，你需要为 allPlayers 添加类型注解：

```ts
let allPlayers: BasketballPlayer[] = [];
for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players); // OK
}
```

但更好的解决方案是使用 Array.prototype.flat 方法：

```ts
const allPlayers = Object.values(rosters).flat(); // OK
// ^? const allPlayers: BasketballPlayer[]
```

flat 方法可将多维数组展平。其类型签名类似于 T\[\]\[\] => T\[\]。这个版本最为简洁，且无需类型注解。额外的好处是，你可以使用 const 而非 let 来防止后续对 allPlayers 变量的修改。

假设你想从 allPlayers 开始，生成一份按薪资排序的各球队最高薪球员名单。

这是一个不使用 Lodash 的解决方案。在任何未使用函数式结构的地方都需要类型注解：

```ts
const teamToPlayers: { [team: string]: BasketballPlayer[] } = {};
for (const player of allPlayers) {
  const { team } = player;
  teamToPlayers[team] = teamToPlayers[team] || [];
  teamToPlayers[team].push(player);
}
for (const players of Object.values(teamToPlayers)) {
  players.sort((a, b) => b.salary - a.salary);
}
const bestPaid = Object.values(teamToPlayers).map((players) => players[0]);
bestPaid.sort((playerA, playerB) => playerB.salary - playerA.salary);
console.log(bestPaid);
```

输出如下：

```ts
[
  { team: "GSW", salary: 51915615, name: "Stephen Curry" },
  { team: "PHO", salary: 47649433, name: "Kevin Durant" },
  { team: "DEN", salary: 47607350, name: "Nikola Jokić" },
  { team: "PHI", salary: 47607350, name: "Joel Embiid" },
  { team: "LAL", salary: 47607350, name: "LeBron James" },
];
```

使用 Lodash 的等效写法：

```ts
const bestPaid = _(allPlayers)
  .groupBy((player) => player.team)
  .mapValues((players) => _.maxBy(players, (p) => p.salary)!)
  .values()
  .sortBy((p) => -p.salary)
  .value();
console.log(bestPaid.slice(0, 10));
// ^? const bestPaid: BasketballPlayer[]
```

这段代码不仅长度减半，而且仅需一次非空断言（类型检查器无法识别传入 \_.maxBy 的 players 数组非空）。它运用了 Lodash 和 Underscore 中的"链式调用"概念，让你能以更自然的顺序编写操作序列。不同于这种写法：

```ts
_.c(_.b(_.a(v)));
```

你可以这样写：

```ts
_(v).a().b().c().value();
```

\_(v) 对值进行"包装"，而.value()则对其进行"解包"。

你可以检查调用链中的每个函数，查看被包装值的类型。这些类型始终是正确的。

内置函数式结构和 Lodash 等库中的结构能如此流畅地传递类型并非偶然。通过避免数据突变并从每次调用返回新值，它们也能产生新类型（条款 19）。在很大程度上，TypeScript 的发展正是为了精准建模现实 JavaScript 库的行为模式。充分利用这些成果并善加运用吧！

### 要点备忘

- 优先使用内置函数式结构和 Lodash 等工具库提供的功能，而非手动实现的结构，这样可以改善类型流、增强代码可读性，并减少显式类型标注的需求。

## 第 27 条：使用异步函数替代回调以优化类型流

传统 JavaScript 采用回调模式处理异步行为，这导致了臭名昭著的"回调地狱"现象：

```ts
declare function fetchURL(
  url: string,
  callback: (response: string) => void
): void;
fetchURL(url1, function (response1) {
  fetchURL(url2, function (response2) {
    fetchURL(url3, function (response3) {
      // ...
      console.log(1);
    });
    console.log(2);
  });
  console.log(3);
});
console.log(4);

// Logs:
// 4
// 3
// 2
// 1
```

这段代码存在严重的嵌套问题，从日志可以看出其执行顺序与代码书写顺序完全相反。这使得回调代码极难阅读。若需要并发执行请求或在出错时中断，情况会变得更加混乱。

ES2015 引入了 Promise 概念来破解回调地狱。Promise 代表未来某个时刻可用的值（有时也被称为"futures"）。以下是使用 Promise 重构的相同代码：

```ts
const page1Promise = fetch(url1);
page1Promise
  .then((response1) => {
    return fetch(url2);
  })
  .then((response2) => {
    return fetch(url3);
  })
  .then((response3) => {
    // ...
  })
  .catch((error) => {
    // ...
  });
```

现在嵌套层级减少了，执行顺序也更直接地对应代码顺序。同时更容易统一错误处理，并使用像 Promise.all 这样的高阶工具。

ES2017 引入了 async 和 await 关键字，使代码更加简洁：

```ts
async function fetchPages() {
  const response1 = await fetch(url1);
  const response2 = await fetch(url2);
  const response3 = await fetch(url3); //
}
```

await 关键字会暂停 fetchPages 函数的执行，直到每个 Promise 完成解析。在 async 函数中，等待一个被拒绝的 Promise 会抛出异常。这让你可以使用常规的 try/catch 机制：

```ts
async function fetchPages() {
  try {
    const response1 = await fetch(url1);
    const response2 = await fetch(url2);
    const response3 = await fetch(url3);
    // ...
  } catch (e) {
    // ...
  }
}
```

与异常类似，TypeScript 中的 Promise 拒绝也是无类型的。

所有现代 JavaScript 运行时都支持 async 和 await，即使你的目标是 ES5 或更早版本，TypeScript 编译器也会执行一些复杂的转换来使 async 和 await 正常工作。换句话说，无论你的运行时环境如何，使用 TypeScript 都可以使用 async/await。

相比回调函数，使用 Promise 或 async/await 有几个充分的理由：

- Promise 比回调函数更易于组合。
- 类型系统能更轻松地通过 Promise 传递，而回调函数则较难实现这一点。

若需并发获取页面，例如可使用 Promise.all 组合多个 Promise：

```ts
async function fetchPages() {
  const [response1, response2, response3] = await Promise.all([
    fetch(url1),
    fetch(url2),
    fetch(url3),
  ]);
  // ...
}
```

在此场景下，结合解构赋值与 await 语法尤为优雅。

TypeScript 能自动推断这三个响应变量的类型均为 Response。若改用回调函数实现并发请求，等效代码需要更多机制和类型注解：

```ts
function fetchPagesWithCallbacks() {
  let numDone = 0;
  const responses: string[] = [];
  const done = () => {
    const [response1, response2, response3] = responses;
    // ...
  };
  const urls = [url1, url2, url3];
  urls.forEach((url, i) => {
    fetchURL(url, (r) => {
      responses[i] = url;
      numDone++;

      if (numDone === urls.length) done();
    });
  });
}
```

要扩展此功能以包含错误处理或实现类似 Promise.all 的通用性颇具挑战性。

类型推断同样适用于 Promise.race 方法，该方法会在其输入的多个 Promise 中首个完成时返回结果。你可以利用这一特性为 Promise 添加通用的超时机制：

```ts
function timeout(timeoutMs: number): Promise<never> {
  return new Promise((resolve, reject) => {
    setTimeout(() => reject("timeout"), timeoutMs);
  });
}
async function fetchWithTimeout(url: string, timeoutMs: number) {
  return Promise.race([fetch(url), timeout(timeoutMs)]);
}
```

fetchWithTimeout 的返回类型会被自动推断为 Promise，无需手动添加类型注解。深入理解其原理颇为有趣：Promise.race 的返回类型是其输入类型的联合类型，本例中即 Promise<Response | never>。但由于 never 类型（空集）参与联合运算时会被消解，因此最终简化为 Promise。当你使用 Promise 时，TypeScript 的所有类型推断机制都会协同工作以确保类型正确。

虽然偶尔仍需直接使用原始 Promise（例如封装 setTimeout 这类回调 API 时），但若条件允许，通常应优先选择 async/await 而非原始 Promise，原因有二：

这种方式通常能生成更简洁直观的代码。
它强制要求异步函数始终返回 Promise 对象。

后一个特性有助于避免一类令人困惑的错误。根据定义，异步函数始终返回 Promise，即使它没有等待任何操作也是如此。TypeScript 能帮助你建立这种直觉：

```ts
async function getNumber() {
  return 42;
}
// ^? function getNumber(): Promise<number>
```

你也可以创建异步箭头函数：

```ts
const getNumber = async () => 42; // ^? const getNumber: () => Promise<number>
```

与之等价的原始 Promise 写法是：

```ts
const getNumber = () => Promise.resolve(42); // ^? const getNumber: () => Promise<number>
```

虽然为立即可用的值返回一个 Promise 可能看起来有些奇怪，但这实际上有助于强制执行一个重要规则：函数应该始终同步运行，或者始终异步运行，绝不能混用两种方式。

为了理解违反这条规则会如何导致混乱，让我们尝试为 fetchURL 函数添加缓存功能：

```ts
// Don't do this!
const _cache: { [url: string]: string } = {};
function fetchWithCache(url: string, callback: (text: string) => void) {
  if (url in _cache) {
    callback(_cache[url]);
  } else {
    fetchURL(url, (text) => {
      _cache[url] = text;
      callback(text);
    });
  }
}
```

虽然立即调用回调函数看似是一种优化，但现在客户端使用这个函数会变得极其困难：

```ts
let requestStatus: "loading" | "success" | "error";
function getUser(userId: string) {
  fetchWithCache(`/user/${userId}`, (profile) => {
    requestStatus = "success";
  });
  requestStatus = "loading";
}
```

调用 getUser 后 requestStatus 的值会是什么？这完全取决于用户资料是否被缓存。如果未被缓存，requestStatus 将被设置为"success"；如果已缓存，它会被先设为"success"然后又变回"loading"。糟糕！

对两个函数都使用 async 可确保行为一致性：

```ts
const _cache: { [url: string]: string } = {};
async function fetchWithCache(url: string) {
  if (url in _cache) {
    return _cache[url];
  }
  const response = await fetch(url);
  const text = await response.text();
  _cache[url] = text;
  return text;
}
let requestStatus: "loading" | "success" | "error";
async function getUser(userId: string) {
  requestStatus = "loading";
  const profile = await fetchWithCache(`/user/${userId}`);
  requestStatus = "success";
}
```

现在可以完全明确 requestStatus 最终会以"success"状态结束。使用回调或原生 Promise 很容易意外产生半同步代码，但使用 async 则很难出现这种情况。

请注意，如果从 async 函数返回 Promise，它不会被再次包装：返回类型将是 Promise<T> 而非 Promise<Promise<T>>。TypeScript 会帮助你建立这方面的直觉：

```ts
async function getJSON(url: string) {
  const response = await fetch(url);
  const jsonPromise = response.json();
  return jsonPromise; // ^? const jsonPromise: Promise<any>
}
getJSON;
// ^? function getJSON(url: string): Promise<any>
```

### 要点备忘

- 优先使用 Promise 而非回调，以获得更好的可组合性和类型流。
- 尽可能优先使用 async 和 await 而非原始 Promise。它们能生成更简洁直观的代码，并消除整类错误。
- 若函数返回 Promise，应将其声明为 async。

## 条款 28：运用类与柯里化创建新的推断点

假设你使用 TypeScript 接口定义了一个 API：

```ts
export interface SeedAPI {
  "/seeds": Seed[];
  "/seed/apple": Seed;
  "/seed/strawberry": Seed;
  // ...
}
```

这表明我们的 API 有一个/seeds 端点，它会返回一个 Seed 对象数组。而/seed/apple 和/seed/strawberry 这两个端点则各自返回一个

Seed 对象。

让我们编写一个向 API 端点发起请求的函数。该函数需要验证端点是否存在，并确保返回正确类型的数据。这对于从客户端发起安全的 API 调用将极为有用。

以下是该函数的具体实现逻辑：

```ts
// Correct usage:
const berry = await fetchAPI<SeedAPI>("/seed/strawberry"); // OK, returns Sed
// Incorrect usage; these should be errors:
fetchAPI<SeedAPI>("/seed/chicken"); // endpoint doesn't exist
const seed: Seed = await fetchAPI<SeedAPI>("/seeds"); // wrong return type
```

以下是声明 fetchAPI 的方式（我们这里不关心具体实现，只关注类型）：

```ts
declare function fetchAPI<API, Path extends keyof API>(
  path: Path
): Promise<API[Path]>;
```

遗憾的是，当你尝试使用时会出现错误：

```ts
fetchAPI<SeedAPI>("/seed/strawberry");
// Expected 2 type arguments, but got 1.
```

问题在于 TypeScript 的类型推断是非此即彼的：要么让 TypeScript 根据用法推断所有类型参数，要么显式指定所有参数。不存在中间状态（虽然可以为类型参数设置默认值，但默认值只能引用其他类型参数，无法从用法中推断）。

API 类型参数可以是任意值：由于我们希望 fetchAPI 能适配任何 API，因此它无法被自动推断，必须显式声明。所以看起来唯一的解决方案就是同时显式声明 Path 类型：

```ts
const berry = fetchAPI<SeedAPI, "/seed/strawberry">("/seed/strawberry"); // ok
// ^? const berry: Promise<Seed>
```

这样虽然可行，但重复操作令人沮丧。肯定有更好的方法。我们需要将显式编写 API 类型参数的位置与推断 Path 类型参数的位置分离开来。

有两种标准方法可以实现这一点：类和柯里化。

### 类

类非常擅长封装状态片段。它们能避免你反复向一组相关函数（类的方法）传递相同状态。在 TypeScript 中，类同样非常擅长封装类型。

以下是定义一个类来解决此问题的方法：

```ts
declare class ApiFetcher<API> {
  fetch<Path extends keyof API>(path: Path): Promise<API[Path]>;
}
```

以下是使用该类的示例：

```ts
const fetcher = new ApiFetcher<SeedAPI>();
const berry = await fetcher.fetch("/seed/strawberry"); // OK
// ^? const berry: Seed
fetcher.fetch("/seed/chicken");
//
// Argument of type '"/seed/chicken"' is not assignable to type 'keyof SeedAPI'
const seed: Seed = await fetcher.fetch("/seeds");
// \~\~\~\~ Seed[] is not assignable to Seed
```

这正好产生了我们期望的错误类型。（当然，你还需要实现这个类！我们这里只关注类型部分。）

原本需要两个泛型类型参数的函数，现在变成了一个显式指定单个泛型参数的类，以及一个自动推断泛型参数的方法。TypeScript 非常乐意让你在调用类构造函数时绑定 API 类型参数（如 new ApiFetcher<API>()），然后在调用 fetch 方法时自动推断 Path 参数。

使用类创建独立的绑定站点特别有效，尤其当你有多个方法都需要相同类型参数时。

### 柯里化

有趣的事实：编程语言实际上并不需要多参数的函数。与其这样：

```ts
declare function getDate(mon: string, day: number): Date;
getDate("dec", 25);
```

你可以编写一个返回另一个函数的函数：

```ts
declare function getDate(mon: string): (day: number) => Date;
getDate("dec")(25);
```

注意调用第二个版本时略有不同的语法。这种操作被称为柯里化（currying），得名于逻辑学家哈斯凯尔·柯里，尽管他始终否认自己是这种技术的发明者。

柯里化赋予我们所需的灵活性，可以按需引入任意数量的推断点。每个函数调用都能推断出新的类型参数。

以下是使用返回函数的函数来重构 fetchAPI 的方法：

```ts
declare function fetchAPI<API>(): <Path extends keyof API>(
  path: Path
) => Promise<API[Path]>;
```

现在 fetchAPI 不接收参数，但会返回一个接收单个参数的函数。具体用法如下：

```ts
const berry = await fetchAPI<SeedAPI>()("/seed/strawberry"); // OK // ^? const berry: Seed
fetchAPI<SeedAPI>()("/seed/chicken");
//
// Argument of type '"/seed/chicken"' is not assignable to type 'keyof SeedAPI'
//
const seed: Seed = await fetchAPI<SeedAPI>()("/seeds");
// \~\~\~\~ Seed[] is not assignable to Seed
```

就像类解决方案一样，这种方法在我们需要时有效，并在其他情况下产生预期的错误。你可以使用中间变量来分离两个函数调用以减少重复：

```ts
const fetchSeedAPI = fetchAPI<SeedAPI>();
const berry = await fetchSeedAPI("/seed/strawberry"); // ^? const berry: Seed
```

柯里化方法与类方法的差异并不像最初看起来那么明显。如果使用不同的名称并返回对象类型而非函数，它们看起来几乎完全相同：

```ts
declare function apiFetcher<API>(): {
  fetch<Path extends keyof API>(path: Path): Promise<API[Path]>;
};
const fetcher = apiFetcher<SeedAPI>();
fetcher.fetch("/seed/strawberry"); // OK
```

这种用法与类示例的唯一区别在于关键字 new。

如果你想显式指定某些泛型参数，同时允许其他参数被推断，类和柯里化是你的两个选择。

那么你该选择哪种方式呢？最终决定权在你手中。选择让你感觉最顺手、能产出最便利 API 的方式即可。不过柯里化方法在 TypeScript 环境下至少有一个优势：它能创建一个用于定义局部类型别名的作用域：

```ts
function fetchAPI<API>() {
  type Routes = keyof API & string; // local type alias
  return <Path extends Routes>(path: Path): Promise<API[Path]> =>
    fetch(path).then((r) => r.json());
}
```

仅靠声明无法实现这一点：只有实现部分才会引入新的作用域。像 Routes 这样的局部类型别名可以减少涉及复杂类型表达式时的重复代码。类语法中不存在等效功能。

### 要点备忘

- 对于具有多个类型参数的函数，类型推断是全有或全无的：要么所有类型参数都被推断出来，要么必须全部显式指定。
- 要实现部分类型推断，可以使用类或柯里化方法来创建新的推断点。
- 若需创建局部类型别名，建议采用柯里化方法。
