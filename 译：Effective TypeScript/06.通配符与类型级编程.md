# 第 6 章 通配符与类型级编程

TypeScript 的类型系统旨在模拟 JavaScript 代码的运行时行为。由于 JavaScript 非常动态且宽容，这促使 TypeScript 的类型系统发展出越来越强大的功能。如第 15 项所述，这包括类型间的映射逻辑。

当你将泛型类型别名加入其中时，TypeScript 的类型系统变得足够强大，以至于你可以将其视为一种独立的编程语言。（TypeScript 的类型系统是图灵完备的，因此从形式上来说这是正确的。）与你在 JavaScript 中使用值编程不同，现在你是在使用类型编程，换句话说，是类型层面的编程。这与元编程（编写操作程序的程序）不同，尽管这两个术语有时会被混淆。

学习新语言很有趣，你可以使用 TypeScript 的类型系统构建各种各样的应用程序，从游戏到 SQL 解析器。这在一定程度上是由 Type Challenges 项目推动的，该项目包括数百个越来越难的类型系统难题。在阅读本章时解决这些难题是巩固你所学知识的好方法。

本章还包括一些警告性注释。TypeScript 包含一种类型编程语言，并不意味着它是一个特别直观、使用方便或令人愉快的语言。类型级别编写逻辑并不意味着总是个好主意。过度使用泛型会导致代码晦涩难懂且难以维护。Josh Goldberg 在《Learning TypeScript》（O’Reilly）中很好地表达了这一点：

尽管泛型可以给我们很大的灵活性来描述代码中的类型，但它们很快就会变得相当复杂。初学 TypeScript 的程序员往往会过度使用泛型，导致代码变得难以阅读且过于复杂。通常来说，TypeScript 的最佳实践是仅在必要时使用泛型，并在使用时明确说明其用途。

本章将帮助你决定是否有必要使用泛型类型，并提供一些替代方案。使用得当，类型级别的代码可以改善其他开发者的体验，而他们甚至不需要知道其中涉及了复杂的类型级别代码。

# 第 50 条：将泛型视为类型间的函数

第 15 项展示了如何使用类型操作（extends、映射类型、索引、keyof）来减少相关类型之间的重复。在值的世界里，函数是提取重复代码的关键方式。在类型的世界里，函数的等价物是泛型类型。泛型类型接受一个或多个类型参数，并生成一个具体的、非泛型类型。你“调用”一个函数，而“实例化”一个泛型类型。

内置的 Partial 泛型类型使另一个类型的所有属性都成为可选的。你可以这样自己定义它：

```ts
type MyPartial<T> = { [K in keyof T]?: T[K] };
```

这里的 T 是类型参数。你可以看到，这与内置的 Partial 类型完全相同：

```ts
interface Person {
  name: string;
  age: number;
}

type MyPartPerson = MyPartial<Person>;
// ^? type MyPartPerson = { name?: string; age?: number; }
type PartPerson = Partial<Person>;
// ^? type PartPerson = { name?: string; age?: number; }
```

通过定义这个泛型类型，我们封装了将另一个类型的所有属性变为可选所需的类型级操作。这与函数封装将一个值转换为另一个值的逻辑完全类似。你不需要知道 Math.cos 是如何实现的，只需要知道它计算一个数的余弦值即可。

你可以编写接受多个类型参数的泛型类型。以下是如何定义内置 Pick 泛型的等价类型：

```ts
type MyPick<T, K> = {
  [P in K]: T[P];
  // Type 'K' is not assignable to type 'string | number |  symbol'.
  // \~\~ Type 'P' cannot be used to index type 'T'.
};
```

即使你在类型级别编程，TypeScript 也会应用所有相同的静态分析工具来检查代码中的可赋值性和其他错误。在这里，它发现了两个问题：

- 我们在遍历 K，但 TypeScript 没有理由相信 K 包含可以作为属性键使用的类型，即 string、number 或 symbol。
- 即使它是有效的属性键，TypeScript 也没有理由相信 P 可以用来索引 T。T 可能不是对象类型，也可能没有那个键。

处理类型级错误的方法有很多，就像在非泛型代码中处理类型错误的方法有很多一样。最简单的方法之一就是忽略它们。这竟然效果很好！

```ts
// @ts-expect-error (don't do this)
type MyPick<T, K> = { [P in K]: T[P] };

type AgeOnly = MyPick<Person, 'age'>;
// ^? type AgeOnly = { age: number; }
```

你可以将其视为类型级等效于 TypeScript 即使在存在类型错误的情况下也会生成 JavaScript（第 3 项）。仅仅因为 TypeScript 不喜欢你实现的泛型类型，并不意味着它不会让你使用它。

当然，TypeScript 抱怨是正确的。这个版本的 MyPick 非常容易出错：

```ts
type FirstNameOnly = MyPick<Person, 'firstName'>;
// ^? type FirstNameOnly = { firstName: unknown; }
type Flip = MyPick<'age', Person>;
// ^? type Flip = {}
```

与其得到类型错误，MyPick 的错误用法只是返回错误的类型。几乎就像在 JavaScript 中编程一样！

另一种让错误消失的方法是添加与 TypeScript 预期类型相交的类型。这看起来是这样的：

```ts
type MyPick<T, K> = { [P in K & PropertyKey]: T[P & keyof T] };
type AgeOnly = MyPick<Person, 'age'>;
// ^? type AgeOnly = { age: number; }
type FirstNameOnly = MyPick<Person, 'firstName'>;
// ^? type FirstNameOnly = { firstName: never; }
```

PropertyKey 是内置的别名，表示 string | number | symbol。你可以将这种相交类型视为类型级别的 as any。它已经消除了实现中的类型错误，并且保留了正确的用法不变。不正确的用法会有所不同，这或许是一种改进：never 经常表明有错误发生。

但保持这种类比，as any 在值层面很少是正确的选择，而在类型层面，这些相交类型通常也不是最佳选择。你通常通过让函数接受更窄的参数类型来解决类型错误，而这正是我们在这里想要做的。你可以使用 extends 关键字对类型参数添加约束：

```ts
type MyPick<T extends object, K extends keyof T> = { [P in K]: T[P] };
type AgeOnly = MyPick<Person, 'age'>;
// ^? type AgeOnly = { age: number; }
type FirstNameOnly = MyPick<Person, 'firstName'>;
//
// Type '"firstName"' does not satisfy the constraint 'keyof Person'.
type Flip = MyPick<'age', Person>;
// Type 'string' does not satisfy the constraint 'object'.
```

通过将 T 约束为对象类型，并将 K 约束为 T 的键的子类型，我们同时解决了两个问题：消除了实现中的类型错误，并在 MyPick 的无效实例化中产生了类型错误。

当没有设置 noImplicitAny 时，TypeScript 要求你为所有函数参数提供类型注解。类型参数没有类似的功能。如果你不指定约束，默认值为 unknown，这允许用户传递任何类型的值。当你定义一个泛型类型时，考虑是否要给用户提供较少的自由度和更多的安全性。

当你编写一个函数时，你可以选择描述性的参数名称并编写 TSDoc 注释（第 68 条）。你也应该为泛型类型做同样的事情。有一种惯例是使用单字母名称作为类型参数名称（如本条目所示），但在类型级别代码中，你应该像对待单字母变量名称一样谨慎对待这些名称。

命名的一般原则是名称的长度应与其作用域相匹配。长期存在的全局变量应有长且描述性的名称，而像 i、k 或 v 这样的短名称实际上可以在作用域有限的简洁箭头函数中提高可读性。对于一个简短的泛型 MyPick，

T 和 K 没问题。但对于类型参数范围更广的长定义（比如泛型类），使用一个更长且更具意义的名字可以提高清晰度。

你可以为泛型类型编写 TSDoc，TypeScript 语言服务会在相关情况下将其显示出来，就像它会为函数显示 TSDoc 一样。类型级别的 @param 等价物是 @template:1

```ts
/**
 * Construct a new object type using a subset of the properties of another one
 * (same as the built-in `Pick` type).
 * @template T The original object type
 * @template K The keys to pick, typically a union of string literal types.
 */
type MyPick<T extends object, K extends keyof T> = { [P in K]: T[P] };
```

如果你在实例化位置检查 MyPick，你会得到完整的文档。而在定义中将鼠标悬停在 T 或 K 上时，你会看到该类型参数的文档（图 6-1）。

![](https://cdn-mineru.openxlab.org.cn/extract/502cbe09-f625-4c65-a0d4-26b025d9b0ff/e5d4a041c12dde2942a60420c23a8c3c5b802e0056e52c68388bbfafae523c51.jpg)
图 6-1. 可以使用 @templateTSDoc 标签来文档化类型参数。

TypeScript 类型最好被视为值的集合（Item 7），因此泛型类型本质上是操作集合。这与 JavaScript 函数不同，在 JavaScript 函数中，你知道每次调用函数时每个参数都将只有一个值。实际上这意味着你总是需要考虑泛型类型在联合类型中的行为。Item 53 展示了如何做到这一点。

你为你的值级代码编写了测试，那类型级代码呢？你绝对应该测试你的类型！这是一个有趣且足够深入的话题，值得单独讨论。请参阅 Item 55。

你还可以为一些值级构造，如函数和类，添加类型参数。例如，我们可以为 Pick 泛型类型添加一个相应的 pick 函数：

```ts
function pick<T extends object, K extends keyof T>(
  obj: T,
  ...keys: K[]
): Pick<T, K> {
  const picked: Partial<Pick<T, K>> = {};
  for (const k of keys) {
    picked[k] = obj[k];
  }
  return picked as Pick<T, K>;
}
const p: Person = { name: 'Matilda', age: 5.5 };
const age = pick(p, 'age');
// ^? const age: Pick<Person, "age">
console.log(age); // logs { age: 5.5 }
```

仅仅从类型的角度来看，忽略括号中的内容，这看起来很像之前定义的 MyPick 类型：

```ts
type P = typeof pick;
// ^? type P = <T extends object, K extends keyof T>(
// obj: T, ...keys: K[]
// ) => Pick<T, K>
```

你可以将泛型函数概念性地理解为定义了一个关联的泛型类型。然而，泛型函数的魅力在于，当函数被调用时，TypeScript 可以从传入的值中推断出类型参数。在之前的例子中，我们只是写了 \`pick(p, 'age')\`。这比显式写出类型（并且产生完全相同的结果）要简洁得多：

```ts
const age = pick<Person, 'age'>(p, 'age'); // ^? const age: Pick<Person, "age">
```

另一个优势是，使用你的 \`pick\` 函数的用户完全不需要知道他们正在处理泛型类型或类型级操作。他们只需享受准确、精确的类型即可。年龄的类型是一个提示，表明有类型级编程在起作用，但如果你愿意，这个提示也可以隐藏起来。第 56 项展示了如何做到这一点。

类也可以接受类型参数，这些参数也可以从使用中推断出来：

```ts
class Box<T> {
  value: T;
  constructor(value: T) {
    this.value = value;
  }
}
const dateBox = new Box(new Date());
// ^? const dateBox: Box<Date>
```

回想第 8 项的内容，类是 TypeScript 中少数几个同时引入类型和值的构造之一。对于一个泛型类，它引入了一个泛型类型，将类型参数（T）与该类的属性和方法关联起来。

正如类擅长于捕获那些你需要自己跟踪的相关状态一样，泛型类也是一种捕获类型的好方法。泛型类的类型参数在构造时设置，当你调用其方法时不需要再传递这些类型参数（尽管它的方法可以有自己的类型参数）。第 28 项探讨了如何利用这一点来获得更精细的类型推断控制。

在值的世界里，你可以编写像 map、filter 和 reduce 这样的“高阶函数”，这些函数可以接受其他函数作为参数。这给你带来了巨大的灵活性，可以提取出共享的行为。在类型层面，有没有类似的东西？

到本文写作时为止，答案是否定的。这些被称为“函数的函数的类型”或“高阶类型”，通常被称为“高阶类型”。

它们将允许你提取出常见的操作，比如将一个泛型类型应用到对象中的值类型：

```ts
type MapValues<T extends object, F> = {
  [K in keyof T]: F<T[K]>;
  // Type 'F' is not generic.
};
```

好消息是，这并不限制你可以使用泛型类型做什么。它只是限制了你表达的方式。在这种情况下，你需要使用映射类型而不是 MapValues。同样，不存在匿名泛型类型。

泛型类型最好被视为类型之间的函数。在编写它们时，请牢记这一点。你现在正在处理类型级别，这既令人兴奋又新鲜。但你仍然在编码，你之前学习的所有编写值级别代码的最佳实践仍然适用。

### 注意事项

- 将泛型类型视为类型之间的函数。
- 使用 extends 限制类型参数的领域，就像使用类型注解来限制函数参数一样。
- 选择类型参数名称以提高代码的可读性，并为其编写 TSDoc。
- 将泛型函数和类视为有助于类型推断的概念性定义。

## 第 51 条：避免不必要的类型参数

这是官方 TypeScript 手册对泛型函数的描述：

编写泛型函数很有趣，但过多地使用类型参数可能会适得其反。如果类型参数过多或在不需要的地方使用约束，可能会导致类型推断不成功，让调用该函数的人感到沮丧。

它还提供了一些关于如何使用泛型的具体建议，其中包括一个有时被称为“泛型的金科玉律”的建议：

类型参数应出现两次

类型参数用于关联多个值的类型。如果类型参数在函数签名中只出现一次，那么它并没有起到关联任何类型的作用。

### 规则：如果类型参数只出现一次，强烈考虑是否真的需要它。

此规则为您提供了一种具体的方法来判断任何类型参数是好是坏，但有时并不明显如何应用它，而且它并不能提供很多关于如何重写代码的指导，特别是当你使用泛型不当的时候。在本项中，我们将通过一些泛型使用的好坏示例来说明该规则是如何工作的，并重新编写那些不好的示例。

让我们从恒等函数开始：

```ts
function identity<T>(arg: T): T {
  return arg;
}
```

此函数接受一个单一参数并返回它，不改变其类型。你可以这样使用它：

```ts
const date = identity(new Date());
// ^? const date: Date
const nums = [1, 2, 3];
// ^? const nums: number[]
const numsCopy = nums.map(identity);
// ^? const numsCopy: number[]
```

这个函数在实际中可能很有用，如果你需要传递一个回调函数但又不想改变你的数据。从金规则的角度考虑，这是好的泛型使用还是不好的泛型使用？在这个例子中，类型参数 T 在声明后出现了两次：

```ts
function identity<T>(arg: T): T {
  // (decl.) 1 2
  return arg;
}
```

所以这个通过了测试，是泛型的良好使用。而且这是合理的：因为它说明了输入参数的类型和函数的返回类型是相同的。

那这个呢？

```ts
function third<A, B, C>(a: A, b: B, c: C): C {
  return c;
}
```

类型参数 C 出现了两次，所以没问题。但是 A 和 B 只出现了一次（除了在它们的声明中），所以这个函数没有通过测试。你可以用一个类型参数来重写它：

```ts
function third<C>(a: unknown, b: unknown, c: C): C {
  return c;
}
```

这是一个解析 YAML 的函数类型声明：

```ts
declare function parseYAML<T>(input: string): T;
```

这是一个泛型的使用是好是坏的例子？类型参数 T 只出现了一次，所以这一定是不好的使用。如何修复？这取决于你的目标。所谓的“仅返回的泛型”是危险的，因为它们等同于类型断言（第 9 条），但没有使用 as 关键字：

```ts
interface Weight {
  pounds: number;
  ounces: number;
}
const w: Weight = parseYAML('');
```

乍一看，这段代码看起来是安全的，因为它没有类型断言或任何类型。但这是一种错觉。你可以用任何其他类型替换 Weight，这段代码仍然可以类型检查。为类型参数设置默认值也不会改变这一点：

```ts
declare function parseYAML<T = null>(input: string): T;
const w: Weight = parseYAML(''); // till allowed
```

更好的做法是让这个函数返回 unknown（参见第 46 条关于 unknown 类型的复习）：

```ts
declare function parseYAML(input: string): unknown;
```

这将迫使调用该函数的用户对结果进行类型断言：

```ts
const w = parseYAML('') as Weight;
```

这实际上是一件好事，因为它迫使你在进行不安全的类型断言时要明确说明。这里没有任何类型安全的幻觉！2

那这个呢？

```ts
function printProperty<T, K extends keyof T>(obj: T, key: K) {
  console.log(obj[key]);
}
```

由于 K 只出现一次，这是一次不好的泛型使用（T 没问题，因为它既作为参数类型出现，又作为 K 的约束条件）。通过将 keyof T 移动到参数类型并消除 K 来修复它：

```ts
function printProperty<T>(obj: T, key: keyof T) {
  console.log(obj[key]);
}
```

这个函数看起来表面相似：

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}
```

然而，这个函数实际上很好地使用了泛型。要理解为什么，我们需要看看该函数推断出的返回类型。如果你在编辑器中检查 getProperty，你会发现它的返回类型是 T\[K\]。这意味着该签名等同于：

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```

所以 K 确实出现了两次！这是一个很好的泛型使用案例：K 与 T 有关，返回类型与 K 和 T 都有关。

那对于一个类呢？

```ts
class ClassyArray<T> {
  arr: T[];
  constructor(arr: T[]) {
    this.arr = arr;
  }
  get(): T[] {
    return this.arr;
  }
  add(item: T) {
    this.arr.push(item);
  }
  remove(item: T) {
    this.arr = this.arr.filter((el) => el !== item);
  }
}
```

这种情况是可以接受的，因为 T 在实现中出现了多次（我数了数有 5 次）。当你实例化一个 ClassyArray 时，会绑定类型参数，并且这会关联类的所有属性和方法的类型。（这在创建推断点时很有用，就像我们在第 28 项中看到的那样。）

而这个类则未能通过测试：

```ts
class Joiner<T extends string | number> {
  join(els: T[]) {
    return els.map((el) => String(el)).join(',');
  }
}
```

首先，T 只适用于 join 方法，因此它可以移到方法上，而不是类上：

```ts
class Joiner {
  join<T extends string | number>(els: T[]) {
    return els.map((el) => String(el)).join(',');
  }
}
```

通过将 T 的声明移近其使用位置，我们使得 TypeScript 能够推断出 T 的类型。通常来说，这是你想要的结果！但在这种情况下，由于 T 只出现了一次，你应该将其声明为非泛型：

```ts
class Joiner {
  join(els: (string | number)[]) {
    return els.map((el) => String(el)).join(',');
  }
}
```

最后，为什么这需要是一个类呢？这类包装类在 Java 中很常见（Java 不支持独立函数），但在 JavaScript 中却是多余的。3 直接把它做成独立函数即可：

```ts
function join(els: (string | number)[]) {
  return els.map((el) => String(el)).join(',');
}
```

那这个用于获取任何类数组对象长度的函数怎么样？

```ts
interface Lengthy {
  length: number;
}
function getLength<T extends Lengthy>(x: T) {
  return x.length;
}
```

由于 T 只在其定义后出现一次，这种泛型的使用是不好的。它可以写成：

```ts
function getLength(x: Lengthy) {
  return x.length;
}
```

或者甚至可以写成：

```ts
function getLength(x: { length: number }) {
  return x.length;
}
```

或者，由于 TypeScript 内置了 ArrayLike 类型：

```ts
function getLength(x: ArrayLike<unknown>) {
  return x.length;
}
```

每条规则都有例外，这条规则也不例外吗？确实有一些罕见的情况，额外的类型参数可以帮助你正确实现。例如，这个函数中的两个类型参数都是不好的：

```ts
declare function processUnrelatedTypes<A, B>(a: A, b: B): void;
```

修复的方法是这样重写：

```ts
declare function processUnrelatedTypes(a: unknown, b: unknown): void;
```

然而，这会对函数的实现产生影响。在第一个声明中，a 和 b 在函数体中是不可互赋的。

函数的定义为：

```ts
function processUnrelatedTypes<A, B>(a: A, b: B) {
  a = b;
  // \~ Type 'B' is not assignable to type 'A'.
  b = a;
  // \~ Type 'A' is not assignable to type 'B'.
}
```

改进后的类型签名如下：

```ts
function processUnrelatedTypes(a: unknown, b: unknown) {
  a = b; // Ok
  b = a; // ok;
}
```

一种变通方法是使用单一的重载函数来为调用者和实现创建不同的类型签名。第 52 项展示了这种做法的具体情况。然而，一般来说，这种情况下比较罕见，你应该避免仅出现一次的泛型类型参数。

到目前为止，你应该对如何应用泛型的黄金法则以及如何修复违反该规则的声明有了很好的理解。当你阅读和编写泛型函数时，想想它们是否遵循这条规则！如果一个函数或类不需要是泛型的，那么如果不使用泛型，它会更容易理解和维护。

换句话说，泛型的第一个规则是“不要使用”。

### 注意事项

- 避免向不需要它们的函数和类添加类型参数。
- 由于类型参数关联类型，因此每个类型参数必须出现两次或两次以上以建立关系。
- 记住，类型参数可能出现在推断类型中。
- 避免“仅用于返回的泛型”。
- 不必要的类型参数通常可以用未知类型替换。

# 第 52 项 优先使用条件类型而非重载签名

你会如何为这个 JavaScript 函数编写类型声明？

```ts
function double(x) {
  return x + x;
}
```

\`double\` 可以接受字符串或数字。因此，你可以使用联合类型：

```ts
declare function double(x: string | number): string | number;
```

虽然这个声明是准确的，但它有些不够精确：

```ts
const num = double(12); // ^? const num: string | number
const str = double('x'); // ^? const str: string | number
```

当 double 接收一个数字时，它返回一个数字；当它接收一个字符串时，它返回一个字符串。这个声明忽略了这种细微差别，会导致不方便处理的类型。

你可能会通过使函数泛型来捕捉这种关系：

```ts
declare function double<T extends string | number>(x: T): T;
const num = double(12);
// ^? const num: 12
const str = double('x');
// ^? const str: "x"
```

可惜，在追求精确的过程中我们有些过头了。现在这些类型有些过于精确。当 double 接收一个字符串类型时，它会返回一个字符串类型，这是正确的。但当它接收一个字符串字面量类型时，返回类型仍然是相同的字符串字面量类型。这是错误的：将 'x' 乘以 2 应该得到 'xx'，而不是 'x'。如第 40 项所述，不精确的类型比不准确的类型更好，所以这是一个错误的方向。我们如何做得更好？

另一个选项是提供多个类型声明，也被称为“重载签名”（参见第 3 项以作复习）。虽然 JavaScript 只允许你为一个函数编写一种实现方式，但 TypeScript 允许你编写任意数量的类型签名。你可以利用这一点来改进 double 的类型：

```ts
declare function double(x: number): number;
declare function double(x: string): string;
const num = double(12);
// ^? const num: number
const str = double('x');
// ^? const str: string
```

这是一个进步！但仍然存在一个细微的 bug。这种类型声明可以处理字符串或数字值，但不能处理既可以是字符串又可以是数字的值：

```ts
function f(x: string | number) {
  return double(x);
  // \~ Argument of type 'string | number' is not assignable
  // to parameter of type 'string'
}
```

这个 double 的调用是安全的，应该返回 string|number。当你提供重载签名时，TypeScript 会依次处理它们，直到找到匹配项。你看到的错误是因为最后一个重载（字符串版本）失败了，因为 string|number 不能赋值给 string。

虽然你可以通过添加一个 string|number 的第三种重载来修复这个问题，但更好的解决方案是使用条件类型。条件类型就像类型空间中的 if 语句（条件语句）。它们非常适合这种需要覆盖几种可能性的情况：

```ts
declare function double<T extends string | number>(
  x: T
): T extends string ? string : number;
```

这与使用泛型函数尝试输入双精度浮点数的第一次尝试类似，但返回类型更为复杂。你可以像读取 JavaScript 中的三元运算符（?:）一样读取条件类型：

- 如果 T 是 string 的子类型（即 string、字符串字面量、字符串字面量的联合类型或模板字面量类型），则返回类型为 string。
- 否则返回数字。

有了这个声明，我们所有的示例都能正常工作：

```ts
const num = double(12);
// ^? const num: number
const str = double('x');
// ^? const str: string
function f(x: string | number) {
  // ^? function f(x: string | number): string | number
  return double(x); // Ok
}
```

字符串或数字的示例之所以有效，是因为条件类型会分配给联合类型。当 T 为 string|number 时，TypeScript 会将条件类型解析为以下内容：

> (string | number) extends string ? string : number → (string extends string ? string : number) | (number extends string ? string : number) → string | number

条件类型在联合类型上分布的方式是 TypeScript 类型系统设计的一部分。这并不是必须如此，但在许多情况下（例如这种情况），这种行为是正确的并且极其方便。

虽然使用重载签名进行类型声明更简单，但使用条件类型版本更为正确，因为它可以推广到各个情况的联合类型。这种情况在重载签名中很常见。虽然重载是独立处理的，但类型检查器可以将条件类型视为单一表达式，并将其分布在联合类型中。

每当编写条件类型时，你应该考虑它是否应该分布在联合类型上。通常情况下是这样，但并不总是如此。第 53 项介绍了分布不正确的情况，并展示了如何获得对其的控制权。

是否有些情况下你应该优先使用重载？如果联合类型的情况不合理，或者你的函数实际上更像是两个或多个完全不同的函数，具有完全不同的签名，那么处理这种情况可能不值得，保持这些不同的重载函数独立会使代码更易读。

不过，如果你发现自己处于这种情况，可以考虑是否两个不同的函数会更清晰。例如，Node 标准库提供了基于回调和 Promise 的文件系统函数版本，如 readFile。这可以是一个根据参数行为不同的单一函数。但通常你事先就知道是使用回调还是 Promise，因此有两个独立的函数会更清晰和简单。

由于这一章是关于类型级编程的，我们完全集中在类型上。但值得简要讨论一下如何实现重载函数和返回条件类型函数。这通常会显得有些笨拙，并且需要在函数体中使用类型断言。TypeScript 无法为变量推断出条件类型。

一种策略是定义一个单一的重载，向调用者呈现不同的类型签名，而在实现函数时使用不同的类型。例如：

```ts
function double<T extends string | number>(
  x: T
): T extends string ? string : number;
function double(x: string | number): string | number {
  return typeof x === 'string' ? x + x : x + x;
}
```

在这里，我们使用条件类型作为对外可见的 API，但在实现时使用更简单的类型。（typeof 检查看起来有些奇怪，但省去了类型断言。）TypeScript 会检查两种签名是否兼容，但无法做到完美。因此，测试你的类型仍然很重要，如第 55 项所述。

### 注意事项

- 优先使用条件类型而不是重载类型签名。通过在联合类型上进行分发，条件类型允许你的声明支持联合类型而无需额外的重载。
- 如果联合模式不合理，可以考虑将函数拆分为具有不同名称的两个或多个函数，从而使函数更清晰。
- 考虑使用单个重载策略来实现使用条件类型声明的函数。

## 第 53 项：了解如何控制联合在条件类型中的分布

第 52 项探讨了条件类型在联合中的分布方式，以及这如何有助于双函数的类型定义：

```ts
declare function double<T extends number | string>(
  x: T
): T extends string ? string : number;
const num = double(12);

// ^? const num: number
const str = double('x'); // ^? const str: string
declare let numOrStr: number | string;
const either = double(numOrStr); // ^? const either: number | string
```

在这种情况下，对联合类型的分布产生了预期的结果。但这通常并不总是如此。

为了看到一个分布不 desirable 的例子，我们定义一个 isLessThan 函数，用于判断其第一个参数是否小于第二个参数。我们希望它能够处理日期、数字和字符串。为了方便起见，如果我们以日期作为第一个参数，我们希望允许以自纪元以来的毫秒数作为第二个参数。

你可以使用条件类型来建模这一点：

```ts
type Comparable<T> = T extends Date
  ? Date | number
  : T extends number
  ? number
  : T extends string
  ? string
  : never;
declare function isLessThan<T>(a: T, b: Comparable<T>): boolean;
```

这似乎允许和禁止了我们预期的组合：

```ts
isLessThan(new Date(), new Date()); // ok
isLessThan(new Date(), Date.now()); // ok, Date/number comparison allowed
isLessThan(12, 23); // ok
isLessThan('A', 'B'); // Ok
isLessThan(12, 'B');
// \~\~\~ Argument of type 'string' is not assignable to parameter
// of type 'number'.
```

由于它的写法，Comparable 操作符会分布在联合类型上。这是否是理想的？显然不是：

```ts
let dateOrStr = Math.random() < 0.5 ? new Date() : 'A';
// ^? let dateOrStr: Date | string
isLessThan(dateOrStr, 'B');
// ok, but should be an error
```

第二个参数应该是这两个可能性的交集，而不是联合。而且，(Date | number) & string 永远不会匹配，因此这个调用根本不应该被允许。

我们如何防止这种分布？只有当条件是裸类型（T extends ...）时，联合类型才会分布在条件类型上。所以为了防止这种分布，我们需要稍微复杂化一下表达式。标准的做法是将 T 包装在一个元素的元组类型中，即 \[T\]：

```ts
type Comparable<T> = [T] extends [Date]
  ? Date | number
  : [T] extends [number]
  ? number
  : [T] extends [string]
  ? string
  : never;
```

类型 \[A\] 可以赋值给 \[B\] 当且仅当 A 可以赋值给 B。所以表面上看，这个更改似乎不会影响 Comparable 的行为。但由于 \[T\] 不是裸类型，联合类型不再分布在 Comparable 上，我们就能得到期望的错误提示，而不会破坏其他有效的调用：

```ts
isLessThan(new Date(), new Date()); // ok
isLessThan(new Date(), Date.now()); // ok, Date/number comparison allowed
isLessThan(12, 23); // ok
isLessThan('A', 'B'); // ok
isLessThan(12, 'B');
// \~ Argument of type 'string' is not assignable to parameter
// of type 'number'.
isLessThan(dateOrStr, 'B');
// \~ Argument of type 'string' is not assignable to
// parameter of type 'never'.
```

有时情况会反过来，你有一个条件类型无法分布，但你希望它能分布。这种情况通常是因为泛型类型实现方式的意外结果。

为了看看这种情况是如何发生的，我们来实现一个泛型类型 NTuple<T, N>，它生成一个包含 N 个元素的元组，所有元素的类型为 T。这比我们之前见过的类型复杂一些，但我们可以通过逐步分析来理解它。这里有一种使用累加器的方法来实现它：

```ts
type NTuple<T, N extends number> = NTupleHelp<T, N, []>;
type NTupleHelp<T, N extends number, Acc extends T[]> = Acc['length'] extends N
  ? Acc
  : NTupleHelp<T, N, [T, ...Acc]>;
```

这里的诀窍是不断向元组类型中添加元素，直到其长度属性与我们想要的长度匹配。请记住，这个查找是在类型系统中进行的。对于数组类型，查找 'length' 会返回 number 类型，但对于元组类型，它会返回一个更精确的数字字面量类型，如 0, 1, 2 等。

这个泛型类型在 N 是单个数字时按我们希望的方式工作，用于构建 N 元组：

```ts
type PairOfStrings = NTuple<string, 2>; // ^? type PairOfStrings = [string, string]
type TripleOfNumbers = NTuple<number, 3>; // ^? type TripleOfNumbers = [number, number, number]
```

但当 N 是联合类型时，它并不会如我们所愿地工作：

```ts
type PairOrTriple = NTuple<bigint, 2 | 3>; // ^? type PairOrTriple = [bigint, bigint]
```

正确的结果应该是 \[bigint, bigint\] | \[bigint, bigint, bigint\]。更直接的问题是，一旦累加器变成一个元组，Acc\['length'\] 扩展 2 | 3 就会立即变为真。但更深层次的问题是，我们的条件类型没有正确地分配到联合类型上。我们希望它能做到这一点。为什么它做不到，我们又该如何修复它？

问题在于条件是 Acc\['length'\] extends N，这并没有以所需的“N extends...”形式开始，这是分配的关键。因此，最简单的修复方法是添加一个额外的条件类型，看起来像这样：

```ts
type NTuple<T, N extends number> = N extends number
  ? NTupleHelp<T, N, []>
  : never;
```

由于 N 被限制为扩展 number，这个条件总是会评估为真（你也可以让它成为 N extends any 或 N extends unknown）。它的唯一目的是添加一个以正确形式进行分配的条件类型。而且它确实有效！

```ts
type PairOrTriple = NTuple<bigint, 2 | 3>;
// ^? type PairOrTriple = [bigint, bigint] | [bigint, bigint, bigint]
```

这是因为 NTupleHelp 分别用 N=2 和 N=3 实例化，并将结果合并在一起。使用累加器是递归泛型类型中的一种常见技术，因为它可以提高它们的性能。第 57 项将解释这一点。4

条件类型在分布到布尔类型和 never 类型时还具有两种其他令人惊讶的行为，你应该了解这些行为。

首先，布尔类型。让我们定义一个泛型类型，如果其参数为 true，则生成一个庆祝消息：

```ts
type CelebrateIfTrue<V> = V extends true ? 'Huzzah!' : never;
type Party = CelebrateIfTrue<true>;
// ^? type Party = "Huzzah!"
type NoParty = CelebrateIfTrue<false>;
// ^? type NoParty = never
type SurpriseParty = CelebrateIfTrue<boolean>;
// ^? type SurpriseParty = "Huzzah!"
```

最后一个实例化竟然解析为"Huzzah!"这一点令人惊讶，因为你不会认为布尔类型扩展 true 为 true。实际上，发生的情况要微妙得多。内部来说，TypeScript 将布尔类型视为一个联合类型：

```ts
type boolean = true | false;
```

因为布尔类型是一种联合类型，所以它可以分配到条件类型中。因此，展开一下，这种评估看起来是这样的：

```ts
type SurpriseParty = CelebrateIfTrue<boolean>
= CelebrateIfTrue<true | false>
= CelebrateIfTrue<true> | CelebrateIfTrue<false>
= "Huzzah!" | never
= "Huzzah!";
```

在这种情况下，这可能不是你想要的结果。就像之前一样，你可以通过将条件包裹在一个元组中来防止这种分配：

```ts
type CelebrateIfTrue<V> = [V] extends [true] ? 'Huzzah!' : never;
type SurpriseParty = CelebrateIfTrue<boolean>;
// ^? type SurpriseParty = never
```

另一个意外之处在于 \`never\` 类型。根据这个定义，你可能会认为 \`AllowIn\` 总是会评估为 "Yes"、"No" 或者可能是 "Yes" | "No"：

```ts
type AllowIn<T> = T extends { password: 'open-sesame' } ? 'Yes' : 'No';
```

但如果是 \`T\` 为 \`never\` 的情况，还有一种其他的可能性：

```ts
type N = AllowIn<never>; // ^? type N = never
```

为什么如果条件的两边都不是 never 类型，结果会是 never 呢？再次强调，这完全取决于对联合类型的分配规则。TypeScript 将 never 视为

将类型视为一个空联合类型，如果没有什么可分布的，则会返回空类型。如果你将 T 替换为 T|never（这与 T 相同），然后看看会发生什么，可能会更容易理解一些。

```ts
AllowIn<T>
= AllowIn<T never>
= AllowIn<T> | AllowIn<never>
= AllowIn<T> | never
= AllowIn<T>
```

T|绝不能像 T 那样对待。当涉及分发时，这意味着 F 必须永远不成立，无论你如何定义 F。如前所述，如果你不想这样，一个解决方案是将你的条件包装在一个元组中。

条件类型在联合类型上分布的方式是它们最强大和有用的功能之一。通常情况下，但并非总是如此，这是你想要的行为。当你编写泛型类型时，考虑是否希望它在联合类型上分布，并注意看似无害的重构可能会启用或禁用这种分布。

### 注意事项

- 考虑是否希望联合类型分布在条件类型之上。
- 了解如何通过添加条件或通过将条件包裹在单元素元组中来启用或禁用分布。
- 注意布尔类型和 never 类型在分布在联合类型上时的意外行为。

## 第 54 项：使用模板字面量类型来建模 DSL 和字符串之间的关系

第 35 项建议在自己的代码中使用更精确的替代字符串类型。但世界上有很多字符串，完全避免使用它们是很难的。在这种情况下，TypeScript 提供了一种独特的工具来捕获字符串中的模式和关系：模板字面量类型。本项将探讨此功能的工作原理，并展示如何使用它来为原本无法类型化的代码带来安全性。

就像所有编程语言一样，TypeScript 也有字符串类型，但正如我们在之前几项中看到的，它还有一种字符串字面量类型，其领域由单个字符串值组成。这些类型通常与联合类型结合使用：

```ts
type MedalColor = 'gold' | 'silver' | 'bronze';
```

通过字符串字面量类型的联合，你可以模拟一组有限的字符串。而使用字符串本身，则可以捕获所有可能字符串的无限集合。模板字面量类型让你可以模拟两者之间的内容，例如所有以“pseudo”开头的字符串集合：

```ts
type PseudoString = `pseudo${string}`;
const science: PseudoString = 'pseudoscience'; // ok
const alias: PseudoString = 'pseudonym'; // ok
const physics: PseudoString = 'physics';
// \~\~ Type '"physics"' is not assignable to type '`pseudo${string}`'.
```

与字符串类似，伪字符串类型也有无限的域（第 7 项）。但与字符串不同，伪字符串类型中的值具有一定的结构：它们都以 pseudo 开头。与其他类型级构造类似，模板字面量类型的语法特意设计成唤起 JavaScript 模板字面量的效果。

JavaScript 中充斥着结构化的字符串。例如，如果你希望一个对象具有某些已知的属性集，但同时允许任何以 data- 开头的其他属性（这种模式在 DOM 中很常见）。

```ts
interface Checkbox {
  id: string;

  checked: boolean;
  [key: `data-${string}`]: unknown;
}

const check1: Checkbox = {
  id: 'subscribe',
  checked: true,
  value: 'yes',
  // \~\~ Object literal may only specify known properties,
  // and 'value' does not exist in type 'Checkbox'. 'data-listIds': 'all-the-lists', // ok
};
const check2: Checkbox = {
  id: 'subscribe',
  checked: true,
  listIds: 'all-the-lists',
  // Object literal may only specify known properties,
  // and 'listIds' does not exist in type 'Checkbox'
};
```

如果我们使用字符串作为索引类型，在 check1 中将失去多余的属性检查的好处（参见第 11 项），并且在 check2 中错误地允许没有 data- 前缀的属性：

```ts
interface Checkbox {
  id: string;
  checked: boolean;
  [key: string]: unknown;
}
const check1: Checkbox = {
  id: 'subscribe',
  checked: true,
  value: 'yes', // permitted
  'data-listIds': 'all-the-lists',
};
const check2: Checkbox = {
  id: 'subscribe',
  checked: true,
  listIds: 'all-the-lists', // also permitted, matches index type
};
```

模板字面量类型有助于建模字符串的子集，但它们真正的强大之处在于将它们与泛型和类型推断结合使用，以捕捉类型之间的关系。

考虑 DOM 提供的 querySelector 函数。TypeScript 已经足够聪明，如果你查询特定的元素，它会给你一个更具体的 HTMLElement 子类型：

```ts
const img = document.querySelector('img'); // ^? const img: HTMLImageElement | null
```

这允许你访问 img.src 等属性，而在更不具体的 Element 类型中则不允许访问这些属性。（第 75 条涵盖了 TypeScript 和 DOM。）

不过这种聪明才智并不深入。如果你尝试通过特定 ID 查询一个图像，你只会得到一个 Element：

```ts
const img = document.querySelector('img#spectacular-sunset');
// ^? const img: Element | null
img?.src;
// \~\~ Property 'src' does not exist on type 'Element'.
```

借助模板字面量类型，我们可以解决这个问题。TypeScript 对 DOM 的类型声明（lib.dom.d.ts）中包含了一个从标签名到类型的映射：

```ts
interface HTMLElementTagNameMap {
  a: HTMLAnchorElement;
  abbr: HTMLElement;
  address: HTMLElement;
  area: HTMLAreaElement;
  // ... many more ...
  video: HTMLVideoElement;
  wbr: HTMLElement;
}
```

以及一些用于 querySelector 的声明：5

```ts
interface ParentNode extends Node {
  querySelector<E extends Element = Element>(selectors: string): E | null;
  // ...
}
```

现在我们可以使用模板字面量类型为 tag#id 情况添加一个重载：

```ts
type HTMLTag = keyof HTMLElementTagNameMap;
declare global {
  interface ParentNode {
    querySelector<TagName extends HTMLTag>(
      selector: `${TagName}#${string}`
    ): HTMLElementTagNameMap[TagName] | null;
  }
}
```

之前的示例现在可以按你期望的方式工作，返回更精确的 image 类型，并允许访问其 src 属性：

```ts
const img = document.querySelector('img#spectacular-sunset');
// ^? const img: HTMLImageElement | null
img?.src; // ok
```

这很有帮助，但我们稍微偏离了目标：

```ts
const img = document.querySelector('div#container img');
// ^? const img: HTMLDivElement | null
```

CSS 选择器中的空格表示“后代”。在这种情况下，我们的模板字面量类型 \``${TagName}#${string}`\` 匹配了 "div"，然后是 "#"，接着是 "container img"。在尝试获得更精确的类型时，我们违背了第 40 条建议，即宁可选择不精确也不选择不准确。

虽然可以想象使用模板字面量类型构建整个 CSS 选择器解析器，但处理这个问题的一个更不雄心勃勃的方法是使用另一个重载来防止 CSS 选择器中有特殊含义的字符：

```ts
type CSSSpecialChars = ' ' | '>' | '+' | '~' | '||' | ',';
type HTMLTag = keyof HTMLElementTagNameMap;
declare global {
  interface ParentNode {
    // escape hatch
    querySelector(
      selector: `${HTMLTag}#${string}${CSSSpecialChars}${string}`
    ): Element | null;
    // same as before
    querySelector<TagName extends HTMLTag>(
      selector: `${TagName}#${string}`
    ): HTMLElementTagNameMap[TagName] | null;
  }
}
```

现在你至少可以得到一个不精确的类型，而不是不准确的类型：

```ts
const img = document.querySelector('img#spectacular-sunset'); // ^? const img: HTMLImageElement | null
const img2 = document.querySelector('div#container img'); // ^? const img2: Element | null
```

这将有助于确保安全使用。有关 TypeScript 和 DOM 的更多信息，请参见第 75 条。

模板字面量类型通常与条件类型结合使用，以实现针对特定领域的语言（如 CSS 选择器）的解析器。为了了解这是如何工作的，我们尝试为一个将 snake_cased 对象的键转换为 camelCase 的 objectToCamel 函数获取精确的类型：

```ts
// e.g. foo*bar -> fooBar
function camelCase(term: string) {
  return term.replace(/_([a-z])/g, (m) => m[1].toUpperCase());
}
// (return type to be filled in shortly)
function objectToCamel<T extends object>(obj: T) {
  const out: any = {};

  for (const [k, v] of Object.entries(obj)) {
    out[camelCase(k)] = v;
  }
  return out;
}
const snake = { foo_bar: 12 };
// ^? const snake: { foo_bar: number; }
const camel = objectToCamel(snake);
// camel's value at runtime is {fooBar: 12};
// we'd like the type to be {fooBar: number}
const val = camel.fooBar;
// we'd like this to have a number type
const val2 = camel.foo_bar;
// we'd like this to be an error
```

首先，我们定义一个类型级的 ToCamelOnce 辅助类型：

```ts
type ToCamelOnce<S extends string> = S extends `${infer Head}_${infer Tail}`
  ? `${Head}${Capitalize<Tail>}`
  : S;
type T = ToCamelOnce<'foo_bar'>; // type is "fooBar"
```

在这里，我们使用条件类型中的 infer 关键字来提取字符串中下划线前后的一部分。当 S 为"foo_bar"时，Head 是字符串字面量类型"foo"，Tail 是字符串字面量类型"bar"。当我们匹配时，我们使用模板字面量类型构造一个新的字符串（不包含下划线），并将尾部的第一个字母大写（Capitalize 是一个内置辅助类型）。

为了使这个功能适用于包含多个下划线的字符串，如"foo_bar_baz"，我们需要使其递归：

```ts
type ToCamel<S extends string> = S extends `${infer Head}_${infer Tail}`
  ? `${Head}${Capitalize<ToCamel<Tail>>}`
  : S;
type T0 = ToCamel<'foo'>; // type is "fo "
type T1 = ToCamel<'foo_bar'>; // type is "fooBar"
type T2 = ToCamel<'foo_bar_baz'>; // type is "fooBarBaz"
```

现在我们可以使用映射类型（第 15 项）并结合辅助函数，给 \`objectToCamel\` 更精确的类型：

```ts
type ObjectToCamel<T extends object> = {
  [K in keyof T as ToCamel<K & string>]: T[K];
};
function objectToCamel<T extends object>(obj: T): ObjectToCamel<T> {
  // ... as before .
}
```

现在类型正是我们想要的！

```ts
const snake = { foo_bar: 12 };
// ^? const snake: { foo_bar: number; }
const camel = objectToCamel(snake);
// ^? const camel: ObjectToCamel<{ foo_bar: number; }>
// (equivalent to { fooBar: number; })
const val = camel.fooBar;
// ^? const val: number
const val2 = camel.foo_bar;
// Property 'foo_bar' does not exist on type
// '{ fooBar: number; }'. Did you mean 'fooBar'?
```

这个新的、更精确的 \`objectToCamel\` 类型是“花哨”的 TypeScript 功能如何为开发者带来好处的一个绝佳例子。你不需要了解模板字面量类型、条件类型或映射类型，就可以使用 \`objectToCamel\`。但你仍然会从这些类型中受益，体现在更精确的类型上。你的 TypeScript 使用体验是，即使你不完全理解它是如何做到这一点的，TypeScript 也能理解这段代码。

一个小问题是驼峰命名类型的显示并不理想。第 56 项将解释如何改进这一点。

### 注意事项

- 使用模板字面量类型来建模字符串类型和领域特定语言（DSL）的结构化子集。
- 将模板字面量类型与映射类型和条件类型结合使用，以捕捉类型之间的细微关系。
- 注意避免类型不准确的问题。力求使用模板字面量类型来提升开发体验，而不需要开发者了解复杂的语言特性。

## 第 55 条：为你的类型编写测试

直到恐惧转化为厌烦，才开始写测试。

—Philp（引自 Kent Beck，《通过示例的测试驱动开发》\[Addison-Wesley Professional\]）

你不会在没有测试的情况下编写代码（我希望是这样！），同样，你也不应该在没有为其编写测试的情况下编写类型声明。但是，如何测试类型呢？如果你正在编写类型声明或 TypeScript 库，测试你的类型是一项必不可少但又相当棘手的任务。

与大多数其他编程语言相比，TypeScript 在这方面的需求尤为迫切，原因有两点：

TypeScript 让你可以在类型中放入大量的逻辑。有逻辑的地方可能就有 bug，而有 bug 的地方就需要写测试。
对于 JavaScript 库，以及在一定程度上对于 TypeScript 代码，你可以独立于运行时实现来定义类型。这意味着两者可能会脱节，你需要写测试来确保这种情况不会发生。

测试类型主要有两种方式：使用类型系统和使用类型系统之外的工具。这两种方法各有优劣。本文将首先探讨一些无效的类型测试方法，然后讨论这两种标准方法的优缺点。

假设你为一个实用库提供的映射函数编写了一个类型声明（流行的 Lodash 库就提供了这样的函数，其他库也是如此），

原生数组):

```ts
declare function map<U, V>(array: U[], fn: (u: U) => V): V[];
```

如何检查这种类型声明是否产生了预期的类型？（显然，实现部分有单独的测试。）一种常见的方法是编写一个测试文件来调用该函数：

```ts
map(['2017', '2018', '2019'], (v) => Number(v));
```

这将进行一些粗略的错误检查：如果你的 map 声明只列出了一个参数，这个测试就会捕捉到错误。但这里似乎缺少了些什么？

这种运行时行为的测试风格的等价形式可能看起来像这样：

```ts
test('square a number', () => {
  square(1);
  square(2);
});
```

当然，这测试了平方函数不会抛出错误。但它没有检查返回值，所以并没有真正测试行为。即使平方函数的实现有误，这个测试也会通过。

这种做法在测试类型声明文件时很常见，因为简单地复制粘贴库的现有单元测试即可。虽然它提供了一定的价值，但实际检查一些类型会更好！

一种方法是将结果赋值给一个声明了类型的变量：

```ts
const lengths: number[] = map(['john', 'paul'], (name) => name.length);
```

这正是 Item 18 会鼓励你移除的那种多余的类型声明。但在这种情况下，它扮演了一个关键角色：它提供了一定的信心，至少证明了映射声明在做些什么。

与类型保持一致。确实，在 DefinitelyTyped 中你可以找到很多类型声明正是使用这种方法进行测试的。

然而，使用赋值进行测试存在一些问题。

其中一个问题是，你必须创建一个命名变量，而这个变量很可能不会被使用。这增加了样板代码，同时也意味着你将不得不禁用任何关于未使用变量的警告规则。

通常的解决方案是定义一个辅助函数：

```ts
function assertType<T>(x: T) {}
assertType<number[]>(map(['john', 'paul'], (name) => name.length));
```

第二个问题是，我们检查的是两个类型的可赋值性而不是相等性。通常情况下，这种检查按预期工作。例如：

```ts
const n = 12;
assertType<number>(n); // oK
```

如果你在编辑器中检查 n 符号，你会发现它的类型实际上是 12，一个数值字面量类型。这属于 number 的子类型，可赋值性检查通过了，正如你所预期的那样。

到目前为止一切正常。但当你开始检查对象的类型时，情况就变得复杂了：

```ts
const beatles = ['john', 'paul', 'george', 'ringo'];
assertType<{ name: string }[]>(
  map(beatles, (name) => ({ name, inYellowSubmarine: name === 'ringo' }))
); // OK
```

map 调用返回一个 {name: string, inYellowSubmarine: boolean} 对象的数组。这个数组可以赋值给 {name: string}\[\]，因此代码通过了类型检查。但黄色潜艇呢？在这种情况下，我们更希望检查类型相等性。

测试函数类型是否可赋值也会导致一些令人惊讶的行为：

```ts
const add = (a: number, b: number) => a + b;
assertType<(a: number, b: number) => number>(add); // oK
const double = (x: number) => 2 * x;
assertType<(a: number, b: number) => number>(double); // oK?
```

令人惊讶的是，第二个断言能够成功，因为这两个函数接受的参数数量不同。但这就是 TypeScript 中可赋值工作的规则：一个函数类型可以被另一个接受更少参数的函数类型赋值：

```ts
const g: (x: string) => any = () => 12; // OK
```

这反映了这样一个事实：在 JavaScript 中，调用一个声明接受更少参数的函数时传递更多的参数是完全允许的。TypeScript 选择模拟这种行为而不是禁止它，主要是因为它在回调中非常普遍。例如，在 Lodash 的 map 函数中，回调函数可以接受多达三个参数：

```ts
map(array, (element, index, array) => {
  /* ... */
});
```

虽然在需要时这三个参数都是可用的，但通常只使用一个或有时使用两个，就像我们在本项中所做的那样。实际上，同时使用这三个参数的情况非常罕见。如果 TypeScript 禁止这种赋值，将会在大量的 JavaScript 代码中报告错误。

你可以怎么做？你可以拆分函数类型，并使用内置的 Parameters 和 ReturnType 类型来测试其各个部分：

```ts
const double = (x: number) => 2 * x;
declare let p: Parameters<typeof double>;
assertType<[number, number]>(p);
// \~ Argument of type '[number]' is not
// assignable to parameter of type [number, number]
```

但如果“this”还不够复杂，还存在另一个问题：Lodash 的 map 会为其回调设置 this 的值。TypeScript 可以模拟这种行为（参见第 69 条），因此你的类型声明也应该这样做。你也应该对其进行测试。我们如何做到这一点？

到目前为止，我们对 map 的测试风格有点“黑盒”：我们通过一个数组和一个函数运行 map，并测试结果的类型，但没有测试中间步骤的细节。我们可以通过填充回调函数并直接验证其参数和 this 的类型来做到这一点：

```ts
const beatles = ['john', 'paul', 'george', 'ringo'];
assertType<number[]>(
  map(beatles, function (name, i, array) {
    // \~\~\~ Argument of type '(name: any, i: any, array: any) => any' is
    // not assignable to parameter of type '(u: string) => any'
    assertType<string>(name);
    assertType<number>(i);
    assertType<string[]>(array);
    assertType<string[]>(this);
    // 'this' implicitly has type 'any' return name.length;
  })
);
```

这揭示了我们之前声明的 map 几个问题，特别是其回调只接受一个参数，并且没有为 this 设置类型。注意使用函数表达式而不是箭头函数，以便我们可以测试 this 的类型。

这里有一个通过检查的声明：

```ts
declare function map<U, V>(
  array: U[],
  fn: (this: U[], u: U, i: number, array: U[]) => V
): V[];
```

然而，仍然存在一个最终问题，而且这是一个重大问题。这里是我们模块的一个完整类型声明文件，即使是最严格的 map 测试也能通过，但它比毫无用处还要糟糕：

declare module 'your-amazing-module';

这个声明将整个模块的类型设置为 any。你的类型断言都会通过，但你将没有任何类型安全。更糟糕的是，这个模块中每个函数的调用都会默默地产生一个 any 类型，从而在整个代码中破坏类型安全。即使启用了 noImplicitAny，你仍然可以通过类型声明文件获得 any 类型。

解决这个问题的一种方法是添加一些“负向”测试：预期会失败的测试。TypeScript 通过 \`@ts-expect-error\` 注释允许你这样做：

```ts
// @ts-expect-error only takes two parameters
map([1, 2, 3], (x) => x * x, 'third parameter');
```

这颠倒了常规的错误检查过程：现在如果没有类型错误，将会触发编译器错误。这确实可以在一定程度上保护类型安全，但请注意：@ts-expect-error 是一个非常粗暴的工具。你无法确切指定预期的错误。例如，之前的代码片段仍然可以通过任何类型，因为函数参数会隐式地产生一个任何类型的错误：

```ts
declare const map: any;
map([1, 2, 3], (x) => x * x, 'third parameter');
// \~ Parameter 'x' implicitly has an 'any' type.
```

一个解决办法是将代码拆分到多行中，以减少指令的作用范围：

```ts
map(
  [1, 2, 3],
  (x) => x * x
  // @ts-expect-error only takes two parameters 'third parameter'
);
```

如果我们能让 assertType 能处理这些烦人的 any 类型就好了。通过一些巧妙的方法，可以使用类型别名检测 any 类型。不过，为了不增加测试代码的复杂性，我们不妨将其作为使用测试库的提示。

在类型系统中较为流行的选择之一是 expect-type。你可以单独使用它，或者通过 vitest 测试框架来使用它，后者会将其打包进去。它的使用方式如下：

```ts
import { expectTypeOf } from 'expect-type';
const beatles = ['john', 'paul', 'george', 'ringo'];
expectTypeOf(
  map(beatles, function (name, i, array) {
    expectTypeOf(name).toEqualTypeOf<string>();
    expectTypeOf(i).toEqualTypeOf<number>();
    expectTypeOf(array).toEqualTypeOf<string[]>();
    expectTypeOf(this).toEqualTypeOf<string[]>();
    return name.length;
  })
).toEqualTypeOf<number[]>();
```

正如你所期望的，它能够捕捉到任何类型的错误，包括不同的函数类型，以及诸如只读属性等细微差异：

```ts
const anyVal: any = 1;
expectTypeOf(anyVal).toEqualTypeOf<number>();
//
// Type 'number' does not satisfy the constraint 'never'.
const double = (x: number) => 2 * x;
expectTypeOf(double).toEqualTypeOf<(a: number, b: number) => number>(); //
// Type ... does not satisfy '"Expected: function, Actual: never"'

interface ABReadOnly {
  readonly a: string;
  b: number;
}
declare let ab: { a: string; b: number };
expectTypeOf(ab).toEqualTypeOf<ABReadOnly>();
//
// Arguments for the rest parameter 'MISMATCH' were not provided.
expectTypeOf(ab).toEqualTypeOf<{ a: string; b: number }>(); // OK
```

以这种方式测试类型具有许多优势：

- 它不需要任何额外的工具。所有的类型测试都是通过你已经使用的 tsc 来完成的。
- 由于类型是通过结构进行测试的，因此它不会被诸如 1|2 与 2|1 这样的无意义差异所困扰。
- TypeScript 的语言服务可以帮助进行重构。例如，如果你重命名了一个接口，那么在任何类型断言中它的名称也会被更新。
- 如果你使用了像 prettier 这样的格式化工具，你的断言将会以与代码相同的方式进行格式化。

这种方法也有一些缺点：

- 错误信息“类型不匹配（MISMATCH）”并没有提供太多关于不匹配的具体内容或发生位置的指导。
- 由于它是在测试类型结构，因此无法检测到它们显示方面的问题。如第 56 条所述，你可以在一定程度上控制这一点，并且应该对此有所关注。

尽管如此，这仍然是测试类型的一个很好的方法，相比于本条目早期看到的手动实现，这是一个巨大的改进。

另一种类似的方法是由 Type Challenges 仓库普及的。它看起来像这样：

```ts
export type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <
  T
>() => T extends Y ? 1 : 2
  ? true
  : false;

export type Expect<T extends true> = T;
const double = (x: number) => 2 ** x;
type Test1 = Expect<Equals<typeof double, (x: number) => number>>;
type Test2 = Expect<Equals<typeof double, (x: string) => number>>;
// Type 'false' does not satisfy the constraint 'true'.
```

从第 48 项回忆可知，函数类型在返回类型方面是共变的。但第一个条件类型可靠地赋值给第二个类型的方式，唯一可能是 X 等于 Y。（试着用几个具体的类型替换 X、Y 和 T，让自己信服这一点。）与其依赖类型级逻辑来测试相等性，这是一次我们可以让 TypeScript 本身来比较类型是否相等的罕见情况。

虽然这种方法比 expect-type 更稳健，但它也有许多相同的优势和缺点。失败测试的错误信息并不特别有启发性。而且，在 TypeScript 中，类型相等是一个非常罕见的概念，其语义有些模糊。类型显示的某些部分有意义，而另一些部分则没有意义：

```ts
type Test3 = Expect<Equals<1 | 2, 2 | 1>>; / o d!
type Test4 = Expect<Equals<[a: 1, b: 2], [1, 2]>>; // maybe not so go d
type Test5 = Expect<Equals<{x: 1} & {y: 2}, {x: 1, y: 2}>>; // urprising //
// Type 'false' does not satisfy the constraint 'true'.
```

至于在类型系统内部测试类型。如果你想要使用外部工具来测试类型呢？两种常见的工具是 dtslint 和 eslintplugin-expect-type。如它们的名字所示，这两种工具都作为代码检查器运行。

dtslint 是为测试 DefinitelyTyped 仓库中的类型声明而构建的。它通过特别格式化的注释来运行。以下是如何使用 dtslint 编写 map 函数的最后一个测试示例：

```ts
const beatles = ['john', 'paul', 'george', 'ringo'];
map(
  beatles,
  function (
    name,
    // $ExpectType string
    i,
    // $ExpectType number

    array
    // $ExpectType string[]
  ) {
    this;
    // $ExpectType string[]
    return name.length;
  }
);
// $ExpectType number[]
```

rather than 检查可分配性，dtslint 检查每个符号的类型，并进行文本比较。这与你在编辑器中手动测试类型声明的方式相符：dtslint 基本上是自动化了这个过程。这种方法也有一些缺点：尽管本质上是相同类型的，\`number|string\` 和 \`string|number\` 在文本上是不同的。但 \`string\` 和 \`any\` 也是如此，尽管它们可以相互分配，这正是关键所在。

eslint-plugin-expect-type 以类似的方式工作，但作为 ESLint 插件。如果你想要测试自己的 TypeScript 类型而不是 DefinitelyTyped 上的类型声明，这种方式更方便。除了 \`$ExpectType\` 注释外，它还会检查以 Twoslash 风格注释中的类型：

```ts
const spiceGirls = ['scary', 'sporty', 'baby', 'ginger', 'posh'];
// ^? const spiceGirls: string[]
```

这应该很熟悉：它与本书中代码示例使用的语法相同！你也可以在 TypeScript 在线 playground 中使用 Twoslash 风格注释（参见第二版前言中的图 P-1）。

使用外部工具测试类型有诸多优势：

- 它符合你在编辑器中与类型交互的方式。进行类型显示的逐字符比较不需要在类型级别上添加任何花哨的功能。
- 因为它测试的是类型字符串表示形式，所以能够捕捉到类型显示方面的问题（第 56 项）。
- ESLint 插件的自动修复功能使得更新测试变得非常容易。

不过也有一些缺点：

- 它需要设置另一个工具（尽管你很可能已经在使用 ESLint 了）。
- 它可能会过于敏感；例如，因为它显示方式不同，所以认为 1|2 和 2|1 是不同的类型。
- 由于类型在注释中，你无法享受类型格式化/重构的功能。

有些工具采用混合方法。例如，tsd 是一种类型测试工具，它在类型系统内运作，但也包含一个外部工具以提供否则难以获得的更严格的类型检查。

最后，还有一些你可能想要测试的功能，这两种工具都无法帮助你完成。例如，这里有一个流行的技巧，可以在提供几个值的自动补全的同时，仍然允许任何字符串：

```ts
type Game = 'wordle' | 'crossword' | (string & {});
const spellingBee: Game = 'spelling bee';
let g: Game = '';
```

如果你在最后一个空字符串中按下 Ctrl-Space，TypeScript 会建议“wordle”或“crossword”。但它仍然允许将任何字符串赋值给 Game。如果你想编写一个测试来验证这一点是否按预期工作，前面描述的两种方法都无法帮助你（图 6-2）。

![](https://cdn-mineru.openxlab.org.cn/extract/502cbe09-f625-4c65-a0d4-26b025d9b0ff/11366059404d7e68fb9becd6b6192f96ff3e2a124ad009e9a37b5f22a8fd2a0a.jpg)
图 6-2. TypeScript 提供两个值的自动补全，但接受所有字符串。

测试类型声明是一件棘手的事情。你应该测试它们。但要意识到一些常见技术的陷阱。不要自己开发类型测试系统。如果你在 DefinitelyTyped 中编写类型声明，应该使用 dtslint，因为这是该环境下的标准工具。如果你在测试自己的代码，可以使用 vitest、expect-type 或 tsd 这样的库。如果你想编写对类型显示方式敏感的测试，而不是仅仅关注其结构，可以使用 eslint-plugin-expect-type。

### 注意事项

- 在测试类型时，请注意相等性和可赋值性之间的区别，尤其是在处理函数类型时。
- 对于使用回调的函数，请测试回调参数的推断类型。如果 this 是 API 的一部分，请记得测试其类型。
- 避免编写自己的类型测试代码。请使用标准工具代替。
- 对于 DefinitelyTyped 中的代码，请使用 dtslint。对于您自己的代码，请使用 vitest、expect-type 或 Type Challenges 方法。如果您想测试类型显示，请使用 eslint-plugin-expect-type。

## 第 56 条：注意类型显示方式

通常，我们关心的是类型是什么以及哪些值可以赋给它们。但在使用 TypeScript 库时，库选择以何种方式显示类型会对你的使用体验产生很大影响。这意味着，作为库的作者，你需要关注你的类型是如何显示的。

对于任何类型，都有很多种有效的显示方式。例如，联合类型通常会按照你在定义时列出的顺序显示其成员：

```ts
type T123 = '1' | '2' | '3'; // ^? type T123 = "1" | "2" | "3"
```

但如果你之前引入了一个重叠的联合类型，显示方式可能会有所不同：

```ts
type T21 = '2' | '1';
// ^? type T21 = "2" | "1"
type T123 = '1' | '2' | '3';
// ^? type T123 = "2" | "1" | "3"
```

是 1, 2, 3 还是 2, 1, 3？这两种表示方式都是同一种类型的完全有效表示。在这种情况下，两种表示方式的可读性差不多，但有时在多种表示方式之间可能会有显著差异。

为了展示一个不理想的类型显示示例，让我们实现一个 PartiallyPartial 泛型，使其对象的某些属性可选，但不是所有属性。这里是一个实现示例：

```ts
type PartiallyPartial<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;
```

在实际应用中，它可能看起来像这样：

```ts
interface BlogComment {
  commentId: number;
  title: string;
  content: string;
}

type PartComment = PartiallyPartial<BlogComment, 'title'>;
// ^? type PartComment =
// Partial<Pick<BlogComment, "title">> &
// Omit<BlogComment, "title">
```

泛型类型实现正确，这是一个完全有效的显示结果实例化。但对检查 PartComment 的用户来说，还有一些不足之处：title 的类型是什么？它是可空的吗？还有哪些字段被 Omit 隐藏了？整个显示给人一种过于关注泛型类型定义过程，而不是最终类型本身的印象。

我们希望 TypeScript 能多做一些工作来解析这些泛型类型。有一种广泛使用的技巧可以做到这一点：

我们稍后会讨论它是如何工作的。但首先，这是你如何使用它：

```ts
type PartiallyPartial<T, K extends keyof T> = Resolve<
  Partial<Pick<T, K>> & Omit<T, K>
>;
type PartComment = PartiallyPartial<BlogComment, 'title'>; // ^? type PartComment = {
// title?: string | undefined;
// commentId: number;
// content: string;
// }
```

通过将泛型类型包裹在 Resolve 中，我们神奇地告诉 TypeScript 将所有属性的显示展开。现在这种类型看起来清晰多了。更棒的是，所有实现的痕迹都消失了。使用这种类型的用户不需要知道它是使用 Partial、Pick 或 Omit 实现的。

那么 Resolve 是如何工作的呢？如果你忽略条件类型，剩下的表达式看起来应该是对象类型的恒等函数：

确实，这可以“解决”某些类型。因为这是一个同态映射类型（参见第 15 项），它允许原始类型保持不变：

```ts
type S = ObjIdentity<string>;
// ^? type S = string
type N = ObjIdentity<number>;
// ^? type N = number
type U = ObjIdentity<'A' | 'B' | 'C'>; // ^? type U = "A" | "B" | "C"
```

然而，对于函数来说它不是恒等映射，这就是为什么我们需要在 Resolve 上使用条件类型进行保护：

```ts
type F = ObjIdentity<(a: number) => boolean>; // ^? type F = {}
```

这个辅助函数在大量使用泛型类型的 TypeScript 代码中非常常见。我选择将它命名为 Resolve，但你也可以看到它被称为 Simplify、NOP、NOOP 或 Merge n ertions。

你可以递归地解析对象类型来创建一个 DeepResolve，但这通常不是一个好主意，因为 Resolve 在类上会过于激进：

```ts
type D = Resolve<Date>;
// ^? type D = {
// toLocaleString: {
// (locales?: Intl.LocalesArgument,
// options?: Intl.DateTimeFormatOptions | undefined): string; // (): string;
// (locales?: string | string[] | undefined,
// options?: Intl.DateTimeFormatOptions | undefined): string; // };
// 42 more ...
// [Symbol.toPrimitive]: {
//
// };
// }
```

内联在这里适得其反。直接让这种类型显示为 Date 更好。

你也可以使用 Resolve 来内联 keyof 表达式，如果你觉得这样能提高可读性的话：

```ts
interface Color {
  r: number;
  g: number;
  b: number;
  a: number;
}
type Chan = keyof Color;
// ^? type Chan = keyof Color
type ChanInline = Resolve<keyof Color>;
// ^? type ChanInline = "r" | "g" | "b" "a"
```

有时你希望类型能清晰地显示出来，特别是某些重要的情况。对于 PartiallyPartial，这可能发生在类型参数 K 从未被使用的情况下（在这种情况下，没有字段是可选的）。这是根据我们当前的定义处理这种情况的方式：

```ts
type FullComment = PartiallyPartial<BlogComment, never>;
// ^? type FullComment = {
// title: string;
// commentId: number;
// content: string;
// }
```

这种结果是正确的，这也是一种有效的显示方式。但有一种更简洁的表示方式：FullComment 就是 BlogComment。我们可以通过检查这种情况来获得更简洁的类型： %%

```ts
type PartiallyPartial<T extends object, K extends keyof T> = [K] extends [never]
  ? T // special case
  : T extends unknown // extra conditional to preserve distribution over unions
  ? Resolve<Partial<Pick<T, K>> & Omit<T, K>>
  : never;

type FullComment = PartiallyPartial<BlogComment, never>; // ^? type FullComment = BlogComment
```

参见第 53 项，了解我们为何将条件包装在元组类型中（\[K\] 而不是 K），并添加了 T extends unknown 子句的原因。添加这种特殊情况并不会改变 PartiallyPartial 的任何行为，它只是在一种情况下改进了其结果的显示方式。

您可能会看到其他一些调整类型显示的技术，例如：

- Exclude<keyof T, never> 以内联 keyof 表达式
- unknown & T 或 {} & T 以内联对象类型

这些都可以用 Resolve 替换，Resolve 效果相同且更不易出错。

当你更改类型显示时，请确保不要为了其他情况而牺牲可读性。由于这些操作微妙且不影响可赋值性，很容易出现未被注意到的回归问题。

新版本的 TypeScript 也可能影响类型显示的方式。因此，建立一个测试类型显示的系统非常重要。第 55 项会向你展示如何操作。

### 注意事项

- 同一种类型可以有多种有效的显示方式。有些方式比其他方式更清晰。
- TypeScript 提供了一些工具来控制类型显示的方式，特别是 Resolve 通用类型。明智地使用这些工具可以澄清类型显示并隐藏实现细节。
- 考虑处理通用类型的重要的特殊情形，以改进类型显示。
- 为你的通用类型及其显示编写测试，以避免回归问题。

## 第 57 条：优先使用尾递归泛型类型

计算的历史充满了意外的编程语言。你向系统中添加了一些自定义功能。你的用户喜欢它并要求更多。你又添加了一些有用的功能。你不断给用户更多的控制权。最终，有人指出你的系统是图灵完备的！6 著名的例子包括微软 Excel、C 预处理器、C++模板和 TypeScript 泛型类型。

这些意外的编程语言通常完全是函数式的，因为这种范式能用最少的概念提供巨大的控制力。你只需要函数组合和某种形式的分支。以 TypeScript 的类型系统为例，函数组合意味着实例化一个泛型类型。而你可以通过在对象类型中查找键或使用条件类型来获得分支。

纯粹函数式语言通常通过递归来实现循环。正如我们在第 54 项中看到的，这可以很好地用于处理字符串类型。

但递归虽然在概念上效率高，但在实际应用中也有一些缺点，因为每次递归调用都需要在栈上创建一个新的栈帧。

为了说明这个问题，我们来写一个 JavaScript 函数，用于计算列表中所有数字的和。一种方法是使用递归：

```ts
function sum(nums: readonly number[]): number {
  if (nums.length === 0) {
    return 0;
  }
  return nums[0] + sum(nums.slice(1));
}
console.log(sum([0, 1, 2, 3, 4]));
```

如你所料，这会打印出：

> 10

这是一种效率很低的计算列表中数字和的方法。列表中的每个数字都会导致另一个递归调用，占用栈空间，并最终溢出。对于我来说，使用 Node.js 时，这种情况发生在数组包含大约 7,000 到 8,000 个元素时：

```ts
const arr = Array(7875).fill(1);
console.log(sum(arr));
return nums[0] + sum(nums.slice(1));
```

RangeError: 超过了最大调用栈大小

使用 for-of 循环实现的累加版本将不会有这样的限制。那么循环是否天然优于递归？别急！很久以前，函数式程序员们为了解决这个问题想出了一个聪明的解决方案。如果一个函数的最后一项操作是递归调用自身并返回那个值，它就可以放弃栈上的空间：它的工作已经完成，它

不再需要它了。这被称为尾调用优化（TCO），具有这种形式的函数称为尾递归函数。

这是一个使用累加器的尾递归版本的 sum 函数：

```ts
function sum(nums: readonly number[], acc = 0): number {
  if (nums.length === 0) {
    return acc;
  }
  return sum(nums.slice(1), nums[0] + acc);
}
```

运行这段代码会迅速得到正确的结果，而不会发生栈溢出：7

```bash
$ bun sum-tail-rec.js 7875
```

对于递归的 TypeScript 类型别名，同样需要注意。TypeScript 限制了类型别名的递归实例化次数，以防止无限循环和类型检查器的缓慢。但 TypeScript 支持尾调用优化，并为尾递归的类型别名提供了更大的深度限制。由于它们更高效且功能更强大，因此在可能的情况下，应将递归的类型别名设为尾递归。

这一点对于逐字符处理字符串字面量类型的泛型尤为重要。例如，这里有一个泛型类型，它可以将字符串字面量类型转换为字符串中字符的联合类型：

```ts
type GetChars<S extends string> =
  S extends `${infer FirstChar}${infer RestOfString}`
    ? FirstChar | GetChars<RestOfString>
    : never;
type ABC = GetChars<'abc'>;
// ^? type ABC = "a" "b"
```

这个操作在其递归调用之后执行（与 FirstChar 进行并集操作），因此它不是尾递归。对于长度超过约 50 个字符的字符串字面量类型，你可能会遇到溢出问题：

为了更现实地说明这个问题可能导致的问题，让我们再次回顾第 54 项中的 objectToCamel 函数。该函数接收一个具有 snake_case 属性的对象（{foo_bar: 0}），并返回一个具有 camelCase 属性的等效对象（{fooBar: 0}）。我们开发了一个 ToCamel 通用函数，用于将字符串字面量类型 "foo_bar" 转换为 "fooBar"。

现在让我们反向操作，实现 ToSnake。在这种情况下没有分隔符（“\_”），所以我们需要逐字符处理字符串类型。

这里有一个实现：

```ts
type ToSnake<T extends string> = string extends T
  ? string
  : // We want ToSnake<string> = string
  T extends `${infer First}${infer Rest}`
  ? First extends Uppercase<First> // Is First a capital letter?
    ? `_${Lowercase<First>}${ToSnake<Rest>}` // e.g. "B" -> "\_b" \
    : `${First}${ToSnake<Rest>}`
  : T;
type S = ToSnake<'fooBarBaz'>;
// ^? type S = "foo_bar_baz"
type Two = ToSnake<'className' | 'tagName'>;
// ^? type Two = "class_name" | "tag_name"
```

这里有两个递归调用，取决于字符串字面量类型的首字符是否为大写字母。如果是大写字母，我们希望将其替换为下划线和小写字母，并继续处理。否则，我们保持原样并继续处理。第二个示例展示了它在联合类型上正确地进行了分配（第 53 条项）。

这种类型别名在每个条件分支的递归调用之后确实进行了字符串连接和转换为小写，因此它不是尾递归。正如你现在已经预料到的，它很容易溢出栈：

如果你尝试使用这个辅助函数将一个长键的对象转换为下划线命名（snake_case），你的类型将会出错。虽然 50 个字符可能看起来足够用于属性名，但在许多情况下，属性名要长得多，尤其是在 Java 世界中。8

我们可以通过重构 ToSnake 使其尾递归，从而取消对长字符串字面量类型的限制并加快所有实例的类型检查速度：

```ts
type ToSnake<T extends string, Acc extends string = ''> = string extends T
  ? string // We want ToSnake<string> = string
  : T extends `${infer First}${infer Rest}`
  ? ToSnake<
      Rest,
      First extends Uppercase<First>
        ? `${Acc}_${Lowercase<First>}`
        : `${Acc}${First}`
    >
  : Acc;
type S = ToSnake<'fooBarBaz'>;
// ^? type S = "foo_bar_baz"
type Two = ToSnake<'className' | 'tagName'>;
// ^? type Two = "class_name" | "tag_name"
type Long = ToSnake<'reallyDescriptiveNamePropThatsALittleTooLoquacious'>;
// ^? type Long =
('really_descriptive_name_prop_thats_a_little_too_loquacious');
```

就像尾递归版本的 sum 一样，我们添加了一个累加器来跟踪到目前为止已完成的工作。这使我们能够将递归实例移至尾递归位置并取消限制。你将能够将你的 Java 同事抛出的任何冗长的属性名都转换为下划线命名！

### 注意事项

- 尽量让你的递归泛型类型成为尾递归类型。它们更高效，并且具有更大的深度限制。
- 递归类型别名通常可以通过重写为使用累加器的方式来实现尾递归。

## 第 58 条：考虑将复杂类型转换为代码生成

谨防一切皆有可能但无趣之事皆不易的图灵泥潭。

—Alan Perlis

本章探讨了在 TypeScript 中进行类型级别的编程。这意味着实现操作类型而非值的逻辑和函数（Item 50）。就像常规程序一样，我们可以编写测试（Item 55）并考虑它们的性能（Item 57）。特别是借助处理模板字面量类型工具（Item 54），TypeScript 中的类型级别程序可以实现一些令人印象深刻的功能。

TypeScript 的类型系统是图灵完备的，因此理论上可以用它来表示任何计算。不过，正如本项开头的引言所警告的那样，虽然某事可能做到，但这并不意味着它容易，或者明智。

假设你的 TypeScript 程序与数据库交互，并包含一些 SQL：

```ts
async function getBooks(db: Database) {
  const result = await db.query(
    `SELECT title, author, year, publisher FROM books`
  );
  return result.rows;
}
```

通过一些巧妙的方法，你可能能够使用模板字面量类型和条件类型在 TypeScript 的类型系统中解析该查询。结合一个表示你的数据库模式的类型，你实际上可能能够从查询的 SQL 本身推断出查询的结果类型。这是一个令人印象深刻的成就，你肯定会从它那里获得更精确的类型。

但如果你的程序也包含这个查询呢？

```ts
async function getLatestBookByAuthor(db: Database, publisher: string) {
  const result = await db.query(
    `SELECT author, MAX(year) FROM books GROUP BY author WHERE publisher=$1`,
    [publisher]
  );
  return result.rows;
}
```

为这个查询获取正确的类型要困难得多。你的 SQL 查询解析器需要理解 GROUP BY 子句、MAX 表达式，并且知道$1 占位符意味着你需要传递一个包含单个字符串的数组作为第二个参数。即使你能够为第一个查询构建一个解析器，这个查询可能会将你的代码推向“图灵泥潭”，在那里一切皆有可能但没有什么是容易的。你可能还会发现越来越难以确保你遵循了第 40 条建议，即优先选择不精确的类型而不是不准确的类型。随着程序变得更加复杂，出错的可能性也会增加。

有一种更为简单的替代方案：代码生成，或简称代码生成。代码生成是真正的元编程：程序操作代码并生成其他代码。代码生成的魅力在于，它让你可以用任何你喜欢的语言来编写类型操作代码。是的，TypeScript 的类型系统功能强大且灵活，但可能不是完成工作的首选语言。使用代码生成，你可以用普通的 TypeScript 编写类型操作代码。你也可以使用 Python 或 Rust。甚至一个 shell 脚本也可能完成这项工作。

对于我们的 SQL 查询，一个选项是使用 PgTyped 库。它会在你的 TypeScript 中找到适当标记的 SQL 查询，然后与实时数据库进行检查，并生成一个类型声明文件，其中包含输入和输出类型。你将这样用 PgTyped 编写你的查询：

```ts
// books-queries.ts
import { sql } from '@pgtyped/runtime';
const selectLatest = sql`
  SELECT author, MAX(year) 
  FROM books 
  GROUP BY author 
  WHERE publisher=$publisher`;

async function getLatestBookByAuthor(db: Database, publisher: string) {
  const result = await selectLatest.run({ publisher }, db);
  // ^? const result: any[] return result;
}
```

然后运行 pgtyped 命令进行代码生成：

```bash
$ npx pgtyped -c pgtyped.config.json
```

(pgtyped.config.json 是一个文件，用于告诉 PgTyped 如何连接到你的数据库)

这将生成一个新文件，包含某些类型：

```ts
// books-queries.types.ts
/** Types generated for queries found in "books-queries.ts" **/
/** 'selectLatest' parameters type **/
export interface selectLatestParams {
  publisher: string;
}
/** 'selectLatest' return type **/
export interface selectLatestResult {
  author: string;
  year: number;
}
/** 'selectLatest' query type **/
export interface selectLatestQuery {
  params: selectLatestParams;
  result: selectLatestResult;
}
```

并对 books-queries.ts 作出一些修改：

```ts
// books-queries.ts
import { sql } from '@pgtyped/runtime';
import { selectLatestQuery } from './books-queries.types';
export const selectLatestBookByAuthor = sql<selectLatestQuery>`SELECT author, MAX(year) FROM books GROUP BY author WHERE publisher=$publisher`;
async function getLatestBookByAuthor(db: Database, publisher: string) {
  const result = await selectLatestBookByAuthor.run({ publisher }, db);
  // ^? const result: selectLatestResult[]
  return result;
}
```

现在我们的查询已经被正确地类型化了！PgTyped 绝对不是一个简单的程序，但它使用了 TypeScript 编写，采用了标准的数据库和测试库，并且肯定比使用 TypeScript 类型系统编写任何同等强大工具的开发过程要轻松得多。

除了让你在一个更传统的编程系统中工作外，代码生成方法还让你完全控制类型显示的方式。第 56 项中描述的技巧将不再适用于你生成的类型。你可以让它们完全按照你想要的方式呈现。不喜欢 snake_case 类型名称？只需通过 sed 或你选择的文本处理工具进行转换即可。

生成的类型也可能会比你手工编写的 SQL 解析器对 TypeScript 编译器和语言服务的负担要小得多。

代码生成的一个显著成本是它增加了一个必须定期运行的构建步骤，以确保生成的代码保持同步。在 SQL 的情况下，这意味着每当查询发生变化或数据库模式发生变化时，都需要重新运行 pgtyped 命令。通常的做法是在持续集成（CI）系统中进行代码生成，并通过 git diff 确保没有发生变化。你也可以将其作为推送前检查的一部分。

软件工程是一场与复杂性的持续斗争。像 TypeScript 这样的主要编程语言及其生态系统被构建来给你一个对抗复杂性的机会。虽然 TypeScript 的类型级功能令人印象深刻，但它并不是这场斗争中最好的武器。如果你在 TypeScript 中编写了一些复杂的类型级代码，并感觉像是在穿越图灵泥潭，可以考虑是否可以通过生成类型并用更传统的语言编写代码来解决问题。

第 42 项和第 74 项探讨了代码生成如何被用于提高类型安全性并减少维护开销的其他方式。

### 注意事项

- 虽然类型级 TypeScript 是一个非常强大的工具，但它并不总是最适合的任务工具。
- 对于复杂的类型操作，考虑生成代码和类型作为编写类型级代码的替代方案。你的代码生成工具可以用普通的 TypeScript 或其他任何语言编写。
- 在持续集成系统中运行代码生成和 git diff，以确保生成的代码保持同步。
