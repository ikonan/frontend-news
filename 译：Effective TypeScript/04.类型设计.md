# 第 4 章 类型设计

给我看流程图却隐藏数据表，我仍会困惑不解；展示数据表，通常就无需流程图——它们将不言自明。

——弗雷德·布鲁克斯《人月神话》（AddisonWesley Professional 出版）

布鲁克斯的引文措辞虽显陈旧，但观点依然正确：若无法看清代码操作的数据或数据类型，理解代码就会变得困难。类型系统的巨大优势正在于此：通过显式编写类型，你让代码读者能够直观看到它们。而这正是代码可理解的关键所在。

其他章节涵盖了 TypeScript 类型的基础知识：如何使用它们、推断它们、转换它们以及用它们编写声明。本章讨论类型本身的设计。本章的示例都以 TypeScript 为背景编写，但其中大部分理念具有更广泛的适用性。

如果你能精心设计类型，那么流程图自然也会清晰明了。

## 条款 29：优先选择始终表示有效状态的类型

如果类型设计得当，代码编写就会顺理成章。但如果类型设计不当，再多的技巧或文档也于事无补。代码将变得难以理解且容易出错。

高效类型设计的关键在于创建只能表示有效状态的类型。本条目将通过几个示例展示可能出错的情况，并演示如何修正这些问题。

假设你正在构建一个网页应用，该应用允许选择页面、加载页面内容并显示。你可能会这样编写状态：

```ts
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}
```

当你编写渲染页面的代码时，需要考虑所有这些字段：

```ts
function renderPage(state: State) {
  if (state.error) {
    return `Error! Unable to load ${currentPage}: ${state.error}`;
  } else if (state.isLoading) {
    return `Loading ${currentPage}...`;
  }
  return `<h1>${currentPage}</h1>\n${state.pageText}`;
}
```

但这样正确吗？如果 isLoading 和 error 同时被设置会怎样？那意味着什么？是显示加载信息还是错误信息更好？这很难说！因为可用信息不足。

或者，如果你正在编写一个 changePage 函数呢？这里有一个尝试：

```ts
async function changePage(state: State, newPage: string) {
  state.isLoading = true;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const text = await response.text();
    state.isLoading = false;
    state.pageText = text;
  } catch (e) {
    state.error = "" + e;
  }
}
```

这里存在很多问题！以下是其中几个：

- 我们忘记在错误情况下将 state.isLoading 设为 false。
- 我们没有清除 state.error，所以如果之前的请求失败了，你会继续看到那个错误消息，而不是加载消息或新页面。
- 若用户在页面加载期间再次切换页面，结果将难以预料。根据响应返回的顺序，他们可能看到新页面后紧接着出现错误提示，或是只显示第一个页面而看不到第二个页面。

问题在于当前状态既包含信息不足（哪个请求失败了？哪个正在加载？）又包含冗余信息：State 类型允许同时设置 isLoading 和 error 标志，即便这代表一种无效状态。这使得 render()和 changePage()函数都无法良好实现。

以下是更优的应用程序状态表示方案：

```ts
interface RequestPending {
  state: "pending";
}
interface RequestError {
  state: "error";
  error: string;
}
interface RequestSuccess {
  state: "ok";
  pageText: string;
}
type RequestState = RequestPending | RequestError | RequestSuccess;
interface State {
  currentPage: string;
  requests: { [page: string]: RequestState };
}
```

这里采用带标签联合类型（亦称"可辨识联合"）来显式建模网络请求可能处于的不同状态。这个版本的状态定义虽然比之前长三四倍，但其巨大优势在于完全排除了无效状态。当前页面和每个已发出请求的状态都被显式建模，因此 renderPage 和 changePage 函数的实现变得简单明了：

```ts
function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case "pending":
      return `Loading ${currentPage}...`;
    case "error":
      return `Error! Unable to load ${currentPage}: ${requestState.error}`;
    case "ok":
      return `<h1>${currentPage}</h1>\n${requestState.pageText}`;
  }
}
async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: "pending" };
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const pageText = await response.text();
    state.requests[newPage] = { state: "ok", pageText };
  } catch (e) {
    state.requests[newPage] = { state: "error", error: "" + e };
  }
}
```

首次实现中的模糊性已完全消除：当前页面状态一目了然，每个请求都严格处于单一状态。即使用户在请求发出后切换页面也毫无问题——旧请求仍会完成，但不会对界面产生任何影响。

举个更简单却更严峻的案例：2009 年 6 月 1 日在大西洋上空失事的法航 447 航班（空客 A330）。这架

空客采用电传操纵系统，飞行员的操控指令需经计算机处理才能传递至飞机物理控制面。空难发生后，人们开始质疑将生死决策权交给计算机的合理性。两年后从海底打捞出的黑匣子揭示了诸多事故诱因，其中关键因素正是糟糕的状态设计。

空客 A330 的驾驶舱为机长和副驾驶配备了独立操纵杆。"侧杆"用于控制飞机攻角——后拉使飞机爬升，前推则令其俯冲。该机型采用"双重输入"系统，允许两侧操纵杆独立运作。以下是用 TypeScript 建模其状态的示例：

```ts
interface CockpitControls {
  /** Angle of the left side stick in degrees, 0 = neutral, + = forward */
  leftSideStick: number;
  /** Angle of the right side stick in degrees, 0 = neutral, + = forward */
  rightSideStick: number;
}
```

假设你获得这个数据结构，并被要求编写计算当前杆位的 getStickSetting 函数，你会如何实现？

一种处理方式是默认由左侧的机长掌控操作：

```ts
function getStickSetting(controls: CockpitControls) {
  return controls.leftSideStick;
}
```

但如果副驾驶取得控制权呢？或许应该采用偏离零位的操纵杆数值：

```ts
function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  }
  return leftSideStick;
}
```

但这个实现存在一个问题：只有当右侧操纵杆处于中立状态时，我们才能放心地返回左侧设置。因此你需要对此进行检查：

```ts
function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  } else if (rightSideStick === 0) {
    return leftSideStick;
  } // ???
}
```

如果两侧操纵杆都处于非零状态该怎么办？理想情况下它们的数值应该相近，这时你可以直接取平均值：

```ts
function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  } else if (rightSideStick === 0) {
    return leftSideStick;
  }
  if (Math.abs(leftSideStick - rightSideStick) < 5) {
    return (leftSideStick + rightSideStick) / 2;
  } // ???
}
```

但如果数值相差悬殊呢？能直接报错吗？实际上不行：机翼襟翼必须被设置到某个角度！

法航 447 航班事件中，当飞机进入风暴区时，副驾驶默默后拉了他那侧的侧杆操纵器。飞机虽然爬升了高度，但最终失速进入失速状态——这种状态下飞机速度过慢无法有效产生升力。随后飞机开始下坠。

为摆脱失速状态，飞行员接受过将操纵杆前推使飞机俯冲以恢复速度的训练。这正是当时飞行员采取的操作。但副驾驶仍在默默地向后拉他那侧的操作杆。而空客系统的运作机制是这样的：

```ts
function getStickSetting(controls: CockpitControls) {
  return (controls.leftSideStick + controls.rightSideStick) / 2;
}
```

尽管飞行员将操纵杆全力前推，系统却将两方输入取平均导致操作无效。他完全不明白飞机为何没有俯冲。当副驾驶坦白自己的操作时，飞机已失去过多高度无法改出，最终坠入大海，机上 228 人全部遇难。

问题的关键在于：基于这种输入设计，根本不可能正确实现 getStickSetting 函数！这个函数从设计上就注定会失效。多数飞机的双操纵系统是机械联动的——若副驾驶后拉操纵杆，主驾驶的操纵杆也会同步后移。这种控制状态只需简单表示为：

```ts
interface CockpitControls {
  /** Angle of the stick in degrees, 0 = neutral, + = forward */
  stickAngle: number;
}
```

正如本章开篇引用的 Fred Brooks 名言所述，此刻我们的流程图变得一目了然。你根本不需要 getStickSetting 这个函数。

在设计类型时，务必仔细考虑应包含哪些值以及排除哪些值。若仅允许表示有效状态的值，代码将更易于编写，TypeScript 也能更轻松地进行检查。这是一条通用原则，本章其他条款将具体阐述其多种表现形式。

### 要点备忘

- 同时表示有效和无效状态的类型很可能导致代码混乱且容易出错。
- 优先选择仅表示有效状态的类型。即便这些类型更长或更难表达，最终它们会为你节省时间并减少痛苦！

## 条款 30：宽进严出（对输入宽容，对输出严格）

这一理念被称为健壮性原则或波斯特尔定律，得名于乔恩·波斯特尔，他在 TCP 网络协议的背景下提出了该原则：

TCP 实现应遵循健壮性通用原则：发送时要保守，接收时要开放。

类似的规则也适用于函数契约。函数可以宽松地接受各种输入参数，但通常应该对输出结果有更严格的定义。

例如，某个 3D 地图 API 可能提供定位相机并计算边界框视口的方法：

```ts
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;
```

viewportForBounds 的返回结果可以直接传递给 setCamera 来定位相机，这非常方便。

让我们看看这些类型的定义：

```ts
interface CameraOptions {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}
type LngLat =
  | { lng: number; lat: number }
  | { lon: number; lat: number }
  | [number, number];
```

CameraOptions 中的字段都是可选的，因为您可能只想设置中心点或缩放级别，而不改变方位角或俯仰角。LngLat 类型也让 setCamera 在接收参数时更加灵活：您可以传入{lng, lat}对象、{lon, lat}对象，或者如果您确定顺序正确的话，也可以传入`[lng, lat]`数组。这些设计让函数调用变得简单。

viewportForBounds 函数接收另一种"灵活"类型：

```ts
type LngLatBounds =
  | { northeast: LngLat; southwest: LngLat }
  | [LngLat, LngLat]
  | [number, number, number, number];
```

您可以通过指定命名角落、一对经纬度坐标，或者如果您确信顺序正确的话使用四元组来界定范围。由于 LngLat 已经支持三种形式，LngLatBounds 至少有 19 种可能的组合形式（3×3 + 3×3 + 1）。确实非常灵活！

现在让我们编写一个函数，调整视口以适应 GeoJSON 要素，并将新视口存储在 URL 中（假设我们有一个辅助函数来计算 GeoJSON 要素的边界框）：

```ts
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f); // helper function
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {
    center: { lat, lng },
    zoom,
  } = camera;
  // Property 'lat' does not exist on type .
  // \~\~\~ Property 'lng' does not exist on type ..

  zoom; // ^? const zoom: number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

糟糕！只有 zoom 属性存在，但其类型被推断为 number|undefined，这也有问题。关键在于 viewportForBounds 的类型声明表明，它不仅在接收参数时很宽松，在返回结果时也同样宽松。使用相机结果的唯一类型安全方式是为联合类型的每个组成部分引入代码分支。

包含大量可选属性和联合类型的返回类型使得 viewportForBounds 难以使用。其广泛的参数类型虽然方便，但宽泛的返回类型却不然。一个更友好的 API 应该对输出结果保持严格。

实现这一目标的一种方法是区分坐标的规范格式。遵循 JavaScript 区分"数组"和"类数组"的惯例（条款 17），您可以区分 LngLat 和 LngLatLike 类型。您还可以区分完整定义的 Camera 类型与 setCamera 接受的局部版本：

```ts
interface LngLat {
  lng: number;
  lat: number;
}
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];
interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}
interface CameraOptions extends Omit<Partial<Camera>, "center"> {
  center?: LngLatLike;
}

type LngLatBounds =
  | { northeast: LngLatLike; southwest: LngLatLike }
  | [LngLatLike, LngLatLike]
  | [number, number, number, number];
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera;
```

宽松的 CameraOptions 类型适配了更严格的 Camera 类型。在 setCamera 中使用 Partial<Camera> 作为参数类型在此处并不适用，因为您确实需要允许 center 属性使用 LngLatLike 对象。而且您不能写成"CameraOptions extends Partial<Camera>"，因为 LngLatLike 是 LngLat 的超类型而非子类型。（如果这感觉反直觉，请参阅条款 7 进行复习。）

如果这看起来太复杂，你也可以选择以略微重复为代价，显式写出类型：

```ts
interface CameraOptions {
  center?: LngLatLike;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}
```

无论采用哪种方式，通过这些新的类型声明，focusOnFeature 函数都能通过类型检查：

```ts
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {
    center: { lat, lng },
    zoom,
  } = camera; // OK
  // ^? const zoom: number
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

这次 zoom 的类型是 number，而非 number|undefined。现在 viewportForBounds 函数使用起来容易多了。如果还有其他生成 bounds 的函数，你同样需要引入规范形式，并区分 LngLatBounds 和 LngLatBoundsLike。

允许边界框有 19 种可能形式是个好设计吗？或许不是。但如果你正在为这样做的库编写类型声明，就需要对其行为进行建模。只是千万别让返回类型也多达 19 种！

这种模式最常见的应用之一是在以数组作为参数的函数中。例如，下面这个函数用于计算数组元素的总和：

数组元素：

```ts
function sum(xs: number[]): number {
  let sum = 0;
  for (const x of xs) {
    sum += x;
  }
  return sum;
}
```

number 的返回类型相当严格。很好！但 number\[\]的参数类型呢？我们并没有使用它的许多功能，因此可以放宽限制。第 17 条讨论了 ArrayLike 类型，而 ArrayLike 在这里会很适用。第 14 条讨论了只读数组，readonly number\[\]作为参数类型也会很合适。

但如果只需要遍历参数，那么 Iterable 就是最宽泛的类型：

```ts
function sum(xs: Iterable<number>): number {
  let sum = 0;
  for (const x of xs) {
    sum += x;
  }
  return sum;
}
```

对于数组而言，其表现与预期一致：

```ts
const six = sum([1, 2, 3]); // ^? const six: number
```

此处使用 Iterable 而非 Array 或 ArrayLike 的优势在于，它同样支持生成器表达式：

```ts
function* range(limit: number) {
  for (let i = 0; i < limit; i++) {
    yield i;
  }
}
const zeroToNine = range(10); // ^? const zeroToNine: Generator<number, void, unknown>
const fortyFive = sum(zeroToNine); // Ok, result is 45
```

若函数仅需遍历参数，采用 Iterable 类型可使其兼容生成器。使用 for-of 循环时，无需修改任何现有代码。

### 要点备忘

- 输入类型通常比输出类型更宽泛。可选属性和联合类型在参数类型中比在返回类型中更为常见。
- 避免使用宽泛的返回类型，这会让客户端使用起来很别扭。
- 要在参数和返回类型之间复用类型，可以引入规范形式（用于返回类型）和宽松形式（用于参数）。
- 如果只需要遍历函数参数，请使用 Iterable 而非 T\[\]。

## 第 31 条：不要在文档中重复类型信息

这段代码有什么问题？

```ts
/**
 * 返回一个包含前景色的字符串。
 * 该函数可接受零个或一个参数。若不传入参数，则返回标准前景色；若传入一个参数，则返回特定页面的前景色。
 */
function getForegroundColor(page?: string) {
  return page === "login" ? { r: 127, g: 127, b: 127 } : { r: 0, g: 0, b: 0 };
}
```

代码和注释不一致！缺乏更多上下文很难判断哪一方是正确的，但显然存在问题。正如我的一位教授常说："当代码和注释出现矛盾时，往往两者都是错的！"

假设代码表现的是预期行为。那么这个注释存在几个问题：

- 注释声称函数会返回字符串格式的颜色值，但实际上返回的是{r, g, b}格式的对象。
- 它解释了该函数接受零个或一个参数，这一点从类型签名中已经显而易见。
- 这显得冗长多余：注释内容比函数声明和实现还要长！

TypeScript 的类型注解系统设计得简洁、描述性强且易于阅读。其开发者是拥有数十年经验的语言专家。在表达函数输入输出类型方面，它几乎肯定比你的文字描述更胜一筹！

而且由于你的类型注解会经过 TypeScript 编译器检查，它们永远不会与实现不同步。也许 getForegroundColor 曾经返回字符串，但后来改为返回对象。进行修改的人可能忘记更新那段冗长的注释。

除非强制同步，否则任何事物都无法保持同步。通过类型注解，TypeScript 的类型检查器就是这种强制力！如果将类型信息放在注解而非文档中，就能极大提高这些信息会随着代码演变而保持正确的信心。

更好的注释可能是这样的：

```ts
/**  获取应用程序或特定页面的前景色。 */
function getForegroundColor(page?: string): Color {
  //
}
```

若要描述特定参数，请使用@param JSDoc 注解。更多内容详见条款 68。

关于不可变性的注释同样值得怀疑：

```ts
/**  按数字值对字符串进行排序（例如 "2" < "10"）。不会修改 nums 数组。*/
function sortNumerically(nums: string[]): string[] {
  return nums.sort((a, b) => Number(a) - Number(b));
}
```

注释称该函数不会修改其参数，但数组的 sort 方法会就地操作，实际上确实会修改。注释中的声明并不具备约束力。

如果改用 readonly 声明参数（条款 14），就能让 TypeScript 来强制执行这一约定：

```ts
/**  Sort the strings by numeric value (i.e. "2" < "10"). */
function sortNumerically(nums: readonly string[]): string[] {
  return nums.sort((a, b) => Number(a) - Number(b));
  // \~ \~ Property 'sort' does not exist on 'readonly string[]'.
}
```

该函数的正确实现应该复制数组或使用不可变的 toSorted 方法：

```ts
/** Sort the strings by numeric value (i.e. "2" < "10"). */
function sortNumerically(nums: readonly string[]): string[] {
  return nums.toSorted((a, b) => Number(a) - Number(b)); // Ok
}
```

注释的注意事项同样适用于变量命名。避免在名称中标注类型：与其将变量命名为 ageNum，不如直接命名为 age 并确保其类型确实为数字。

带有单位的数字是个例外。如果单位不明确，你可能需要将它们包含在变量或属性名中。例如，\`timeMs\` 比单纯的 \`time\` 更清晰，\`temperatureC\` 也比 \`temperature\` 更明确。第 64 条描述了"品牌"模式，它提供了一种更类型安全的方式来建模单位。

### 要点备忘

- 避免在注释和变量名中重复类型信息。最好的情况下这会与类型声明冗余，最坏的情况下则会导致信息冲突。
- 使用 \`readonly\` 声明参数，而不是口头说明不会修改它们。
- 如果类型本身无法明确单位，考虑在变量名中包含单位（例如 \`timeMs\` 或 \`temperatureC\`）。

## 条款 32：避免在类型别名中包含 null 或 undefined

这段代码中，可选链（?.）是否必要？user 是否可能为 null？

```ts
function getCommentsForUser(comments: readonly Comment[], user: User) {
  return comments.filter((comment) => comment.userId === user?.id);
}
```

即使假设启用了 strictNullChecks，在没有看到 User 定义的情况下也无法断言。如果它是允许 null 或 undefined 的类型别名，那么就需要使用可选链：

```ts
type User = { id: string; name: string } | null;
```

另一方面，如果它是简单的对象类型，则不需要：

```ts
interface User {
  id: string;
  name: string;
}
```

作为一般规则，最好避免允许空值或未定义值的类型别名。虽然违反这条规则不会让类型检查器困惑，但阅读代码的人会感到困惑。当我们看到像 User 这样的类型名称时，会默认它代表一个用户，而不是可能代表一个用户。

如果出于某些原因必须在类型别名中包含空值，请为代码阅读者考虑，使用一个明确无歧义的名称：

```ts
type NullableUser = { id: string; name: string } | null;
```

但当 User|null 这种更简洁且普遍可识别的语法存在时，何必多此一举呢？

```ts
function getCommentsForUser(comments: readonly Comment[], user: User | null) {
  return comments.filter((comment) => comment.userId === user?.id);
}
```

这条规则针对的是类型别名的顶层定义。它并不涉及较大对象中可为空或未定义（或可选）的属性：

```ts
type BirthdayMap = { [name: string]: Date | undefined };
```

千万别这么做：

```ts
type BirthdayMap = { [name: string]: Date | undefined } | null;
```

在对象类型中避免使用空值和可选字段也有其道理，但这将是第 33 条和第 37 条要讨论的话题。目前而言，请避免使用会让代码阅读者感到困惑的类型别名。优先选择那些能明确表示某种含义的类型别名，而不是既能表示某种含义又能表示空值或未定义的类型别名。

### 要点备忘

- 避免定义包含空值或未定义的类型别名。

## 第 33 条：将空值推到类型的边缘

当你首次启用严格空值检查时，可能会觉得必须在代码各处添加大量检查 null 和 undefined 值的 if 语句。这通常是因为空值与非空值之间的关系是隐式的：当变量 A 非空时，你知道变量 B 也必然非空，反之亦然。这些隐式关系不仅会让代码阅读者困惑，也会让类型检查器难以理解。

处理完全为空或完全非空的值要比处理混合状态简单得多。你可以通过将空值推到结构边缘来建立这种模型。

假设你想计算一组数字的最小值和最大值，我们称之为"范围"。以下是初步尝试：

```ts
// @strictNullChecks: false
function extent(nums: Iterable<number>) {
  let min, max;
  for (const num of nums) {
    if (!min) {
      min = num;
      max = num;
    } else {
      min = Math.min(min, num);
      max = Math.max(max, num);
    }
  }

  return [min, max];
}
```

这段代码能通过类型检查（未启用严格空值检查），其推断返回类型为 `number[]` 看似合理。但它存在一个错误和一个设计缺陷：

- 若最小值或最大值为零，可能会被覆盖。例如，`extent([0, 1, 2])` 将返回 `[1, 2]` 而非 `[0, 2]`。
- 若数值数组为空，该函数将返回 `[undefined, undefined]`。

这种包含多个未定义值的对象会让客户端难以处理，正是本条目所不推荐的类型。通过阅读源码我们可知，min 和 max 要么同时未定义，要么同时有值，但这一信息并未体现在类型系统中。

开启 strictNullChecks 会使未定义值的问题更加明显：

```ts
function extent(nums: Iterable<number>) {
  let min, max;
  for (const num of nums) {
    if (!min) {
      min = num;
      max = num;
    } else {
      min = Math.min(min, num);
      max = Math.max(max, num);
      // \~\~ Argument of type 'number | undefined' is not
      // assignable to parameter of type 'number'
    }
  }
  return [min, max];
}
```

extent 函数的返回类型现在被推断为(number | undefined)\[\]，这使得设计缺陷更加明显。这很可能会在调用 extent 时表现为

类型错误：

```ts
const [min, max] = extent([0, 1, 2]);
const span = max - min; // \~ Object is possibly 'undefined'
```

extent 实现中的错误源于你排除了 min 值为 undefined 的情况，但未对 max 做同样处理。两者本应同时初始化，但类型系统中并未体现这一信息。虽然可以通过增加对 max 的检查来消除错误，但这只会加剧原有缺陷。

更优的解决方案是将 min 和 max 放入同一个对象，并确保该对象要么完全为 null，要么完全非 null：

```ts
function extent(nums: Iterable<number>) {
  let minMax: [number, number] | null = null;
  for (const num of nums) {
    if (!minMax) {
      minMax = [num, num];
    } else {
      const [oldMin, oldMax] = minMax;
      minMax = [Math.min(num, oldMin), Math.max(num, oldMax)];
    }
  }
  return minMax;
}
```

返回类型现在是 `[number, number] | null`，这让客户端使用起来更加方便。可以使用非空断言来获取 `min` 和 `max`：

```ts
const [min, max] = extent([0, 1, 2])!;
const span = max - min; // OK
```

or a single check:

```ts
const range = extent([0, 1, 2]);
if (range) {
  const [min, max] = range;
  const span = max - min; // OK
}
```

通过使用单个对象来跟踪范围，我们改进了设计，帮助 TypeScript 理解空值之间的关系，并修复了一个 bug：现在 `if (!minMax)` 检查不会有问题了。

（下一步可能是防止将非空列表传递给 `extent` 函数，这样就可以完全消除返回 `null` 的可能性。第 64 条介绍了一种在 TypeScript 类型系统中表示非空列表的方法。）
混合使用可空与非空值也可能导致类设计出现问题。例如，假设有一个类同时表示论坛用户及其帖子：

```ts
class UserPosts {
  user: UserInfo | null;
  posts: Post[] | null;
  constructor() {
    this.user = null;
    this.posts = null;
  }
  async init(userId: string) {
    return Promise.all([
      async () => (this.user = await fetchUser(userId)),
      async () => (this.posts = await fetchPostsForUser(userId)),
    ]);
  }
  getUserName() {
    // ...?
  }
}
```

当两个网络请求正在加载时，用户属性和帖子属性都将为空。任何时候，它们可能同时为空、其中一个为空或两者都不为空——存在四种可能性。这种复杂性会渗透到类的每个方法中。这种设计几乎必然会导致混淆、大量空值检查以及错误。

更优的设计是等待类所需的所有数据都准备就绪：

```ts
class UserPosts {
  user: UserInfo;
  posts: Post[];
  constructor(user: UserInfo, posts: Post[]) {
    this.user = user;
    this.posts = posts;
  }
  static async init(userId: string): Promise<UserPosts> {
    const [user, posts] = await Promise.all([
      fetchUser(userId),
      fetchPostsForUser(userId),
    ]);
    return new UserPosts(user, posts);
  }
  getUserName() {
    return this.user.name;
  }
}
```

现在 UserPosts 类完全处于非空状态，编写正确的方法变得轻而易举。当然，如果需要在数据部分加载时执行操作，则仍需处理多种可空与非空状态。

不要试图用 Promise 来替代可为空的属性。这往往会导致代码更加令人困惑，并迫使所有方法都变成异步的。Promise 能明确加载数据的代码逻辑，但对于使用这些数据的类却容易产生相反的效果。

### 要点备忘

- 避免设计出某个值是否为空隐式关联到另一个值是否为空的结构。
- 通过将较大对象设为全空或全非空，将空值推到 API 的边界处。这样能让代码对人类阅读者和类型检查器都更加清晰。
- 考虑创建一个全非空的类，并在所有值都可用时才构造它。

## 第 34 条：优先使用接口联合而非联合类型的接口

如果你创建的接口属性包含联合类型，就应该考虑是否将其改为由更精确接口组成的联合类型会更合理。

假设你正在开发一个矢量绘图程序，需要为具有特定几何类型的图层定义接口：

```ts
interface Layer {
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}
```

layout 字段控制图形的绘制方式和位置（圆角？直角？），而 paint 字段控制样式（线条是蓝色？粗线？细线？虚线？）。

设计初衷是让图层（Layer）的布局属性与绘制属性相互匹配。例如填充布局（FillLayout）应当搭配填充绘制（FillPaint），线条布局（LineLayout）应当搭配线条绘制（LinePaint）。但当前版本的 Layer 类型却允许填充布局与线条绘制混用。这种可能性会增加库的使用错误率，使得该接口难以稳定运作。

更优的建模方式是为每种图层类型建立独立接口：

```ts
interface FillLayer {
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
```

通过这种方式定义 Layer 类型，就能彻底杜绝布局属性与绘制属性混用的情况。这正符合条款 29 所倡导的"优先采用仅能表示有效状态的类型"原则。

迄今为止，这种模式最常见的应用就是"标签联合"（或称"可辨识联合"）。具体表现为其中一个属性是由字符串字面量类型组成的联合类型：

```ts
interface Layer {
  type: "fill" | "line" | "point";
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}
```

和之前一样，如果类型设为'fill'却搭配 LineLayout 和 PointPaint，这合理吗？显然不合理。将 Layer 转换为联合接口类型以排除这种可能性：

```ts
interface FillLayer {
  type: "fill";
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  type: "line";
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  type: "paint";
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
```

type 属性充当"标签"或"判别式"。它可以在运行时被访问，并为 TypeScript 提供足够信息来确定你正在使用联合类型中的哪个元素。在此，TypeScript 能够基于标签在 if 语句中收窄 Layer 的类型：

```ts
function drawLayer(layer: Layer) {
  if (layer.type === "fill") {
    const { paint } = layer; // ^? const paint: FillPaint
    const { layout } = layer; // ^? const layout: FillLayout
  } else if (layer.type === "line") {
    const { paint } = layer; // ^? const paint: LinePaint
    const { layout } = layer; // ^? const layout: LineLayout
  } else {
    const { paint } = layer; // ^? const paint: PointPaint
    const { layout } = layer; // ^? const layout: PointLayout
  }
}
```

通过正确建模该类型中属性间的关系，你帮助 TypeScript 验证了代码的正确性。若使用最初的 Layer 定义，相同代码将会充斥着类型断言。

由于标签联合类型与 TypeScript 的类型检查器配合得天衣无缝，它们在 TypeScript 代码中无处不在。请识别这种模式并在可能时应用它。如果你能用标签联合类型表示某个数据类型，这通常都是个好主意。

若将可选字段视为其类型与 undefined 的联合类型，那么它们同样符合"联合类型接口"的模式。考虑以下类型：

```ts
interface Person {
  name: string;
  // These will either both be present or not be present
  placeOfBirth?: string;
  dateOfBirth?: Date;
}
```

正如第 31 条所述，带有类型信息的注释强烈暗示此处可能存在问题。placeOfBirth 与 dateOfBirth 字段之间存在某种关联性，而你尚未向 TypeScript 阐明这种关系。

更优的建模方式是将这两个属性移至同一个对象中。这类似于将空值移至边界处理的策略（第 33 条）：

```ts
interface Person {
  name: string;
  birth?: { place: string; date: Date };
}
```

现在 TypeScript 会对存在出生地但缺少出生日期的情况报错：

```ts
const alanT: Person = {
  name: "Alan Turing",
  birth: {
    // Property 'date' is missing in type
    // '{ place: string; }' but required in type
    // '{ place: string; date: Date; }'
    //
    place: "London",
  },
};
```

此外，接收 Person 对象的函数只需进行一次检查即可：

```ts
function eulogize(person: Person) {
  console.log(person.name);
  const { birth } = person;
  if (birth) {
    console.log(`was born on ${birth.date} in ${birth.place}.`);
  }
}
```

如果类型结构不受你控制（可能来自 API 接口），你仍然可以通过熟悉的接口联合方式来建模这些字段之间的关系：

```ts
interface Name {
  name: string;
}
interface PersonWithBirth extends Name {
  placeOfBirth: string;
  dateOfBirth: Date;
}

type Person = Name | PersonWithBirth;
```

现在你将获得与嵌套对象类似的部分优势：

```ts
function eulogize(person: Person) {
  if ("placeOfBirth" in person) {
    person; // ^? (parameter) person: PersonWithBirth
    const { dateOfBirth } = person; // OK // ^? const dateOfBirth: Date
  }
}
```

这两种情况下，类型定义都能使属性间的关系更加清晰。

虽然可选属性通常很有用，但在接口中添加它们之前应当三思。第 37 条将深入探讨可选字段的更多弊端。

### 要点备忘

- 包含多个联合类型属性的接口往往是错误设计，因为它们会模糊这些属性之间的关系。
- 接口的联合类型更为精确，且能被 TypeScript 理解。
- 使用带标签的联合类型来辅助控制流分析。由于它们得到良好支持，这种模式在 TypeScript 代码中无处不在。
- 考虑是否可以将多个可选属性分组，以更准确地建模您的数据。

## 第 35 条：优先选择比字符串类型更精确的替代方案

回想第 7 条，类型的域是指可分配给该类型的值的集合。字符串类型的域非常庞大："x"和"y"属于它，《白鲸记》的完整文本（以"叫我以实玛利..."开头，约 120 万个字符）也属于它。当您声明一个字符串类型的变量时，应该考虑是否有更窄的类型会更合适。

假设您正在构建一个音乐收藏集，并想为专辑定义一个类型。以下是一个尝试：

```ts
interface Album {
  artist: string;
  title: string;
  releaseDate: string; // YYYY-MM-DD recordingType: string; // E.g., "live" or "studio"
}
```

字符串类型的普遍使用以及注释中的类型信息（条款 31）都强烈表明这个接口设计存在问题。以下是可能出错的情况：

```ts
const kindOfBlue: Album = {
  artist: "Miles Davis",
  title: "Kind of Blue",
  releaseDate: "August 17th, 1959", // ops!
  recordingType: "Studio", // Oops
}; //OK
```

releaseDate 字段的格式与注释说明不符，且"Studio"本应小写却采用了首字母大写。但由于这些值都是字符串类型，该对象仍可赋值给 Album 类型，类型检查器不会报错。

这种宽泛的字符串类型也可能掩盖有效 Album 对象的错误。例如：

```ts
function recordRelease(title: string, date: string) {
  /* ... */
}
recordRelease(kindOfBlue.releaseDate, kindOfBlue.title); // OK, should be error
```

在调用 recordRelease 时参数顺序颠倒，但由于两者都是字符串类型，类型检查器不会发出警告。由于字符串类型的泛滥，这类代码有时被称为"字符串强类型"（条款 38 将探讨任何类型的重复位置参数都可能引发问题，而不仅限于字符串类型）。

能否将类型范围收窄以避免这类问题？虽然《白鲸记》全文作为艺术家姓名或专辑标题显得冗长，但至少是合理的。因此 string 类型适用于这些字段。对于 releaseDate 字段，最好使用 Date 对象以避免格式问题。最后，对于 recordingType 字段，可以定义一个仅包含两个值的联合类型（也可以使用枚举，但我通常建议避免使用枚举，详见第 72 条）：

```ts
type RecordingType = "studio" | "live";
interface Album {
  artist: string;
  title: string;
  releaseDate: Date;
  recordingType: RecordingType;
}
```

经过这些调整后，TypeScript 能够进行更彻底的错误检查：

```ts
const kindOfBlue: Album = {
  artist: "Miles Davis",
  title: "Kind of Blue",
  releaseDate: new Date("1959-08-17"),
  recordingType: "Studio",
  // Type '"Studio"' is not assignable to type 'RecordingType'
};
```

这种方案的优势不仅在于更严格的类型检查。首先，显式定义类型能确保其含义在传递过程中不会丢失。例如，若想筛选特定录制类型的专辑，可以定义如下函数：

```ts
function getAlbumsOfType(recordingType: string): Album[] {
  //
}
```

该函数的调用者如何知道 recordingType 应该是什么？它仅仅是个字符串。而说明其应为'studio'或'live'的注释隐藏在 Album 类型定义中，用户可能根本想不到去查看。

其次，明确定义类型可以让你为其附加文档（参见第 68 条）：

```ts
/* What type of environment was this recording made in? */
type RecordingType = "live" | "studio";
```

当你将 getAlbumsOfType 改为接收 RecordingType 参数时，调用方能够点击查看相关文档（见图 4-1）。

[![PdfImage.png](https://i.postimg.cc/3rSGqKDd/PdfImage.png)](https://postimg.cc/G9D98nKC)

图 4-1. 使用命名类型而非字符串，使得编辑器能够显示附加在该类型上的文档。

字符串的另一种常见误用是在函数参数中。假设你想编写一个函数，用于提取数组中某个字段的所有值。Underscore 和 Ramda 工具库将其称为 pluck 函数：

```ts
function pluck(records, key) {
  return records.map((r) => r[key]);
}
```

你会如何为这个类型进行定义？这里有一个初步尝试：

```ts
function pluck(records: any[], key: string): any[] {
  return records.map((r) => r[key]);
}
```

这个类型检查通过了，但并不理想。其中的 any 类型存在问题，特别是返回值部分（参见第 43 条）。改进类型签名的第一步是引入泛型类型参数：

```ts
function pluck<T>(records: T[], key: string): any[] {
  return records.map((r) => r[key]);
  // Element implicitly has an 'any' type
  // because type '{}' has no index signature
}
```

TypeScript 现在提示 key 的 string 类型过于宽泛。这个提示是正确的：如果你传入一个 Albums 数组，那么 key 的有效值只有四个（"artist"、"title"、"releaseDate"和"recordingType"），而不是所有可能的字符串。这正是 keyof Album 类型所表达的：

```ts
type K = keyof Album;
// ^? type K = keyof Album
// (equivalent to "artist" | "title" | "releaseDate" | "recordingType")
```

因此解决方案是将 string 替换为 keyof T：

```ts
function pluck<T>(records: T[], key: keyof T) { return records.map(r => r[key]);
```

这通过了类型检查。我们还让 TypeScript 自动推断返回类型。它是如何做到的？如果你在编辑器中悬停查看 pluck 函数，推断出的类型是：

```ts
function pluck<T>(record: T[], key: keyof T): T[keyof T][];
```

`T[keyof T]`表示 `T` 中任何可能值的类型。如果传入单个字符串作为键，这个范围就太宽泛了。例如：

```ts
const releaseDates = pluck(albums, "releaseDate");
// ^? const releaseDates: (string | Date)[]
```

类型应该是 Date\[\]，而非(string | Date)\[\]。虽然 keyof T 比 string 精确得多，但范围仍然过大。要进一步缩小范围，我们需要引入第二个类型参数，它是 keyof T 的子类型（可能是一个单值）：

```ts
function pluck<T, K extends keyof T>(records: T[], key: K): T[K][] {
  return records.map((r) => r[key]);
}
```

现在这个类型签名完全正确了。我们可以通过几种不同方式调用 pluck 来验证这一点：

```ts
const dates = pluck(albums, "releaseDate");
// ^? const dates: Date[]
const artists = pluck(albums, "artist");
// ^? const artists: string[]
const types = pluck(albums, "recordingType");
// ^? const types: RecordingType[]
const mix = pluck(albums, Math.random() < 0.5 ? "releaseDate" : "artist"); // ^? const mix: (string | Date)[]
const badDates = pluck(albums, "recordingDate");
//
// Argument of type '"recordingDate"' is not assignable to parameter of typ
```

语言服务甚至能够为 Album 对象的键提供自动补全功能（如图 4-2 所示）。

![](https://cdn-mineru.openxlab.org.cn/extract/87e44958-cc2c-4024-82d3-3455459e51c9/952f914a572db7d9159f4123fba2cfcbbc05cbf426686859f3cccd23c289074b.jpg)
图 4-2. 使用 keyof Album 作为参数类型而非 string 类型，能在编辑器中获得更完善的自动补全体验。

string 类型存在与 any 类似的问题：若使用不当，它会允许无效值并掩盖类型间的关系。这会阻碍类型检查器工作，并可能隐藏实际错误。TypeScript 定义 string 子集的能力，是为 JavaScript 代码引入类型安全性的强大方式。使用更精确的类型既能捕获错误，又能提升代码可读性。

本条目聚焦于有限字符串集合，但 TypeScript 同样支持对无限集合（例如所有以"http:"开头的字符串）进行建模。这类场景需要使用模板字面量类型，这将是条目 54 讨论的主题。

### 要点备忘

- 避免使用"字符串类型"的代码。在并非所有字符串都适用的情况下，优先选择更合适的类型。
- 如果字符串字面量联合类型能更准确地描述变量的取值范围，就优先使用它而不是普通的字符串类型。这样能获得更严格的类型检查并提升开发体验。
- 对于预期作为对象属性的函数参数，优先使用 keyof T 而非 string 类型。

## 条款 36：为特殊值使用独立类型

JavaScript 的字符串分割方法是一种便捷的方式，可以通过分隔符将字符串拆分开来：

> `'abcde'.split('c') [ 'ab', 'de' ]`

让我们编写一个类似 split 的功能，但针对数组。以下是一个尝试：

```ts
function splitAround<T>(vals: readonly T[], val: T): [T[], T[]] {
  const index = vals.indexOf(val);
  return [vals.slice(0, index), vals.slice(index + 1)];
}
```

它的运行效果正如你所预期：

> splitAround([1, 2, 3, 4, 5], 3) [ [ 1, 2 ], [ 4, 5 ] ]

然而，如果你尝试对一个不在列表中的元素使用 splitAround，它会做出相当出人意料的行为：

> splitAround([1, 2, 3, 4, 5], 6) [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 4, 5 ] ]

虽然这种情况下函数应该如何处理并不完全明确，但绝对不应该是这样！如此简单的代码为何会导致如此奇怪的行为？

根本问题在于，当数组中找不到元素时，indexOf 会返回-1。这是一个特殊值：它表示失败而非成功。但-1 只是个普通数字。你可以把它传给 Array 的 slice 方法，也可以对它进行算术运算。当你向 slice 传递负数时，它会将其解释为从数组末尾倒数的位置。而当你给-1 加 1 时，得到的是 0。因此这里实际执行的是：

```ts
[vals.slice(0, -1), vals.slice(0)];
```

第一次 slice 调用会返回除最后一个元素外的整个数组，第二次 slice 调用则返回数组的完整副本。

这种行为是个缺陷。更遗憾的是 TypeScript 没能帮我们发现这个问题。根源在于 indexOf 找不到元素时返回了-1，而不是像 null 这样的值。为什么会这样？

若不乘坐时光机回到 1995 年的网景公司办公室，我们很难确知答案。但可以推测！JavaScript 深受 Java 影响，而 Java 的 indexOf 也有相同行为。在 Java（和 C 语言）中，函数不能返回基本类型或 null——只有对象（或指针）才可为空。因此这种行为可能源自 Java 的技术限制，而 JavaScript 本不必继承这种限制。

在 JavaScript（和 TypeScript）中，函数返回数字或 null 是没有问题的。因此我们可以封装 indexOf：

```ts
function safeIndexOf<T>(vals: readonly T[], val: T): number | null {
  const index = vals.indexOf(val);
  return index === -1 ? null : index;
}
```

如果将其插入到我们最初定义的 splitAround 中，会立即出现两个类型错误：

```ts
function splitAround<T>(vals: readonly T[], val: T): [T[], T[]] {
  const index = safeIndexOf(vals, val);
  return [vals.slice(0, index), vals.slice(index + 1)]; // 'index' is possibly 'null'
}
```

这正是我们想要的！使用 indexOf 时始终需要考虑两种情况。对于内置版本，TypeScript 无法区分它们，但使用封装版本后就能区分。这里它发现我们只考虑了数组包含该值的情况。

解决方案是显式处理另一种情况：

```ts
function splitAround<T>(vals: readonly T[], val: T): [T[], T[]] {
  const index = safeIndexOf(vals, val);
  if (index === null) {
    return [[...vals], []];
  }
  return [vals.slice(0, index), vals.slice(index + 1)]; // Ok
}
```

这种行为是否正确值得商榷，但至少 TypeScript 迫使我们展开了这场讨论！

第一个实现方案的根本问题在于：indexOf 方法存在两种截然不同的情况，但特殊情况下返回的-1 值与常规情况下返回的数字值具有相同类型。这意味着从 TypeScript 的视角看这只是一个单一场景，因此无法检测出我们未对-1 进行校验的情况。

在设计类型时这种情况经常出现。假设你有一个描述商品的类型：

```ts
interface Product {
  title: string;
  priceDollars: number;
}
```

随后你发现某些商品价格未知。若将该字段设为可选或改为 number|null 类型可能需要数据迁移和大量代码修改，于是你转而引入一个特殊值：

```ts
interface Product {
  title: string;
  /*_ 产品的美元价格，若价格未知则为 -1 */
  priceDollars: number;
}
```

你将代码部署到生产环境。一周后，老板勃然大怒，质问为何在向客户卡里充值。团队紧急回滚变更，而你被要求撰写事故报告。回想起来，当初若能妥善处理那些类型错误该多省事！

选择领域内特殊值（如-1、0 或空字符串""）本质上类似于关闭 strictNullChecks 选项。当 strictNullChecks 关闭时，你可以将 null 或 undefined 赋值给任意类型：

```ts
// @strictNullChecks: false
const truck: Product = {
  title: "Tesla Cybertruck",
  priceDollars: null, // Ok
};
```

这会导致大量错误逃过类型检查器的检测，因为 TypeScript 无法区分 number 和 number|null 类型。此时 null 是所有类型的合法值。当启用 strictNullChecks 后，TypeScript 就能区分这些类型，从而发现大量潜在问题。若选择领域内特殊值（如-1），实际上是在类型系统中人为制造了一个非严格区域。虽然便捷，但终究不是最佳选择。

在某些情况下，使用 null 和 undefined 可能并非表示特殊状态的最佳方式，因为它们的准确含义往往取决于具体语境。例如，当建模网络请求状态时，若用 null 表示错误状态、undefined 表示待定状态，这种设计就欠妥。更好的做法是使用带标签的联合类型来更明确地表示这些特殊状态。第 29 条将对此案例进行详细探讨。

### 要点备忘

- 应当避免使用可被赋值给常规类型的特殊值，这会削弱 TypeScript 发现代码缺陷的能力。
- 推荐使用 null 或 undefined 作为特殊值，而非 0、-1 或空字符串等替代方案。
- 若 null 或 undefined 的含义不够明确，建议考虑采用带标签的联合类型来替代它们。

## 条款 37：限制可选属性的使用

随着类型演进，你不可避免地会想要为它们添加新属性。为了避免使现有代码或数据失效，你可能会选择将这些属性设为可选。虽然这有时是正确的选择，但可选属性确实会带来代价，在添加之前应当三思。

假设你有一个 UI 组件，用于显示带有标签和单位的数字。例如"高度：12 英尺"或"速度：10 英里/小时"：

```ts
interface FormattedValue {
  value: number;
  units: string;
}
function formatValue(value: FormattedValue) {
  /* ... */
}
```

你使用这个组件构建了一个大型 Web 应用。其中部分功能可能用于显示徒步旅行的格式化信息（如"5 英里，时速 2 英里"）：

```ts
interface Hike {
  miles: number;
  hours: number;
}
function formatHike({ miles, hours }: Hike) {
  const distanceDisplay = formatValue({ value: miles, units: "miles" });
  const paceDisplay = formatValue({ value: miles / hours, units: "mph" });
  return `${distanceDisplay} at ${paceDisplay}`;
}
```

某天你了解了公制单位系统，并决定支持它。为了同时兼容公制和英制单位，你在 FormattedValue 中添加了对应的选项。组件会在显示数值前根据需要执行单位换算。为了最小化对现有代码和测试的改动，你决定将该属性设为可选：

```ts
type UnitSystem = "metric" | "imperial";
interface FormattedValue {
  value: number;

  units: string;
  /*_ default is imperial */
  unitSystem?: UnitSystem;
}
```

为了让用户配置此项，我们还需要在全应用配置中指定单位系统：

```ts
interface AppConfig {
  darkMode: boolean; // ... other settings .
  // /*_ default is imperial */
  unitSystem?: UnitSystem;
}
```

现在我们可以更新 formatHike 方法来支持公制单位：

```ts
function formatHike({ miles, hours }: Hike, config: AppConfig) {
  const { unitSystem } = config;
  const distanceDisplay = formatValue({
    value: miles,
    units: "miles",
    unitSystem,
  });
  const paceDisplay = formatValue({
    value: miles / hours,
    units: "mph", // forgot unitSystem, o0ps!
  });
  return `${distanceDisplay} at ${paceDisplay}`;
}
```

我们在一次 formatValue 调用中设置了 unitSystem 参数，但另一次调用中却没有。这个错误意味着使用公制的用户会看到英制和公制单位混用的情况。

事实上，我们的设计正是这类错误的温床。每次使用 formatValue 组件时，我们都必须记得传入 unitSystem 参数。但凡遗漏，使用公制单位的用户就会看到令人困惑的英制单位，比如码、英亩或英尺磅。

如果能自动找出所有遗漏 unitSystem 参数的地方就太好了。这正是类型检查的强项，但由于我们将 unitSystem 属性设为可选，导致它无法发挥作用。

如果将其改为必填属性，所有遗漏设置的地方都会触发类型错误。虽然需要逐一修复这些问题，但让 TypeScript 发现这些错误，总比从困惑的用户那里收到反馈要好得多！

"默认使用英制单位"的文档注释也令人担忧。在 TypeScript 中，对象可选属性的默认值始终是 undefined。要实现替代默认值，我们的代码可能会充斥着这样的语句：

```ts
declare let config: AppConfig;
const unitSystem = config.unitSystem ?? "imperial";
```

每一个这样的设定都可能成为 bug 的温床。也许团队里另一位开发者忘记了英制是默认单位（为什么默认是英制呢？），想当然地认为应该使用公制：

```ts
const unitSystem = config.unitSystem ?? "metric";
```

结果将再次导致显示不一致。

如果需要支持 AppConfig 接口的旧值（可能这些值以 JSON 格式存储在磁盘或数据库中），你就无法将新字段设为必填项。替代方案是将类型一分为二：一种用于从磁盘读取的未规范化配置，另一种则包含更少可选属性，专供应用程序内部使用：

```ts
interface InputAppConfig {
  darkMode: boolean;
  // ... other settings .
  /* default is imperial */
  unitSystem?: UnitSystem;
}
interface AppConfig extends InputAppConfig {
  unitSystem: UnitSystem; // required
}
```

若将子类型中的可选属性改为必填项让你感到别扭，可参阅条款 7。此处亦可使用 Required 类型。

你需要添加一些规范化代码：

```ts
function normalizeAppConfig(inputConfig: InputAppConfig): AppConfig {
  return { ...inputConfig, unitSystem: inputConfig.unitSystem ?? "imperial" };
}
```

这种拆分解决了几个问题：

1.  它允许配置演进并保持向后兼容性，而不会在整个应用程序中增加复杂性。
2.  它将默认值的应用集中化处理。
3.  这导致在需要 AppConfig 的地方难以使用 InputAppConfig。

这类"构建中"的类型在网络代码中经常出现。另一个例子可参见第 33 条中的 UserPosts。

当你向接口添加更多可选属性时，会遇到一个新问题：如果有 N 个可选属性，那么它们的组合方式就有 2 的 N 次方种可能。这会产生大量可能性！如果有 10 个可选属性，你测试过所有 1024 种组合吗？所有这些组合都有意义吗？很可能这些选项存在某种结构，或许某些选项是互斥的。如果是这样，你的状态应该对此建模（参见第 29 条）。这是选项的普遍问题，而不仅限于可选属性。

最后，可选属性是 TypeScript 中潜在的不健全性来源。第 48 条对此有更详细的讨论。

正如你所见，有许多理由要避免使用可选属性。那么何时应该使用它们呢？在描述现有 API 或演进 API 同时保持向后兼容性时，它们很大程度上是不可避免的。

对于庞大的配置项，为所有可选字段填充默认值可能成本过高。而某些属性确实具有可选性：并非所有人都有中间名，因此 Person 类型中的可选 middleName 属性是准确的建模。但请务必意识到可选属性的诸多缺点，了解如何缓解这些问题，如果存在有效替代方案，在添加可选属性前请三思。

### 要点备忘

- 可选属性可能阻碍类型检查器发现错误，并导致重复且可能不一致的默认值填充代码。
- 在接口中添加可选属性前请慎重考虑。思考是否能让它成为必填项。
- 考虑为未规范化的输入数据和代码中使用的规范化数据创建不同的类型。
- 避免选项的组合爆炸。

## 条款 38：避免重复使用相同类型的参数

这个函数调用有什么作用？

```ts
drawRect(25, 50, 75, 100, 1);
```

不看函数的参数列表，根本无法确定。以下是几种可能性：

- 它绘制了一个 75×100 的矩形，左上角位于(25,50)，不透明度为 1.0。
- 它绘制了一个 50×50 的矩形，角点位于(25,50)和(75,100)，描边宽度为一个像素。

缺乏更多上下文的情况下，很难判断这个函数调用是否正确。由于所有参数都是相同类型（数字），如果你混淆了参数顺序或传入宽度高度而非第二个坐标点，类型检查器也无法提供帮助。

假设这是函数声明：

```ts
function drawRect(
  x: number,
  y: number,
  w: number,
  h: number,
  opacity: number
) {}
```

任何接收连续相同类型参数的函数都容易出错，因为类型检查器无法捕获错误的调用。改进这种情况的一种方法是使用不同的 Point 和 Dimension 类型：

```ts
interface Point {
  x: number;
  y: number;
}
interface Dimension {
  width: number;
  height: number;
}
function drawRect(topLeft: Point, size: Dimension, opacity: number) {
  //
}
```

由于该函数现在接收三个不同类型的参数，类型检查器能够区分它们。传入两个点的错误调用将会报错：

```ts
drawRect({ x: 25, y: 50 }, { x: 75, y: 100 }, 1.0);
//
// Argument ... is not assignable to parameter of type 'Dimension'.
```

另一种修复方法是将所有参数合并为一个对象：

```ts
interface DrawRectParams extends Point, Dimension {
  opacity: number;
}
function drawRect(params: DrawRectParams) {
  /* ... */
}
drawRect({ x: 25, y: 50, width: 75, height: 100, opacity: 1.0 });
```

将函数重构为接收对象而非位置参数，能提升代码对人类读者的清晰度。通过为每个数值关联名称，还能帮助类型检查器捕获错误的调用。

随着代码演进，函数可能会被修改为接收越来越多的参数。即便位置参数最初运作良好，但终将成为问题。正如谚语所言："若函数有 10 个参数，多半遗漏了什么。"当函数参数超过三四个时，就应重构以减少参数数量（typescript-eslint 的 max-params 规则可强制执行此规范）。

当参数类型相同时，更需警惕位置参数。即便是两个参数也可能引发问题。

此规则存在少数例外情况：

- 如果参数具有交换性（顺序无关紧要），那就没有问题。例如，max(a, b) 和 isEqual(a, b) 的语义是明确的。
- 如果参数存在"自然"顺序，那么混淆的可能性就会降低。例如，array.slice(start, stop) 比 stop, start 更符合直觉。但要注意：开发者对"自然"顺序的认知可能并不一致（是年、月、日？月、日、年？还是日、月、年？）。

正如 Scott Meyers 在《Effective C++》中所写："让接口易于正确使用，难以错误使用。"这个观点无可辩驳！

### 要点备忘

- 避免编写接收连续相同 TypeScript 类型参数的函数。
- 重构接收多个参数的函数，改为接收更少但类型明确的参数，或改用单一对象参数。

## 第 39 条：优先统一类型而非建模差异

TypeScript 的类型系统提供了强大的工具来实现类型间的映射转换。第 15 条和第六章阐述了其中多数工具的使用方法。当你意识到可以利用类型系统来建模转换时，可能会产生强烈的实践冲动——这确实能带来显著的成效：类型数量激增！安全性大幅提升！

但若条件允许，相较于为两种类型差异建立模型，更好的选择是消除这两种类型之间的差异。这样既无需类型层面的复杂机制，也免除了跟踪当前使用哪个类型版本的认知负担。

为了使这个概念更具体化，假设你有一个从数据库表派生的接口。数据库通常使用 snake_case 命名列名，因此数据会以这种形式呈现：

```ts
interface StudentTable {
  first_name: string;
  last_name: string;
  birth_date: string;
}
```

TypeScript 代码通常采用 camelCase 属性命名。为了让 Student 类型与代码其他部分保持统一，你可以引入一个替代版本的 Student：

```ts
interface Student {
  firstName: string;
  lastName: string;
  birthDate: string;
}
```

你可以编写函数在两种类型间进行转换。更有趣的是，你可以使用模板字面量类型来为此函数添加类型注解。第 54 条详细介绍了具体实现方法，最终效果是你能从一个类型生成另一个类型：

```ts
type Student = ObjectToCamel<StudentTable>;
// ^? type Student = {
// firstName: string;
// lastName: string;
// birthDate: string;
// }
```

太棒了！当发现高级类型编程的绝妙用例带来的兴奋感消退后，你可能会遇到大量类型不匹配的错误——将某个版本的类型传递给期望另一个版本的函数时：

```ts
async function writeStudentToDb(student: Student) {
  await writeRowToDb(db, "students", student); //
  // Type 'Student' is not assignable to parameter of type 'StudentTable'.
}
```

错误信息并未明确指出，但问题在于您忘记调用转换代码：

```ts
async function writeStudentToDb(student: Student) {
  await writeRowToDb(db, "students", objectToSnake(student)); // Ok
}
```

虽然 TypeScript 能在运行时错误发生前标记出这个错误很有帮助，但更简单的做法是在代码中只保留一个版本的 Student 类型，这样就能从根本上避免此类错误。

目前存在两个版本的 Student 类型。您该选择哪一个？

- 若采用驼峰式命名版本，您需要设置某种适配器来确保数据库返回的列名采用驼峰格式。同时还需确保从数据库生成 TypeScript 类型的工具能识别这种转换。这种方法的优势在于数据库接口将与其他所有类型保持风格一致。
- 要采用蛇形命名法（snake_case），你无需做任何额外操作。只需在命名规范上接受表面的不一致性，以换取类型系统更深层次的一致性。

这两种方法都可行，但后者更为简单。

总体原则是：应当优先统一类型，而非为细微差异建立单独模型。不过这条规则也存在一些例外情况。

首先，统一类型并非总是可行。若数据库和 API 不受你控制，就可能需要保留两种类型。这种情况下，在类型系统中系统化地建模这类差异，能帮助你发现转换代码中的错误。这比临时创建类型并指望它们保持同步要好得多。

其次，不要强行统一那些实际上并不代表相同事物的类型！例如，在标记联合体中"统一"不同类型会适得其反，因为它们很可能代表着你希望保持分离的不同状态。

### 要点备忘

- 为同一类型创建不同变体会增加认知负担，并需要大量转换代码。
- 与其在代码中对类型进行细微变化的建模，不如尝试消除这些变化，以便能统一为单一类型。
- 统一类型可能需要对运行时代码进行一些调整。
- 如果类型不在你的控制范围内，你可能需要对变化进行建模。
- 不要统一那些不代表相同事物的类型。

## 第 40 条：宁可不精确的类型，也不要错误的类型

在编写类型声明时，你不可避免地会遇到这样的情况：可以用更精确或不太精确的方式来建模行为。类型精确通常是件好事，因为它能帮助用户发现错误并利用 TypeScript 提供的工具。但在提高类型声明的精确度时要小心：很容易犯错，而错误的类型可能比完全没有类型更糟糕。

假设你正在为 GeoJSON 编写类型声明，这是我们在第 33 条中见过的格式。GeoJSON 几何体可以是几种类型之一，每种类型都有不同形状的坐标数组：

```ts
interface Point {
  type: "Point";
  coordinates: number[];
}
interface LineString {
  type: "LineString";
  coordinates: number[][];
}
interface Polygon {
  type: "Polygon";
  coordinates: number[][][];
}
type Geometry = Point | LineString | Polygon; // also several others
```

这样写没问题，但用 number\[\]表示坐标有些不够精确。实际上这些是纬度和经度，所以或许元组类型会更合适：

```ts
type GeoPosition = [number, number];
interface Point {
  type: "Point";

  coordinates: GeoPosition;
} // Etc.
```

你将更精确的类型发布出去，期待收获赞誉。但不幸的是，有用户抱怨你的新类型破坏了所有东西。尽管你只使用过纬度和经度，但 GeoJSON 中的坐标实际上允许包含第三个元素（高程），甚至可能更多。你试图让类型声明更精确，却矫枉过正导致类型不准确！为了继续使用你的类型声明，用户将不得不引入类型断言或直接用 as any 让类型检查器静默。也许他们会放弃并开始编写自己的声明。

再举一个例子，考虑尝试为 JSON 中定义的类 Lisp 语言编写类型声明：

```ts
12;
"red",
  [("+", 1, 2)], //3
  [("/", 20, 2)], // 10
  [("case", [">", 20, 10], "red", "blue")], // "red"
  [("rgb", 255, 0, 127)]; // #FF007F"
```

Mapbox 库采用类似系统来确定地图元素在各种设备上的显示效果。关于如何精确地为此定义类型，存在着一整套精度谱系：

1.  允许任何类型。
2.  允许字符串、数字和数组。
3.  允许字符串、数字以及以已知函数开头的数组。
    名称。
4.  确保每个函数获得正确数量的参数。
5.  确保每个函数获得正确类型的参数。

前两个选项很直接：

如果一个类型系统允许所有有效程序，则称其为"完备的"。这两种类型将允许所有有效的 Mapbox 表达式，不会出现误报错误。但如此简单的类型会导致许多漏报：无效表达式未被标记。换言之，这些类型并不十分精确。

让我们看看能否在不丧失完备性的前提下提高精确度。为避免倒退，我们应引入包含有效表达式和无效表达式的测试集（第 55 条专门讨论类型测试）。

```ts
const okExpressions: Expression2[] = [
  10,
  "red",
  ["+", 10, 5],
  ["rgb", 255, 128, 64],
  ["case", [">", 20, 10], "red", "blue"],
];
const invalidExpressions: Expression2[] = [
  true,
  // \~\~\~ Type 'boolean' is not assignable to type 'Expression2'
  ["**", 2, 31], // Should be an error: no "**" function
  ["rgb", 255, 0, 127, 0], // Should be an error: too many values
  ["case", [">", 20, 10], "red", "blue", "green"], // (Too any values)
];
```

要提升到更高精确度，可以使用字符串字面量类型的联合作为元组的首个元素：

```ts
type FnName = "case" | "rgb";
type CallExpression = [FnName, ...any[]];
type Expression3 = number | string | CallExpression;
const okExpressions: Expression3[] = [
  10,
  "red",
  ["+", 10, 5],
  ["rgb", 255, 128, 64],
  ["case", [">", 20, 10], "red", "blue"],
];

const invalidExpressions: Expression3[] = [
  true, // Error: Type 'boolean' is not assignable to type 'Expression3'
  ["**", 2, 31], // \~\~ Type '"\*\*"' is not assignable to type 'FnName'
  ["rgb", 255, 0, 127, 0], // Should be an error: too many values
  ["case", [">", 20, 10], "red", "blue", "green"], // (Too any values)
];
```

新捕获了一个错误且没有倒退现象，相当不错！但带来的复杂性是：我们的类型声明与 Mapbox 版本更紧密关联了。如果 Mapbox 新增函数，类型声明也需同步添加。这些类型更精确，但维护成本也更高。

如何确保每个函数都能获得正确数量的参数？这会变得更为棘手，因为类型现在需要递归地深入所有函数调用。TypeScript 允许这样做，不过我们需要谨慎处理，以说服类型检查器我们的递归不是无限的。有几种方法可以实现这一点。其中一种是用接口而非类型来定义 CaseCall（它必须是一个长度为偶数的数组）。

这是可行的，尽管略显笨拙：

```ts
type Expression4 = number | string | CallExpression;
type CallExpression = MathCall | CaseCall | RGBCall;
type MathCall = ["+" | "-" | "/" | "*" | ">" | "<", Expression4, Expression4];
interface CaseCall {
  0: "case";
  [n: number]: Expression4;
  length: 4 | 6 | 8 | 10 | 12 | 14 | 16; // etc.
}

type RGBCall = ["rgb", Expression4, Expression4, Expression4];
```

让我们看看效果如何：

```ts
const okExpressions: Expression4[] = [
  10,
  "red",
  ["+", 10, 5],
  ["rgb", 255, 128, 64],
  ["case", [">", 20, 10], "red", "blue"],
];
const invalidExpressions: Expression4[] = [
  true,
  // \~\~\~ Type 'boolean' is not assignable to type 'Expression4'
  ["**", 2, 31],
  // \~\~ Type '"\*\*"' is not assignable to type '"+" | "-" | "/" |
  ["rgb", 255, 0, 127, 0], // \~ Type 'number' is not assignable to type 'undefined'.
  ["case", [">", 20, 10], "red", "blue", "green"],
  // Types of property 'length' are incompatible.
  // Type '5' is not assignable to type '4 | 6 | 8 | 10 | 12 | 14 | 16'.
];
```

现在所有无效表达式都会产生错误。有趣的是，你可以用 TypeScript 接口表达诸如"长度为偶数的数组"这样的概念。不过其中一些错误信息有点令人困惑，特别是关于类型'5'的那条。

相比之前不够精确的类型定义，这算是一种改进吗？虽然能捕获更多错误用法确实是个进步，但晦涩的错误提示会让这种类型更难使用。正如第 6 条所述，语言服务与类型检查同样重要，都是 TypeScript 体验的核心部分。因此，建议你仔细查看类型声明引发的错误提示，并在预期可用的场景下测试自动补全功能。如果新类型声明虽然更精确却破坏了自动补全，反而会降低 TypeScript 的开发体验。

这种类型声明的复杂性也增加了潜在错误的风险。例如，Expression4 要求所有数学运算符必须接收两个参数，但 Mapbox 表达式规范明确指出+和\*运算符可以接收更多参数。此外，-运算符还能接收单个参数表示取反操作。而 Expression4 错误地将所有这些合法用法都标记为错误：

```ts
const moreOkExpressions: Expression4[] = [
  ["-", 12], // Type '["-", number]' is not assignable to type 'MathCall'.
  // Source has 2 element(s) but target requires 3.
  ["+", 1, 2, 3], // \~ Type 'number' is not assignable to type 'undefined'.
  ["*", 2, 3, 4], // \~ Type 'number' is not assignable to type 'undefined'.
];
```

我们又一次在追求精确的过程中矫枉过正，反而变得不准确了。这些不准确之处可以修正，但你需要扩展测试集来说服自己没有再遗漏其他问题。复杂代码通常需要更多测试，类型系统亦是如此。

在优化类型时，"恐怖谷理论"的比喻很有启发意义。当卡通画作越来越逼真时，我们往往会觉得它更接近现实。但这种认知存在临界点——如果过度追求真实感，我们反而会聚焦于那些残留的细微失真之处。

同理，优化像 any 这样极不精确的类型几乎总是有益的。你和同事会认为这提升了类型安全性和开发效率。但随着类型越来越精确，人们对类型准确性的期待也会水涨船高。你会开始依赖类型系统捕捉大多数错误，因此类型的不准确会显得格外刺眼。如果花费数小时追踪类型错误后，却发现类型声明本身就不准确，这会动摇你对类型声明（乃至 TypeScript 本身）的信心，当然也无助于提升开发效率。

### 要点备忘

- 避开类型安全的"恐怖谷"：复杂但不准确的类型通常比简单但不够精确的类型更糟糕。如果无法精确建模某个类型，就不要错误地建模！可以使用 any 或 unknown 来明确承认类型缺口。
- 在逐步提升类型精确度的过程中，要密切关注错误提示和自动补全功能。这不仅关乎正确性：开发者体验同样重要。
- 随着类型系统日趋复杂，对应的测试套件也应该同步扩展。

## 条款 41：使用问题领域的专业术语来命名类型

计算机科学领域只有两个难题：缓存失效和命名问题。

——菲尔·卡尔顿

本书对类型的形态及其值域集合已有诸多讨论，却鲜少提及如何为类型命名。而这同样是类型设计的重要环节。精心挑选的类型、属性和变量名称能明确意图，提升代码与类型的抽象层次。拙劣的命名则会掩盖代码本意，导致错误的心智模型。

假设你正在构建动物数据库，为此创建了一个接口：

```ts
interface Animal {
  name: string;
  endangered: boolean;
  habitat: string;
}
const leopard: Animal = {
  name: "Snow Leopard",
  endangered: false,
  habitat: "tundra",
};
```

这里存在几个问题：

- "name"是一个非常宽泛的术语。您期望的是哪种名称？学名？俗名？
- 布尔类型的"endangered"字段也存在歧义。如果动物已经灭绝呢？这里是否指"濒危或更严重的情况"？还是字面意义上的濒危？
- "habitat"字段非常模糊，不仅因为过于宽泛的字符串类型（条款 35），还因为"栖息地"具体指代什么并不明确。
- 变量名为 leopard，但 name 属性的值却是"Snow Leopard"。这种区分有意义吗？

以下是一个更明确的类型声明和值：

```ts
interface Animal {
  commonName: string;
  genus: string;
  species: string;
  status: ConservationStatus;
  climates: KoppenClimate[];
}
type ConservationStatus = "EX" | "EW" | "CR" | "EN" | "VU" | "NT" | "LC";
type KoppenClimate =
  | "Af"
  | "Am"
  | "As"
  | "Aw"
  | "BSh"
  | "BSk"
  | "BWh"
  | "BWk"
  | "Cfa"
  | "Cfb"
  | "Cfc"
  | "Csa"
  | "Csb"
  | "Csc"
  | "Cwa"
  | "Cwb"
  | "Cwc"
  | "Dfa"
  | "Dfb"
  | "Dfc"
  | "Dfd"
  | "Dsa"
  | "Dsb"
  | "Dsc"
  | "Dwa"
  | "Dwb"
  | "Dwc"
  | "Dwd"
  | "EF"
  | "ET";
const snowLeopard: Animal = {
  commonName: "Snow Leopard",
  genus: "Panthera",
  species: "Uncia",
  status: "VU", // ulnerable
  climates: ["ET", "EF", "Dfd"], // alpine or subalpine
};
```

这带来了多项改进：

- name 已被更具体的术语替代：commonName（通用名称）、genus（属）和 species（种）。
- 濒危状态已转变为保护状态（ConservationStatus），采用国际自然保护联盟（IUCN）的标准分类体系。
- 栖息地已转变为气候类型，并采用另一套标准分类系统——柯本气候分类法。

若需了解该类型第一版字段的更多信息，你只能去找编写者询问。但很可能对方已离职或完全不记得了。更糟的是，当你用 git blame 追查这些糟糕类型的作者时，可能会发现罪魁祸首就是你自己！

第二版则大幅改善了这种情况。无论是想了解柯本气候分类系统的细节，还是查询保护状态的具体定义，都有大量在线资源可供参考。

每个领域都有描述其主题的专业词汇。与其自创术语，不如尝试复用问题所在领域的既有词汇。这些词汇往往经过数年、数十年甚至数百年的锤炼，已被该领域人士广泛理解。使用这些术语将有助于与用户沟通，并提升类型定义的清晰度。

务必准确使用领域词汇：挪用某个领域的术语来表达不同含义，比自创新词更容易造成混淆。

同样的考量也适用于其他命名场景，例如函数参数名、元组标签和索引类型标签。

在为类型、属性和变量命名时，还需谨记以下准则：

- 让差异具有意义。在写作和演讲中，反复使用同一个词会显得单调乏味，因此我们会引入同义词来打破这种单调性。这能让文章读起来更愉悦，但对代码却会产生相反的效果。如果你使用两个不同的术语，请确保它们之间存在有意义的区分。如果没有，就应该使用相同的术语。
- 避免使用"data"、"info"、"thing"、"item"、"object"或永远流行的"entity"这类模糊无意义的名称。如果"Entity"在你的领域有特定含义，那没问题。但如果你只是懒得想更有意义的名称而使用它，最终会遇到麻烦：项目中可能会出现多个不同类型的"Entity"，你能记得清什么是 Item 什么是 Entity 吗？
- 根据事物本质而非其内容或计算方式来命名。用"Directory"就比"INodeList"更有意义。这能让你将目录视为一个概念，而不是其实现方式。好的命名能提升抽象层次，降低无意中产生冲突的风险。

### 要点备忘

- 尽可能复用问题领域中的名称，以提升代码可读性和抽象层次。确保准确使用领域术语。
- 避免对同一事物使用不同名称：确保名称差异具有实际意义。
- 避免使用"信息"或"实体"等模糊名称。根据类型本质而非形式命名。

## 条款 42：避免基于主观经验的类型设计

本章其他条目已经讨论了良好类型设计的诸多益处，也展示了缺乏类型设计可能引发的问题。精心设计的类型能让 TypeScript 使用体验愉悦，而糟糕的类型设计则会令人痛苦不堪。但这确实给类型设计带来了不小压力。如果能不必亲自操刀岂不美哉？

至少部分类型很可能来自程序外部：规范文档、文件格式、API 接口或数据库架构。人们常倾向于根据已见数据自行编写这些类型的声明，比如测试数据库中的记录或特定 API 端点的响应样本。

请务必抵制这种冲动！从外部源导入类型或根据规范生成类型才是上策。当你仅凭零星数据自行编写类型时，你考虑的只是已见案例。那些可能摧毁程序的重要边界情况很可能被遗漏。而使用更权威的类型时，TypeScript 将帮助你规避这类风险。

在第 30 条中，我们曾使用过计算 GeoJSON 要素边界框的函数。其定义可能如下所示：

```ts
function calculateBoundingBox(f: GeoJSONFeature): BoundingBox | null {
  let box: BoundingBox | null = null;
  const helper = (coords: any[]) => {
    // ...
  };
  const { geometry } = f;
  if (geometry) {
    helper(geometry.coordinates);
  }
  return box;
}
```

如何定义 GeoJSONFeature 类型？你可以查看代码库中的一些 GeoJSON 要素并草拟一个接口：

```ts
interface GeoJSONFeature {
  type: "Feature";

  geometry: GeoJSONGeometry | null;
  properties: unknown;
}
interface GeoJSONGeometry {
  type: "Point" | "LineString" | "Polygon" | "MultiPolygon";
  coordinates: number[] | number[][] | number[][][] | number[][][][];
}
```

该函数通过了类型检查器的验证。但这种定义真的正确吗？这种检查的准确性完全取决于我们自制的类型声明。

更优方案是采用官方 GeoJSON 规范。幸运的是，DefinitelyTyped 上已有现成的 TypeScript 类型声明。你可以通过常规方式添加这些声明：

```bash
$ npm install --save-dev @types/geojson
+ @types/geojson@7946.0.14
```

引入这些声明后，TypeScript 会立即标记出错误：

```ts
import { Feature } from "geojson";
function calculateBoundingBox(f: Feature): BoundingBox | null {
  let box: BoundingBox | null = null;
  const helper = (coords: any[]) => {
    //
  };
  const { geometry } = f;
  if (geometry) {
    helper(geometry.coordinates); //
    // Property 'coordinates' does not exist on type 'Geometry'
    // Property 'coordinates' does not exist on type 'GeometryCollection'
  }
  return box;
}
```

问题在于这段代码假设几何图形会有一个 coordinates 属性。对于点、线、多边形等大多数几何图形确实如此。但 GeoJSON 几何图形还可能是 GeometryCollection（几何图形集合），即其他几何图形的异构集合。与其他几何类型不同，它并不具备 coordinates 属性。

如果你在几何图形为 GeometryCollection 的要素上调用 calculateBoundingBox，程序会抛出"无法读取 undefined 的属性 0"的错误。这确实是个漏洞！而我们通过引入社区类型定义发现了这个问题。

修复这个漏洞的一个方案是明确禁止 GeometryCollection 类型：

```ts
const { geometry } = f;
if (geometry) {
  if (geometry.type === "GeometryCollection") {
    throw new Error("GeometryCollections are not supported.");
  }
  helper(geometry.coordinates); // OK
}
```

TypeScript 能够基于条件检查细化 geometry 的类型，因此引用 geometry.coordinates 的代码得以通过。至少这能为用户提供更清晰的错误提示信息。

但更好的解决方案是支持 GeometryCollections！你可以通过提取另一个辅助函数来实现这一点：

```ts
const geometryHelper = (g: Geometry) => {
  if (g.type === "GeometryCollection") {
    g.geometries.forEach(geometryHelper);
  } else {
    helper(g.coordinates); // OK
  }
};
const { geometry } = f;
if (geometry) {
  geometryHelper(geometry);
}
```

我们手写的 GeoJSON 类型仅基于我们自身对该格式的使用经验，其中并未包含 GeometryCollections。这导致我们对代码正确性产生了虚假的安全感。使用基于规范的社区类型能让你确信代码可以处理所有值，而不仅限于你恰好见过的那些。

类似的考量也适用于 API 调用。如果你使用的 API 有官方的 TypeScript 客户端，那就用它！即使没有，你也可能从官方源生成 TypeScript 类型。

例如，如果你使用的是 GraphQL API，它包含描述所有查询、变更以及类型的模式。有许多工具可为 GraphQL 查询添加 TypeScript 类型。只需打开你常用的搜索引擎，很快就能踏上类型安全的道路。

许多 REST API 都会发布 OpenAPI 规范。这是一个使用 JSON Schema 描述所有端点、HTTP 方法（GET、POST 等）及数据类型的文件。

假设我们正在使用一个允许在博客上发表评论的 API。OpenAPI 规范可能长这样：

```json
// schema.json
{
  "openapi": "3.0.3",
  "info": { "version": "1.0.0", "title": "Sample API" },
  "paths": {
    "/comment": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/Comment" }
            }
          }
        }
      },
      "responses": {
        "200": {
          /* ... */
        }
      }
    }
  },
  "components": {
    "schemas": {
      "CreateCommentRequest": {
        "properties": {
          "body": { "type": "string" },
          "postId": { "type": "string" },
          "title": { "type": "string" }
        },
        "type": "object",
        "required": ["postId", "title", "body"]
      }
    }
  }
}
```

paths 部分定义了端点并将其与数据类型关联，这些类型可在 components/schemas 部分找到。生成类型所需的所有信息都在这里。从 OpenAPI 规范提取类型有多种方法，其中一种是将模式定义提取出来，通过 json-schema-to-typescript 工具处理：

```bash
$ jq .components.schemas.CreateCommentRequest schema.json > comment.json
$ npx json-schema-to-typescript comment.json > comment.ts
$ cat comment.ts
// ...
export interface CreateCommentRequest {
    body: string;
    postId: string;
    title: string;
}
```

最终会生成清晰优雅的接口，帮助您以类型安全的方式与该 API 交互。TypeScript 会在请求体出现类型错误时提示，响应类型也会贯穿您的代码。关键在于这些类型并非手动编写，而是从可靠的真相源自动生成。如果某个字段是可选的或允许为 null，TypeScript 会知晓这一点并强制您处理这种可能性。

下一步可以添加运行时验证，并将类型直接关联到对应的端点。有许多工具能协助完成这项工作，第 74 条将再次回到这个示例。

生成类型时，确实需要确保它们与 API 模式保持同步。第 58 条将讨论处理这一问题的策略。
