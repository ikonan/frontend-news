# 第四章. 使用 render props 进行高级配置

在上一章中，我们讨论了灵活性、组件配置、如何将元素作为属性传递来解决这些问题，以及如何为这些属性设置默认值。但是，尽管将元素作为属性很有用，但它并不能为我们解决所有问题。如果一个通过属性接受其他组件的组件需要以某种显式而非隐式的方式影响这些组件的属性或将某些状态传递给它们，那么将元素作为属性和 `cloneElement` 函数在这里就派不上用场了。

这就是所谓的 “render props” 模式发挥作用的地方。在本章中，你将学习：

- render props 模式是什么，以及它能解决哪些元素作为属性无法解决的配置问题。
- 如何使用 render props 共享有状态的逻辑，以及将子元素作为 render props 是什么样子。
- 既然我们有了 Hooks，为什么现在实际上不应该再这么做了。
- 即使在 Hooks 时代，用于共享逻辑的 render props 模式何时仍然有用。

## 问题

以下是我们在上一章中实现的 `Button` 组件：

```jsx
const Button = ({ appearance, size, icon }) => {
  // 创建默认属性
  const defaultIconProps = {
    size: size === "large" ? "large" : "medium",
    color: appearance === "primary" ? "white" : "black",
  };
  const newProps = {
    ...defaultIconProps,
    // 确保如果图标自带属性存在，则覆盖默认属性
    ...icon.props,
  };
  // 克隆图标并为其分配新属性
  const clonedIcon = React.cloneElement(icon, newProps);
  return (
    <button className={`button ${appearance}`}>Submit {clonedIcon}</button>
  );
};
```

`Button` 组件接受一个图标元素，并默认设置其 `size` 和 `color` 属性。

虽然这种方法在简单场景下效果很好，但对于更复杂的情况就不太适用了。如果我想在 `Button` 组件中引入一些状态，并让 `Button` 的使用者能够访问这些状态呢？例如，在按钮被悬停时调整图标。在按钮中实现这种状态很容易：

```jsx
const Button = ({ ... }) => {
  const [isHovered, setIsHovered] = useState();

  return <button onMouseOver={() => setIsHovered(true)} />
}
```

但接下来呢？我们如何将它与图标共享呢？
这种方法的另一个问题是，我们对通过 `icon` 属性传入的元素做了一些重大假设。我们期望它至少有 `size` 和 `color` 属性。如果我们想使用不同的图标库，而这些图标没有这些确切的属性怎么办？我们的默认属性逻辑就会失效，而且没有办法修复它。

## 用于渲染元素的 Render props

幸运的是，正如我之前提到的，在 React 中有无数种方法可以解决完全相同的问题。在这种情况下，我们可以不将元素作为属性传递，而是将它们作为 render prop（或渲染函数）传递。render prop 不过是一个返回元素的函数。这个函数几乎与组件相同。只是你不会直接调用组件 —— React 会为你调用。但渲染函数由你掌控。

以 `Button` 组件及其图标为例，使用渲染函数的代码如下：

```jsx
// 不再接收期望为元素的 "icon" 属性
// 而是接收一个返回元素的函数
const Button = ({ renderIcon }) => {
  // 然后在图标应该渲染的位置调用这个函数
  return <button>Submit {renderIcon()}</button>;
};
```

我们接受一个 `renderIcon` 函数，并在图标应该显示的位置调用它。然后，在调用方，我们将传递一个返回图标的函数，而不是直接传递图标：

```jsx
<Button renderIcon={() => <HomeIcon />} />
```

当然，我们仍然可以像调整普通元素一样，根据需求调整该图标：

```jsx
// red icon
<Button renderIcon={() => <HomeIcon color="red" /> } />
// large icon
<Button renderIcon={() => <HomeIcon size="large" /> } />

```

那么，使用这个函数的意义何在呢？首先，是图标的属性。现在，我们无需克隆元素（无论如何，克隆元素都是一种不太可靠的做法），只需将对象传递给函数即可：

```jsx
const Button = ({ appearance, size, renderIcon }) => {
  // 像之前一样创建默认属性
  const defaultIconProps = {
    size: size === "large" ? "large" : "medium",
    color: appearance === "primary" ? "white" : "black",
  };
  // 然后将它们传递给函数
  return <button>Submit {renderIcon(defaultIconProps)}</button>;
};
```

然后，在图标的一方，我们可以接收这些属性并将它们展开应用到图标上：

```jsx
<Button renderIcon={(props) => <HomeIcon {...props} />} />
```

我们可以覆盖其中的一些属性：

```jsx
<Button
  renderIcon={(props) => <HomeIcon {...props} size="large" color="red" />}
/>
```

或者将它们转换为我们图标实际接受的属性：

```jsx
<Button
  renderIcon={(props) => (
    <HomeIcon fontSize={props.size} style={{ color: props.color }} />
  )}
/>
```

> 交互式示例和完整代码
> https://advanced-react.com/examples/04/01

一切都是显式的，没有任何内容会通过某种隐藏的魔法来覆盖其他内容。数据的流动虽然有点迂回，但却是可见且可追溯的。

[![20250521214008.jpg](https://i.postimg.cc/6600gzkq/20250521214008.jpg)](https://postimg.cc/bdZk20Nf)

共享状态也不再是问题了。我们只需将该状态值合并到我们传递给图标的对象中：

```jsx
const Button = ({ appearance, size, renderIcon }) => {
  const [isHovered, setIsHovered] = useState(false);
  const iconParams = {
    size: size === 'large' ? 'large' : 'medium',
    color: appearance === 'primary' ? 'white' : 'black',
    // 在这里添加状态 —— 毕竟它只是一个对象
    isHovered,
  }

  return <button ...>Submit {renderIcon(iconParams)}</button>
}
```

或者，我们甚至可以采用更巧妙的方式，将其作为第二个参数传递，以便清晰地区分状态和属性。只要符合我们代码库的逻辑即可：

```jsx
const Button = ({ appearance, size, renderIcon }) => {
const [isHovered, setIsHovered] = useState(false);
const iconParams = {
size: size === 'large' ? 'large' : 'medium',
color: appearance === 'primary' ? 'white' : 'black',
}
// 在这里将状态作为第二个参数传递
return <button ...>Submit {renderIcon(iconParams, { isHovered })}</button>
}
```

然后在图标的处理部分，我们可以根据悬停状态做任何我们想做的事情。我们可以渲染另一个图标：

```jsx
const icon = (props, state) => state.isHovered
  ? <HomeIconHovered {...props} />
  : <HomeIcon {...props} />

<Button renderIcon={icon} />
```

应用不同的类名：
```jsx
const icon = (props, state) => <HomeIcon {...props} className=
{state.isHovered ? 'hovered' : ''} />

<Button renderIcon={icon} />
```

或者直接完全忽略它。
> 交互式示例和完整代码
> https://advanced-react.com/examples/04/02

## 共享有状态逻辑：将子元素作为 render props

render props 的另一个有用应用是在组件之间共享有状态逻辑，并且它通常与 “将子元素作为 props” 模式结合使用。正如上一章所讨论的，当 “children” 以类似 HTML 的嵌套语法使用时，它不过是一个 prop：

```jsx
<Parent>
  <Child />
</Parent>

// 与上面完全相同
<Parent children={<Child />} />

```
