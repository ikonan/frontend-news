# 第 9 章. Refs：从存储数据到命令式 API

React 的众多美妙之处之一在于，它抽象掉了处理真实 DOM 的复杂性。现在我们无需手动查询元素、绞尽脑汁地为这些元素添加类，也不用为浏览器兼容性问题而烦恼，只需编写组件并专注于用户体验即可。不过，仍然存在一些情况（虽然很少！）需要我们访问实际的 DOM。

要做到这一点，我们需要使用 Refs。这次没有什么神秘的，让我们来实现一个带有简单输入字段验证的精美表单。在这个过程中，我们将学习：

- 为什么我们仍然需要访问 DOM 元素。
- 什么是 Ref，以及 Ref 和状态之间有什么区别。
- 如何使用 Refs 访问 UI 元素。
- 什么是 forwardRef，如何使用它，以及如何避免使用它（你会明白为什么！）
- 为什么我们在 React 中仍然需要命令式 API，以及如何使用或不使用 useImperativeHandle 来实现它们。

## 在 React 中访问 DOM

假设我要为我正在组织的一个会议实现一个注册表单。在我向人们发送会议详情之前，我需要他们提供姓名、电子邮件和 Twitter 账号。我希望“姓名”和“电子邮件”字段为必填项。但当人们尝试提交空字段时，我不想在这些输入框周围显示烦人的红色边框。我希望表单看起来很酷。所以，我打算让空字段获得焦点并稍微晃动一下，以此来吸引注意力，只是为了好玩。

现在，React 为我们提供了很多功能，但并非一切。像“手动聚焦某个元素”或“晃动该元素”这类功能并不包含在 React 的功能包里。为此，我们需要重新拾起生疏的原生 JavaScript API 技能。而要做到这一点，我们就需要访问实际的 DOM 元素。
在非 React 环境中，我们会这样做：

```jsx
const element = document.getElementById("bla");
```

之后，我们可以让它获得焦点：

```jsx
element.focus();
```

或者滚动到该元素：

```jsx
element.scrollIntoView();
```

或者满足我们需求的其他操作。在 React 中使用原生 DOM API 的一些典型用例包括：

- 在元素渲染后手动聚焦该元素，例如表单中的输入框。
- 在显示类似弹出框的元素时，检测组件外部的点击事件。
- 在元素出现在屏幕上后手动滚动到该元素。
- 计算组件在屏幕上的大小和边界，以便正确定位工具提示等元素。

虽然从技术上讲，即使在今天也没有什么能阻止我们使用 `getElementById`，但 React 为我们提供了一种更强大的方法来访问该元素，这种方法不需要我们到处散布 `id`，也不需要我们了解底层的 DOM 结构：Refs。

## 什么是 Ref？

Ref 是一个可变对象，React 在重新渲染时会保留它。
请记住，组件内声明的所有内容都会不断被重新创建，对吧？

```jsx
const Component = () => {
  // "data" object will be new with every re-render
  const data = { id: "test" };
};
```

组件不过是函数，因此函数内部的所有内容本质上都是该函数的局部变量。Refs 让我们能够绕过这一限制。

要创建一个 Ref，我们可以使用 useRef 钩子，并将 Ref 的初始值作为参数传递给它：

```jsx
const Component = () => {
  const ref = useRef({ id: "test" });
};
```

现在，该初始值可以通过 `ref.current` 属性访问：我们传递给 Ref 的所有内容都存储在那里。

```jsx
const Component = () => {
  // 在这里传递初始值
  const ref = useRef({ id: "test" });
  useEffect(() => {
    // 在这里访问它
    console.log(ref.current);
  });
};
```

初始值会被缓存，因此如果我们在重新渲染之间比较 `ref.current`，引用将保持不变。这就好像我们对该对象使用了 `useMemo` 钩子一样。

一旦创建了这个 Ref，我们就可以在 `useEffect` 或事件处理程序中为其赋值。它只是一个普通对象，没什么特别的：

```jsx
const Component = () => {
  useEffect(() => {
    // 当 url 发生变化时，将其赋值为 id
    ref.current = { id: url };
  }, [url]);
};
```

所有这些看起来都和状态极其相似，不是吗？只是 API 不同而已。那么问题出在哪里呢？为什么我们到处都在使用状态，而 Ref 却被视为一种不应使用的特殊手段呢？在把我们的表单弄得过于花哨之前，让我们先弄清楚这个问题。也许我们根本就不需要在那里使用状态呢？

## Ref 和状态之间的区别

让我们从表单开始，实现带有提交按钮的第一个输入字段。

```jsx
const Form = () => {
  return (
    <>
      <input type="text" />
      <button onClick={submit}>submit</button>
    </>
  );
};
```

现在，为了让我们的提交功能正常工作，我们需要以某种方式提取输入字段的内容。在 React 中，通常我们只需给输入框添加一个 onChange 回调函数，将这些信息保存到状态中，以便在重新渲染时保留这些信息，然后在提交函数中访问它：

```jsx
const Form = () => {
  const [value, setValue] = useState();
  const onChange = (e) => {
    setValue(e.target.value);
  };
  const submit = () => {
    // send to the backend here
    console.log(value);
  };
  return (
    <>
      <input type="text" onChange={onChange} />
      <button onClick={submit}>submit</button>
    </>
  );
};
```

但我已经多次提到，我们存储在 Ref 中的任何内容在重新渲染之间也会被保留。而且，方便的是，任何内容都可以赋值给 Ref。如果我不把输入框的值保存到状态里，而是保存到 Ref 中，会发生什么呢？

```jsx
const Form = () => {
  const ref = useRef();
  const onChange = (e) => {
    // 将其保存到 ref 而不是状态中
    ref.current = e.target.value;
  };
  const submit = () => {
    // 从 ref 中获取它而不是从状态中
    console.log(ref.current);
  };
  return (
    <>
      <input type="text" onChange={onChange} />
      <button onClick={submit}>submit</button>
    </>
  );
};
```

看起来它的工作方式和使用状态时完全一样：我在输入框中输入一些内容，然后按下按钮，值就被发送出去了。

> 交互式示例和完整代码
> https://advanced-react.com/examples/09/01

那么区别是什么呢？为什么我们在应用程序中通常看不到这种模式呢？有以下几个原因。

## Ref 更新不会触发重新渲染

Ref 和状态之间最大且最明显的区别之一是，Ref 的更新不会导致组件重新渲染。如果你在这两种表单中都加入 `console.log`，你会发现使用状态的表单组件会随着每次按键重新渲染，而使用 Ref 的表单则保持不变。

```jsx
useEffect(() => {
  console.log("Form component re-renders");
});
```

从表面上看，这似乎是个好消息。这本书不有一半内容都是在讲重新渲染以及如何避免重新渲染吗？如果 Ref 不会触发重新渲染，那它们肯定能解决我们所有的性能问题吧？

完全不是这样。如果你还记得第一章的内容，重新渲染是 React 生命周期中至关重要的一环。React 正是通过重新渲染用新信息更新我们的组件。例如，如果我想在文本输入框下方显示输入的字符数量，使用 Ref 就无法做到这一点。

```jsx
const Form = () => {
  const ref = useRef();
  const numberOfLetters = ref.current?.length ?? 0;
  return (
    <>
      <input type="text" onChange={onChange} />
      {/* Not going to work */}
      Characters count: {numberOfLetters}
      <button onClick={submit}>submit</button>
    </>
  );
};
```

Ref 的更新不会触发重新渲染，因此我们返回的输出中 `numberOfLetters` 始终会显示为 0。

实际上，还有比显示 0 更有意思的情况。如果与该输入框完全无关的事情导致 `Form` 组件重新渲染，这个值会突然更新为最新值。要记住，Ref 会在重新渲染之间存储该值。如果我在该表单中添加一个简单的模态对话框，那么对话框的打开就会触发组件进行自我更新，并且使字符数量发生变化。

```jsx
const Form = () => {
  // state for the dialog
  const [isOpen, setIsOpen] = useState(false);
  const ref = useRef();
  const numberOfLetters = ref.current?.length ?? 0;
  return (
    <>
      <input type="text" onChange={onChange} />
      {/* This will not change when you type in the field */}
      {/* Only when you open/close the dialog */}
      Characters count: {numberOfLetters}
      <button onClick={submit}>submit</button>
      {/* Adding dialog here */}
      <button onClick={() => setIsOpen(true)}>Open dialog</button>
      {isOpen ? <ModalDialog onClose={() => setIsOpen(false)} /> : null}
    </>
  );
};
```

> 交互式示例和完整代码
> https://advanced-react.com/examples/09/02

比这更有意思的是，如果将值作为基本类型的属性传递给下游组件，这些组件也不会接收到该值的变化。

想象一下，我想实现某种“搜索结果”组件。它会接收文本值作为属性，并在用户点击“显示结果”按钮时显示异步搜索结果：

```jsx
const SearchResults = ({ search }) => {
  const [showResults, setShowResults] = useState(false);
  return (
    <>
      Searching for: {search} <br />
      {/* This will trigger re-render */}
      <button onClick={() => setShowResults(!showResults)}>show results</button>
    </>
  );
};
```

如果我在保存值到 Ref 的表单里使用该组件，它就是无法正常工作。

```jsx
const Form = () => {
  const ref = useRef();
  const onChange = (e) => {
    ref.current = e.target.value;
  };
  return (
    <>
      <input type="text" onChange={onChange} />
      {/* will never be updated */}
      <SearchResults search={ref.current} />
    </>
  );
};
```

Ref 的更新永远不会触发重新渲染，因此 `SearchResults` 组件上的 `search` 属性永远不会被显式更新。即使我们通过点击 “显示结果” 按钮在 `SearchResults` 组件内部触发重新渲染，搜索值仍然是空字符串。

> 交互式示例和完整代码
> https://advanced-react.com/examples/09/03

## Ref 的更新是同步且可变的

第二个重大区别在于，Ref 的更新是同步的。毕竟，我们只是在修改一个对象，而在 JavaScript 中，这是一个同步操作。然而，状态更新通常是异步的。它甚至比异步更复杂：状态更新是以“快照”的方式运行的。React 有一个复杂的系统来管理状态更新，确保在一个“快照”内的数据和组件是一致的，并且能正确更新。

然而，Ref 并没有这些机制：我们只是直接修改一个对象，仅此而已。

当你在设置状态和 Ref 值之后，尝试在 onChange 回调中访问它们时，这种差异就会非常明显。

```jsx
const Form = () => {
  const [value, setValue] = useState();
  const onChange = (e) => {
    console.log("before", value);
    setValue(e.target.value);
    console.log("after", value); // same as before
  };
};
```

上述代码中 “before” 和 “after” 的值将是相同的。
当我们调用 setValue 时，并不会立即更新状态。我们只是在告知 React，在完成当前正在处理的所有任务后，需要安排一次使用新数据的状态更新。
而对于 Ref 来说，则恰恰相反：

```jsx
const Form = () => {
  const ref = useRef();
  const onChange = (e) => {
    console.log("before", ref.current);
    ref.current = e.target.value;
    console.log("after", ref.current); // already changed
  };
};
```

我们修改了一个对象，该对象中的数据会立即生效，但不会触发 React 生命周期中的任何操作。
